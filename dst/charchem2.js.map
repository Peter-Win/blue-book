{"version":3,"file":"charchem2.js","mappings":"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","sources":["webpack://charchem2/./src/ChemSys.ts","webpack://charchem2/./src/browser/AutoCompileConfig.ts","webpack://charchem2/./src/browser/addClass.ts","webpack://charchem2/./src/browser/autoCompile.ts","webpack://charchem2/./src/browser/documentCompile.ts","webpack://charchem2/./src/browser/renderFormulaCanvas.ts","webpack://charchem2/./src/browser/renderFormulaCfg.ts","webpack://charchem2/./src/browser/renderFormulaSvg.ts","webpack://charchem2/./src/compiler/ChainSys.ts","webpack://charchem2/./src/compiler/ChemCompiler.ts","webpack://charchem2/./src/compiler/compile.ts","webpack://charchem2/./src/compiler/funcs/funcBackground.ts","webpack://charchem2/./src/compiler/funcs/funcC.ts","webpack://charchem2/./src/compiler/funcs/funcColor.ts","webpack://charchem2/./src/compiler/funcs/funcDblAlign.ts","webpack://charchem2/./src/compiler/funcs/funcDots.ts","webpack://charchem2/./src/compiler/funcs/funcL.ts","webpack://charchem2/./src/compiler/funcs/funcM.ts","webpack://charchem2/./src/compiler/funcs/funcPadding.ts","webpack://charchem2/./src/compiler/funcs/funcPos.ts","webpack://charchem2/./src/compiler/funcs/funcSlope.ts","webpack://charchem2/./src/compiler/funcs/funcVer.ts","webpack://charchem2/./src/compiler/funcs/funcnM.ts","webpack://charchem2/./src/compiler/funcs/funcsDict.ts","webpack://charchem2/./src/compiler/main/BracketsCtrl.ts","webpack://charchem2/./src/compiler/main/MulCounter.ts","webpack://charchem2/./src/compiler/main/NodesBranch.ts","webpack://charchem2/./src/compiler/main/StackItem.ts","webpack://charchem2/./src/compiler/main/addNodeItem.ts","webpack://charchem2/./src/compiler/main/agent.ts","webpack://charchem2/./src/compiler/main/agentAnalyse.ts","webpack://charchem2/./src/compiler/main/autoCorrection.ts","webpack://charchem2/./src/compiler/main/bondCommon.ts","webpack://charchem2/./src/compiler/main/bondPolygonal.ts","webpack://charchem2/./src/compiler/main/bondRing.ts","webpack://charchem2/./src/compiler/main/bondSimple.ts","webpack://charchem2/./src/compiler/main/bondSpline.ts","webpack://charchem2/./src/compiler/main/bondUniversal.ts","webpack://charchem2/./src/compiler/main/brackets.ts","webpack://charchem2/./src/compiler/main/branch.ts","webpack://charchem2/./src/compiler/main/chemOp.ts","webpack://charchem2/./src/compiler/main/colors.ts","webpack://charchem2/./src/compiler/main/createLabel.ts","webpack://charchem2/./src/compiler/main/entity.ts","webpack://charchem2/./src/compiler/main/findNode.ts","webpack://charchem2/./src/compiler/main/item.ts","webpack://charchem2/./src/compiler/main/middlePoint.ts","webpack://charchem2/./src/compiler/main/multipier.ts","webpack://charchem2/./src/compiler/main/node.ts","webpack://charchem2/./src/compiler/parse/comment.ts","webpack://charchem2/./src/compiler/parse/isDigit.ts","webpack://charchem2/./src/compiler/parse/isSpace.ts","webpack://charchem2/./src/compiler/parse/parseNum.ts","webpack://charchem2/./src/compiler/parse/parsePadding.ts","webpack://charchem2/./src/compiler/parse/prepareText.ts","webpack://charchem2/./src/compiler/parse/scan.ts","webpack://charchem2/./src/compiler/parse/scanArgs.ts","webpack://charchem2/./src/compiler/parse/scanBondSuffix.ts","webpack://charchem2/./src/compiler/parse/scanCharge.ts","webpack://charchem2/./src/compiler/parse/scanCoeff.ts","webpack://charchem2/./src/compiler/parse/scanId.ts","webpack://charchem2/./src/compiler/parse/scanInt.ts","webpack://charchem2/./src/compiler/parse/scanOp.ts","webpack://charchem2/./src/compiler/parse/scanPostItem.ts","webpack://charchem2/./src/compiler/parse/skipSpaces.ts","webpack://charchem2/./src/compiler/preprocessor/Macros.ts","webpack://charchem2/./src/compiler/preprocessor/PreProcCtx.ts","webpack://charchem2/./src/compiler/preprocessor/bodyPreprocess.ts","webpack://charchem2/./src/compiler/preprocessor/defMacro.ts","webpack://charchem2/./src/compiler/preprocessor/execMacros.ts","webpack://charchem2/./src/compiler/preprocessor/mainPreProcess.ts","webpack://charchem2/./src/compiler/preprocessor/readFormalPars.ts","webpack://charchem2/./src/compiler/preprocessor/scanPar.ts","webpack://charchem2/./src/compiler/sourceMap/getSrcItemsForObject.ts","webpack://charchem2/./src/compiler/sourceMap/index.ts","webpack://charchem2/./src/compiler/state/stateAgent.ts","webpack://charchem2/./src/compiler/state/stateAgentBegin.ts","webpack://charchem2/./src/compiler/state/stateAgentIn.ts","webpack://charchem2/./src/compiler/state/stateAgentMid.ts","webpack://charchem2/./src/compiler/state/stateAgentSpace.ts","webpack://charchem2/./src/compiler/state/stateBegin.ts","webpack://charchem2/./src/compiler/state/stateBracketBegin.ts","webpack://charchem2/./src/compiler/state/stateCharge.ts","webpack://charchem2/./src/compiler/state/stateCommentIn.ts","webpack://charchem2/./src/compiler/state/stateCommentPre.ts","webpack://charchem2/./src/compiler/state/stateCustom.ts","webpack://charchem2/./src/compiler/state/stateElement.ts","webpack://charchem2/./src/compiler/state/stateFuncName.ts","webpack://charchem2/./src/compiler/state/stateNodeRef.ts","webpack://charchem2/./src/compiler/state/stateOpEnd.ts","webpack://charchem2/./src/compiler/state/statePostItem.ts","webpack://charchem2/./src/compiler/state/stateUniBond.ts","webpack://charchem2/./src/core/ChemAgent.ts","webpack://charchem2/./src/core/ChemAtom.ts","webpack://charchem2/./src/core/ChemBackground.ts","webpack://charchem2/./src/core/ChemBond.ts","webpack://charchem2/./src/core/ChemBracket.ts","webpack://charchem2/./src/core/ChemCharge.ts","webpack://charchem2/./src/core/ChemComma.ts","webpack://charchem2/./src/core/ChemComment.ts","webpack://charchem2/./src/core/ChemCustom.ts","webpack://charchem2/./src/core/ChemError.ts","webpack://charchem2/./src/core/ChemExpr.ts","webpack://charchem2/./src/core/ChemK.ts","webpack://charchem2/./src/core/ChemMul.ts","webpack://charchem2/./src/core/ChemNode.ts","webpack://charchem2/./src/core/ChemNodeItem.ts","webpack://charchem2/./src/core/ChemObj.ts","webpack://charchem2/./src/core/ChemOp.ts","webpack://charchem2/./src/core/ChemRadical.ts","webpack://charchem2/./src/core/ChemSubObj.ts","webpack://charchem2/./src/core/ElemList.ts","webpack://charchem2/./src/core/ElemRecord.ts","webpack://charchem2/./src/core/PeriodicTable.ts","webpack://charchem2/./src/core/StructAnalyzer.ts","webpack://charchem2/./src/core/isEmptyNode.ts","webpack://charchem2/./src/core/isNodeHidden.ts","webpack://charchem2/./src/core/isTextBrackets.ts","webpack://charchem2/./src/core/k2s.ts","webpack://charchem2/./src/core/makeChargeText.ts","webpack://charchem2/./src/drawSys/ChemImgProps.ts","webpack://charchem2/./src/drawSys/browser/HtmlCanvasLocalFont.ts","webpack://charchem2/./src/drawSys/browser/HtmlCanvasSurface.ts","webpack://charchem2/./src/drawSys/browser/SvgWebLocalFont.ts","webpack://charchem2/./src/drawSys/browser/SvgWebSurface.ts","webpack://charchem2/./src/drawSys/browser/WebFontCache.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/makeWebFontProps.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/traceBox.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/webFontWeight.ts","webpack://charchem2/./src/drawSys/browser/createBrowserChemImgProps.ts","webpack://charchem2/./src/drawSys/figures/FigBSpline.ts","webpack://charchem2/./src/drawSys/figures/FigEllipse.ts","webpack://charchem2/./src/drawSys/figures/FigFrame.ts","webpack://charchem2/./src/drawSys/figures/FigHashTrapezoid.ts","webpack://charchem2/./src/drawSys/figures/FigPath.ts","webpack://charchem2/./src/drawSys/figures/FigRect.ts","webpack://charchem2/./src/drawSys/figures/FigText.ts","webpack://charchem2/./src/drawSys/figures/Figure.ts","webpack://charchem2/./src/drawSys/figures/drawRect.ts","webpack://charchem2/./src/drawSys/figures/renderTopFrame.ts","webpack://charchem2/./src/drawSys/figures/rubber/braces.ts","webpack://charchem2/./src/drawSys/figures/rubber/closeBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/drawRubberFigure.ts","webpack://charchem2/./src/drawSys/figures/rubber/getRubberBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/openBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/scalePath.ts","webpack://charchem2/./src/drawSys/figures/rubber/squareBrackets.ts","webpack://charchem2/./src/drawSys/svg/SvgSurface.ts","webpack://charchem2/./src/drawSys/svg/standaloneExportOptions.ts","webpack://charchem2/./src/drawSys/svg/svgUtils/buildSvgText.ts","webpack://charchem2/./src/drawSys/utils/createLocalFontHash.ts","webpack://charchem2/./src/drawSys/utils/createRulesList.ts","webpack://charchem2/./src/drawSys/utils/fontFaceProps.ts","webpack://charchem2/./src/drawSys/utils/fontWeightValue.ts","webpack://charchem2/./src/drawSys/utils/pathToString.ts","webpack://charchem2/./src/drawSys/utils/scaleFontFace.ts","webpack://charchem2/./src/drawSys/utils/tracePath.ts","webpack://charchem2/./src/equation/ChemEquation.ts","webpack://charchem2/./src/equation/checkElementsMatching.ts","webpack://charchem2/./src/equation/coeffEnumerators.ts","webpack://charchem2/./src/equation/equationDict.ts","webpack://charchem2/./src/equation/isSuitableForEquation.ts","webpack://charchem2/./src/equation/makeSourceWithNewCoeffs.ts","webpack://charchem2/./src/getVersion.ts","webpack://charchem2/./src/inspectors/calcCharge.ts","webpack://charchem2/./src/inspectors/calcMass.ts","webpack://charchem2/./src/inspectors/isAbstract.ts","webpack://charchem2/./src/inspectors/isTextFormula.ts","webpack://charchem2/./src/inspectors/locateAtomNumber.ts","webpack://charchem2/./src/inspectors/makeBruttoKey.ts","webpack://charchem2/./src/inspectors/makeElemList.ts","webpack://charchem2/./src/inspectors/makeTextFormula.ts","webpack://charchem2/./src/lang/Lang.ts","webpack://charchem2/./src/lang/baseDictEn.ts","webpack://charchem2/./src/lang/baseDictRu.ts","webpack://charchem2/./src/lang/index.ts","webpack://charchem2/./src/lang/replaceLangParams.ts","webpack://charchem2/./src/math/Matrix2x3.ts","webpack://charchem2/./src/math/Point.ts","webpack://charchem2/./src/math/Rational.ts","webpack://charchem2/./src/math/Rect.ts","webpack://charchem2/./src/math/angles.ts","webpack://charchem2/./src/math/index.ts","webpack://charchem2/./src/math/massUtils.ts","webpack://charchem2/./src/math/radians.ts","webpack://charchem2/./src/structBuilder/NodeInfo.ts","webpack://charchem2/./src/structBuilder/applyPadding.ts","webpack://charchem2/./src/structBuilder/bond/clipLine.ts","webpack://charchem2/./src/structBuilder/bond/clipLineByNode.ts","webpack://charchem2/./src/structBuilder/bond/doubleBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBezierBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBondAB.ts","webpack://charchem2/./src/structBuilder/bond/drawBondArrow.ts","webpack://charchem2/./src/structBuilder/bond/drawBondPoly.ts","webpack://charchem2/./src/structBuilder/bond/getBondColor.ts","webpack://charchem2/./src/structBuilder/bond/getBondStyleWidth.ts","webpack://charchem2/./src/structBuilder/bond/singleLine.ts","webpack://charchem2/./src/structBuilder/bond/softBondTemplate.ts","webpack://charchem2/./src/structBuilder/bond/tripleBond.ts","webpack://charchem2/./src/structBuilder/bond/wedgeBond.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmd.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBrClose.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBrOpen.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBridge.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdMul.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdMulBridge.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdNode.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdSoftBond.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/Clusters.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/PAgentCtx.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/brackets/processBrackets.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/buildAgentPrior.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/createAgentCmd.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/createCoeff.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawAllBonds.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawBackground.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawMul.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/findAgentCenter.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/prepareNodes.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/processCommands.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/unwind.ts","webpack://charchem2/./src/structBuilder/buildExpression.ts","webpack://charchem2/./src/structBuilder/buildFrame.ts","webpack://charchem2/./src/structBuilder/buildItem.ts","webpack://charchem2/./src/structBuilder/buildNode.ts","webpack://charchem2/./src/structBuilder/buildOp.ts","webpack://charchem2/./src/structBuilder/drawCharge.ts","webpack://charchem2/./src/structBuilder/drawLewisShell.ts","webpack://charchem2/./src/structBuilder/drawText.ts","webpack://charchem2/./src/structBuilder/drawTextNear.ts","webpack://charchem2/./src/structBuilder/drawTextWithMarkup.ts","webpack://charchem2/./src/structBuilder/getTextInternalRect.ts","webpack://charchem2/./src/table/CellRender.ts","webpack://charchem2/./src/table/TableRulesEasyChemistry.ts","webpack://charchem2/./src/table/TableRulesShort.ts","webpack://charchem2/./src/table/TableRulesStd.ts","webpack://charchem2/./src/table/TableRulesWide.ts","webpack://charchem2/./src/table/drawPeriodicTable.ts","webpack://charchem2/./src/table/fallingNumbers.ts","webpack://charchem2/./src/table/findCategory.ts","webpack://charchem2/./src/table/tableCategories.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/addItemProps.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/buildTextNodes.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/cloneTextNode.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/correctBondsDirection.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/createTextOp.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/dictKeys.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/index.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/optimizeColors.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitColumn.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitRichText.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitScripts.ts","webpack://charchem2/./src/textBuilder/charChem/CCTNode.ts","webpack://charchem2/./src/textBuilder/charChem/buildCharChemText.ts","webpack://charchem2/./src/textBuilder/charChem/buildCharChemTextNodes.ts","webpack://charchem2/./src/textBuilder/htmlPoor/OptionsHtmlPoor.ts","webpack://charchem2/./src/textBuilder/htmlPoor/htmlPoor.ts","webpack://charchem2/./src/textBuilder/htmlPoor/htmlPoorNodes.ts","webpack://charchem2/./src/textBuilder/htmlPoor/index.ts","webpack://charchem2/./src/textBuilder/htmlRich/HtmlRichClasses.ts","webpack://charchem2/./src/textBuilder/htmlRich/buildHtmlRich.ts","webpack://charchem2/./src/textBuilder/htmlRich/cchOperation.ts","webpack://charchem2/./src/textBuilder/htmlRich/createHtmlRichNodes.ts","webpack://charchem2/./src/textBuilder/htmlRich/makeCchTag.ts","webpack://charchem2/./src/textBuilder/mathml/MathMLOptions.ts","webpack://charchem2/./src/textBuilder/mathml/buildMathML.ts","webpack://charchem2/./src/textBuilder/mathml/createMathMLNode.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathColumn.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathItem.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathOptRow.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathRichText.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathScripted.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathText.ts","webpack://charchem2/./src/textBuilder/mathml/utils/onNodeItem.ts","webpack://charchem2/./src/textBuilder/tex/buildTeX.ts","webpack://charchem2/./src/textBuilder/tex/replaceSpecialTeXSymbols.ts","webpack://charchem2/./src/textBuilder/tex/texColors.ts","webpack://charchem2/./src/textBuilder/textFormula.ts","webpack://charchem2/./src/textBuilder/text/buildTextFormat.ts","webpack://charchem2/./src/textBuilder/xmlNode/addClassToXmlNode.ts","webpack://charchem2/./src/textBuilder/xmlNode/optimizeXmlColors.ts","webpack://charchem2/./src/textBuilder/xmlNode/renderXmlNode.ts","webpack://charchem2/./src/textRules/RulesBase.ts","webpack://charchem2/./src/textRules/dictTextRules.ts","webpack://charchem2/./src/textRules/rulesBB.ts","webpack://charchem2/./src/textRules/rulesCharChem.ts","webpack://charchem2/./src/textRules/rulesHtml.ts","webpack://charchem2/./src/textRules/rulesMhchem.ts","webpack://charchem2/./src/textRules/rulesRTF.ts","webpack://charchem2/./src/textRules/rulesText.ts","webpack://charchem2/./src/types/CoeffPos.ts","webpack://charchem2/./src/utils/addAll.ts","webpack://charchem2/./src/utils/addAllSet.ts","webpack://charchem2/./src/utils/cmp.ts","webpack://charchem2/./src/utils/color/colorHex.ts","webpack://charchem2/./src/utils/color/colorNamesMap.ts","webpack://charchem2/./src/utils/color/colorRgb.ts","webpack://charchem2/./src/utils/color/getRgbSamples.ts","webpack://charchem2/./src/utils/color/parseColorCss.ts","webpack://charchem2/./src/utils/color/traceColor.ts","webpack://charchem2/./src/utils/delay.ts","webpack://charchem2/./src/utils/getItemForced.ts","webpack://charchem2/./src/utils/ifDef.ts","webpack://charchem2/./src/utils/isSubStr.ts","webpack://charchem2/./src/utils/lastItem.ts","webpack://charchem2/./src/utils/listToDict.ts","webpack://charchem2/./src/utils/markup.ts","webpack://charchem2/./src/utils/removeItem.ts","webpack://charchem2/./src/utils/romanNum.ts","webpack://charchem2/./src/utils/xml/drawTag.ts","webpack://charchem2/./src/utils/xml/escapeXml.ts","webpack://charchem2/./src/utils/xml/textInsideTag.ts","webpack://charchem2/./src/version.ts","webpack://charchem2/webpack/bootstrap","webpack://charchem2/./src/index.ts"],"sourcesContent":["import { AutoCompileConfig } from \"./browser/AutoCompileConfig\";\nimport { renderFormulaCfg } from \"./browser/renderFormulaCfg\";\nimport { compile } from \"./compiler/compile\";\nimport { ChemExpr } from \"./core/ChemExpr\";\nimport { ChemObj } from \"./core/ChemObj\";\nimport { getVersion, getVersionStr } from \"./getVersion\";\nimport { makeBruttoKey } from \"./inspectors/makeBruttoKey\";\nimport { isAbstract } from \"./inspectors/isAbstract\";\nimport { Lang, LangParams, LocalDict } from \"./lang\";\nimport { calcMass } from \"./inspectors/calcMass\";\nimport { ChemAtom } from \"./core/ChemAtom\";\nimport { findElement } from \"./core/PeriodicTable\";\nimport { drawPeriodicTable } from \"./table/drawPeriodicTable\";\nimport { documentCompile } from \"./browser/documentCompile\";\nimport { tableRulesStd } from \"./table/TableRulesStd\";\nimport { tableRulesWide } from \"./table/TableRulesWide\";\nimport { tableRulesEasyChemistry } from \"./table/TableRulesEasyChemistry\";\nimport { TableRules } from \"./table/TableRules\";\nimport { tableRulesShort } from \"./table/TableRulesShort\";\nimport {\n  categoryBlock,\n  categoryBlockDLa,\n  categoryProps,\n  TCategories,\n} from \"./table/tableCategories\";\nimport { findCategory } from \"./table/findCategory\";\nimport { ChemAgent } from \"./core/ChemAgent\";\nimport { XmlAttrs } from \"./utils/xml/xmlTypes\";\nimport { drawTag } from \"./utils/xml/drawTag\";\nimport { escapeXml } from \"./utils/xml/escapeXml\";\nimport { calcCharge } from \"./inspectors/calcCharge\";\nimport { roundMass } from \"./math/massUtils\";\nimport { makeFormulaSvgText } from \"./browser/renderFormulaSvg\";\nimport { WebFontCache } from \"./drawSys/browser/WebFontCache\";\nimport { ChemEquation } from \"./equation/ChemEquation\";\nimport { RulesBase } from \"./textRules/RulesBase\";\nimport { makeTextFormula } from \"./inspectors/makeTextFormula\";\nimport { dictTextRules } from \"./textRules/dictTextRules\";\nimport {\n  textFormula,\n  FmtDef,\n  FmtType,\n  textTypes,\n} from \"./textBuilder/textFormula\";\n\nexport const ChemSys = Object.freeze({\n  addDict(globalDict: Record<string, LocalDict>) {\n    Lang.addDict(globalDict);\n  },\n  get ver(): number[] {\n    return getVersion();\n  },\n  get verStr(): string {\n    return getVersionStr();\n  },\n  compile(formula: string): ChemExpr {\n    return compile(formula);\n  },\n  documentCompile(cfg: AutoCompileConfig = {}) {\n    return documentCompile(cfg);\n  },\n  draw(\n    owner: Element,\n    exprOrCode: ChemExpr | ChemAgent | string,\n    config?: AutoCompileConfig\n  ): boolean {\n    renderFormulaCfg(owner, exprOrCode, config ?? {});\n    return true;\n  },\n  makeSVG(\n    exprOrCode: ChemExpr | ChemAgent | string,\n    fontPropsCache?: WebFontCache\n  ): string {\n    const expr =\n      typeof exprOrCode === \"string\" ? compile(exprOrCode) : exprOrCode;\n    return makeFormulaSvgText(expr, fontPropsCache);\n  },\n  /**\n   * @deprecated next version: ChemSys.textFormula()\n   * @param objOrCode if string, then formula code, else ChemObj (usually ChemExpr)\n   * @param rules by default = dictTextRules.text\n   * @returns\n   */\n  makeTextFormula(objOrCode: ChemObj | string, rules?: RulesBase): string {\n    const chemObj =\n      typeof objOrCode === \"string\" ? compile(objOrCode) : objOrCode;\n    return makeTextFormula(chemObj, rules);\n  },\n  /**\n   * @deprecated next version: ChemSys.testTypesList (for ChemSys.textFormula())\n   */\n  dictTextRules,\n\n  textFormula(\n    objOrCode: ChemObj | string,\n    fmtOrType: FmtDef | FmtType\n  ): string {\n    return textFormula(objOrCode, fmtOrType);\n  },\n  get textTypesList(): readonly FmtType[] {\n    return textTypes;\n  },\n\n  makeBruttoKey(src: ChemObj | string): string {\n    return makeBruttoKey(src);\n  },\n  makeBrutto(src: ChemObj | string): ChemExpr {\n    return compile(makeBruttoKey(src));\n  },\n  lang(key: string, params?: LangParams, langId?: string): string {\n    return Lang.tr(key, params, langId);\n  },\n  get curLang(): string {\n    return Lang.curLang;\n  },\n  set curLang(locale: string) {\n    Lang.curLang = locale;\n  },\n  get navLang(): string | undefined {\n    return Lang.navLang;\n  },\n  get Dict(): Record<string, LocalDict> {\n    return Lang.dict;\n  },\n  isAbstract(chemObj: ChemObj): boolean {\n    return isAbstract(chemObj);\n  },\n  calcMass(chemObj: ChemObj, applyAgentK?: boolean): number {\n    return calcMass(chemObj, applyAgentK);\n  },\n  roundMass(mass: number): number {\n    return roundMass(mass);\n  },\n  calcCharge(chemObj: ChemObj): number {\n    return calcCharge(chemObj);\n  },\n  findElem(id: string): ChemAtom | undefined {\n    return findElement(id);\n  },\n  drawTable(rules?: TableRules): string {\n    return drawPeriodicTable(rules);\n  },\n  findCategory(table: TCategories, elemId: string, locale?: string) {\n    return findCategory(table, elemId, locale);\n  },\n  TblRules: {\n    Std: tableRulesStd,\n    Wide: tableRulesWide,\n    Short: tableRulesShort,\n    EasyChemistry: tableRulesEasyChemistry,\n  },\n  TblCategory: {\n    block: categoryBlock,\n    blockDLa: categoryBlockDLa,\n    props: categoryProps,\n  },\n  drawTag(tag: string, attrs: XmlAttrs, content?: string | number): string {\n    return content === undefined\n      ? drawTag(tag, attrs, true)\n      : `${drawTag(tag, attrs)}${escapeXml(String(content))}</${tag}>`;\n  },\n  esc(content: string | number): string {\n    return escapeXml(String(content));\n  },\n\n  /**\n   * Solving a chemical equation\n   * @param equation example: \"H2 + O2 = H2O\"\n   * @returns Its recommended to use result.isOk() or getMessage() to check a result expression.\n   *   You can use result.src and result.getAgents() to get results of equalize\n   */\n  equalize(equation: string): ChemExpr {\n    const eq = new ChemEquation();\n    eq.initBySrc(equation);\n    eq.solve();\n    if (!eq.isSolved()) {\n      return ChemExpr.createWithError(eq.makeError(), equation);\n    }\n    return eq.getExpr()!;\n  },\n});\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { RulesHtml } from \"../textRules/rulesHtml\";\n\nexport type DrawSysId = \"svg\" | \"canvas\";\n\nexport interface AutoCompileConfig {\n  nonText?: boolean; // default: false. If true, then text format is not used\n  drawSysId?: DrawSysId; // default: svg\n  formulaSelector?: string; // default: .echem-formula\n  fontPropsCache?: WebFontCache;\n  rules?: RulesHtml;\n}\n\nexport const DrawSysIds: Record<DrawSysId, boolean> = {\n  svg: true,\n  canvas: true,\n};\n","export const addClass = (elem: Element, className: string) => {\n  if (elem.classList) {\n    elem.classList.add(className);\n  } else {\n    const cls: string | null = elem.getAttribute(\"class\");\n    const clsList: string[] = cls ? cls.split(\" \") : [];\n    const clsSet = new Set<string>(clsList);\n    clsSet.add(className);\n    elem.setAttribute(\"class\", Array.from(clsSet).join(\" \"));\n  }\n};\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { AutoCompileConfig, DrawSysId, DrawSysIds } from \"./AutoCompileConfig\";\nimport { documentCompile } from \"./documentCompile\";\n\nexport const fontPropsCache = new WebFontCache();\n\nexport const autoCompile = () => {\n  if (!document) return;\n  const nodes = document.querySelectorAll(\n    \".easyChemConfig,.CharChemConfig,body.echem-auto-compile\"\n  );\n  if (nodes.length === 0) return;\n  const cfgNode = nodes[nodes.length - 1]!;\n  const cfg: AutoCompileConfig = {\n    fontPropsCache,\n  };\n\n  const drawSys = cfgNode.getAttribute(\"data-drawsys\");\n  if (typeof drawSys === \"string\") {\n    const drawSysId = drawSys.toLowerCase();\n    if (drawSysId in DrawSysIds) {\n      cfg.drawSysId = drawSysId as DrawSysId;\n    }\n  }\n\n  const useText = cfgNode.getAttribute(\"data-usetext\");\n  if (typeof useText === \"string\") {\n    const useTextLow = useText.toLowerCase();\n    cfg.nonText = useTextLow === \"no\";\n  }\n\n  documentCompile(cfg);\n};\n\nexport const addAutoCompileEvent = () => {\n  window?.addEventListener(\"DOMContentLoaded\", autoCompile);\n};\n","import { delay } from \"../utils/delay\";\nimport { AutoCompileConfig } from \"./AutoCompileConfig\";\nimport { renderFormulaCfg } from \"./renderFormulaCfg\";\n\nexport const documentCompile = async (\n  config: AutoCompileConfig\n): Promise<void> => {\n  if (!document) return Promise.reject(new Error(\"Document expected\"));\n  try {\n    const selector = config.formulaSelector ?? \".echem-formula\";\n    const list = document.querySelectorAll(selector);\n    // Тут могут быть разные реализации. Например, webworker или lazy-view\n    // Но пока просто делаем перерыв после каждой отрисовки, чтобы браузер мог получать управление между ними\n    // не подходит queueMicrotask. Нужно создавать макрозадачу\n    let i = 0;\n    let elem = list[i++];\n    while (elem) {\n      elementCompile(elem, config);\n      elem = list[i++];\n      // eslint-disable-next-line no-await-in-loop\n      await delay(1);\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  return Promise.resolve();\n};\n\nexport const elementCompile = (elem: Element, config: AutoCompileConfig) => {\n  // @ts-ignore\n  const code = elem.textContent ?? elem.innerText;\n  renderFormulaCfg(elem, code, config);\n};\n","import { createBrowserChemImgProps } from \"../drawSys/browser/createBrowserChemImgProps\";\nimport { renderTopFrame } from \"../drawSys/figures/renderTopFrame\";\nimport { HtmlCanvasSurface } from \"../drawSys/browser/HtmlCanvasSurface\";\nimport { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { buildFrame } from \"../structBuilder/buildFrame\";\nimport { addClass } from \"./addClass\";\n\nexport const renderFormulaCanvas = (\n  owner: Element,\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n): void => {\n  if (!document) return;\n  // eslint-disable-next-line no-param-reassign\n  owner.innerHTML = \"\"; // clear owner's content\n  const canvas = document.createElement(\"canvas\");\n  owner.append(canvas);\n  const surface = new HtmlCanvasSurface(canvas, fontPropsCache);\n  const props = createBrowserChemImgProps(owner, surface);\n  renderTopFrame(buildFrame(expr, props), surface);\n  addClass(owner, \"echem-is-canvas\");\n};\n","import { ChemAgent } from \"../core/ChemAgent\";\nimport { compile } from \"../compiler/compile\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\nimport { AutoCompileConfig } from \"./AutoCompileConfig\";\nimport { renderFormulaCanvas } from \"./renderFormulaCanvas\";\nimport { renderFormulaSvg } from \"./renderFormulaSvg\";\nimport { addClass } from \"./addClass\";\nimport { textFormula } from \"../textBuilder/textFormula\";\n\nexport const renderFormulaCfg = (\n  owner: Element,\n  exprOrCode: ChemExpr | ChemAgent | string,\n  config: AutoCompileConfig\n): void => {\n  const expr =\n    typeof exprOrCode === \"string\" ? compile(exprOrCode) : exprOrCode;\n  if (expr instanceof ChemExpr && !expr.isOk()) {\n    owner.classList?.add(\"echem-error\");\n    owner.setAttribute(\"title\", expr.getMessage());\n  } else {\n    const canText = !config.nonText && isTextFormula(expr);\n    if (canText) {\n      // eslint-disable-next-line no-param-reassign\n      owner.innerHTML = textFormula(expr, \"html\");\n      addClass(owner, \"echem-is-text\");\n    } else if (config.drawSysId === \"canvas\") {\n      renderFormulaCanvas(owner, expr, config.fontPropsCache);\n    } else {\n      renderFormulaSvg(owner, expr, config.fontPropsCache);\n    }\n    if (expr instanceof ChemExpr) {\n      owner.setAttribute(\"data-src\", expr.src0.trim());\n    }\n  }\n};\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { SvgWebSurface } from \"../drawSys/browser/SvgWebSurface\";\nimport { createBrowserChemImgProps } from \"../drawSys/browser/createBrowserChemImgProps\";\nimport { renderTopFrame } from \"../drawSys/figures/renderTopFrame\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { buildFrame } from \"../structBuilder/buildFrame\";\nimport { standaloneExportOptions } from \"../drawSys/svg/standaloneExportOptions\";\nimport { addClass } from \"./addClass\";\n\n/**\n * Make a local SVG image for the specified expression on the given HTML element.\n * @param owner HTML element. The content will be completely replaced by the SVG image.\n * @param expr\n */\nexport const renderFormulaSvg = (\n  owner: Element,\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n) => {\n  if (typeof document === \"undefined\") return;\n  const surface = new SvgWebSurface(fontPropsCache);\n  const props = createBrowserChemImgProps(owner, surface);\n  const frame = buildFrame(expr, props);\n  renderTopFrame(frame, surface);\n  const { bounds } = frame;\n  // eslint-disable-next-line no-param-reassign\n  owner.innerHTML = surface.exportText({\n    width: `${bounds.width}px`,\n    height: `${bounds.height}px`,\n  });\n  addClass(owner, \"echem-is-svg\");\n};\n\nexport const makeFormulaSvgText = (\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n) => {\n  if (typeof document === \"undefined\") return \"\";\n  const tmp = document.createElement(\"div\");\n  tmp.setAttribute(\"class\", \"echem-formula\");\n  try {\n    document.body.append(tmp);\n    const surface = new SvgWebSurface(fontPropsCache);\n    const props = createBrowserChemImgProps(tmp, surface);\n    const frame = buildFrame(expr, props);\n    renderTopFrame(frame, surface);\n    const { bounds } = frame;\n    return surface.exportText({\n      ...standaloneExportOptions,\n      width: `${bounds.width}px`,\n      height: `${bounds.height}px`,\n    });\n  } finally {\n    tmp.remove();\n  }\n};\n","/* eslint-disable no-param-reassign */\nimport { Point } from \"../math/Point\";\nimport { Int } from \"../types\";\nimport { ChemCompiler } from \"./ChemCompiler\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { ChemBond } from \"../core/ChemBond\";\n\nlet baseChainId = 1;\nconst generateChainId = (): Int => baseChainId++;\n\nlet baseSubChainId = 1;\nconst generateSubChainId = (): Int => baseSubChainId++;\n\ntype BondOptional = ChemBond | undefined;\n\nexport class ChainSys {\n  private readonly compiler: ChemCompiler;\n\n  constructor(compiler: ChemCompiler) {\n    this.compiler = compiler;\n  }\n\n  private chainsDict: Record<Int, Set<Int>> = {};\n\n  private subChainsDict: Record<Int, ChemNode[]> = {};\n\n  private curChainId = 0;\n\n  curSubChainId = 0;\n\n  private lastBond: BondOptional;\n\n  private stack: BondOptional[] = [];\n\n  getLastBond(): BondOptional {\n    return this.lastBond;\n  }\n\n  onBranchBegin() {\n    this.stack.unshift(this.lastBond);\n  }\n\n  onBranchEnd() {\n    this.lastBond = this.stack.shift();\n  }\n\n  private createChain(): Int {\n    this.lastBond = undefined;\n    const newChainId = generateChainId();\n    this.chainsDict[newChainId] = new Set();\n    return newChainId;\n  }\n\n  private getCurChain(): Set<Int> {\n    if (this.curChainId === 0) {\n      this.curChainId = this.createChain();\n    }\n    return this.chainsDict[this.curChainId]!;\n  }\n\n  createSubChain(): Int {\n    this.lastBond = undefined;\n    const newId = generateSubChainId();\n    this.curSubChainId = newId;\n    this.subChainsDict[newId] = [];\n    this.getCurChain().add(newId);\n    return newId;\n  }\n\n  private getCurSubChain(): ChemNode[] {\n    if (this.curSubChainId === 0) {\n      this.curSubChainId = this.createSubChain();\n    }\n    return this.subChainsDict[this.curSubChainId]!;\n  }\n\n  addNode(node: ChemNode) {\n    if (node.chain === 0) {\n      this.getCurSubChain().push(node);\n      node.chain = this.curChainId;\n      node.subChain = this.curSubChainId;\n    } else {\n      this.curChainId = node.chain;\n      this.curSubChainId = node.subChain;\n    }\n  }\n\n  setCurNode(node: ChemNode) {\n    this.curChainId = node.chain;\n    this.curSubChainId = node.subChain;\n  }\n\n  addBond(bond: ChemBond) {\n    if (bond.soft) {\n      this.createSubChain();\n    }\n    this.lastBond = bond;\n  }\n\n  private mergeSubChains(dstId: Int, srcId: Int, step: Point) {\n    if (dstId === srcId) {\n      return;\n    }\n    const nodes: ChemNode[] = this.subChainsDict[srcId]!;\n    nodes.forEach((it) => {\n      it.subChain = dstId;\n      it.pt.iadd(step);\n    });\n    const dstNodes = this.subChainsDict[dstId];\n    if (dstNodes) nodes.forEach((it) => dstNodes.push(it));\n    delete this.subChainsDict[srcId];\n    if (this.curSubChainId === srcId) {\n      this.curSubChainId = dstId;\n    }\n  }\n\n  /**\n   * scrChain присоединяется к dstChain\n   */\n  private mergeChains(srcNode: ChemNode, dstNode: ChemNode) {\n    const srcChainId = srcNode.chain;\n    const dstChainId = dstNode.chain;\n    if (srcChainId !== dstChainId) {\n      this.compiler\n        .curAgent!.nodes.filter((it) => it.chain === srcChainId)\n        .forEach((it) => {\n          it.chain = dstChainId;\n        });\n    }\n  }\n\n  private makeTransitionBond(bond: ChemBond) {\n    bond.soft = false;\n    bond.dir = undefined;\n    const node1 = bond.nodes[1];\n    if (node1) {\n      this.addNode(node1);\n    }\n  }\n\n  /**\n   * Связь, у которой второй узел указан через ссылку\n   */\n  bondToRef(bond: ChemBond) {\n    const [srcNode, dstNode] = bond.nodes;\n    if (!srcNode || !dstNode) {\n      return;\n    }\n    // Если узлы принадлежат разным цепям, то нужно срастить две цепи\n    const srcSubChain: Int = srcNode.subChain;\n    const dstSubChain: Int = dstNode.subChain;\n    if (srcSubChain !== dstSubChain) {\n      // Если разные подцепи соединяются мягкой связью, то они остаются разными\n      // иначе подцепи сращиваются\n      if (!bond.soft) {\n        // Если цепи разные, то их нужно объединить\n        const srcChain: Int = srcNode.chain;\n        const dstChain: Int = dstNode.chain;\n        if (srcChain !== dstChain) {\n          this.mergeChains(srcNode, dstNode);\n          const step = dstNode.pt.minus(srcNode.pt).minus(bond.dir!);\n          this.mergeSubChains(dstSubChain, srcSubChain, step);\n        } else {\n          // Если цепь одна, но разные подцепи, то это переходная связь\n          this.makeTransitionBond(bond);\n        }\n      }\n    } else {\n      // Но если узлы в одной подцепи, то корректировать шаг связи\n      bond.dir = dstNode.pt.minus(srcNode.pt);\n    }\n    this.compiler.curNode = dstNode;\n    this.curChainId = dstNode.chain;\n    this.curSubChainId = dstNode.subChain;\n  }\n\n  changeBondToHard(bond: ChemBond) {\n    const dstNode = bond.nodes[0];\n    if (dstNode) {\n      const srcNode = bond.nodes[1];\n      if (srcNode) {\n        if (srcNode.chain !== dstNode.chain) {\n          throw Error(\"Different chains\");\n        }\n        this.mergeSubChains(\n          dstNode.subChain,\n          srcNode.subChain,\n          bond.dir ?? new Point()\n        );\n      }\n      this.curSubChainId = dstNode.subChain;\n      this.curChainId = dstNode.chain;\n    }\n  }\n\n  closeChain() {\n    this.curChainId = 0;\n    this.curSubChainId = 0;\n    this.lastBond = undefined;\n  }\n\n  closeSubChain() {\n    this.curSubChainId = 0;\n    this.lastBond = undefined;\n  }\n\n  findNode(pt: Point): ChemNode | undefined {\n    return this.getCurSubChain().find((it) => it.pt.equals(pt));\n  }\n}\n","import { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { Int, Double, Char } from \"../types\";\nimport { LangParams } from \"../lang\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { LewisDot } from \"../core/ChemNodeItem\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { BondAlign, ChemBond } from \"../core/ChemBond\";\nimport { ChemChargeOwner } from \"../core/ChemChargeOwner\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { ChemError } from \"../core/ChemError\";\n\nimport { ChainSys } from \"./ChainSys\";\nimport { MiddlePoint } from \"./types\";\nimport { MulCounter } from \"./main/MulCounter\";\nimport { NodesBranch } from \"./main/NodesBranch\";\nimport { StackItem } from \"./main/StackItem\";\n\nimport { stateBegin } from \"./state/stateBegin\";\nimport { prepareText } from \"./parse/prepareText\";\nimport { BracketsCtrl } from \"./main/BracketsCtrl\";\nimport { ParamsChemBackground } from \"../core/ChemBackground\";\nimport { ChemCompilerOptions } from \"./ChemCompilerOptions\";\nimport { SrcMapItem, SpecPart } from \"./sourceMap\";\n\nexport type CompilerState = (c: ChemCompiler) => Int;\n\nexport class ChemCompiler {\n  readonly srcText: string;\n\n  readonly options: ChemCompilerOptions;\n\n  constructor(srcText: string, options?: ChemCompilerOptions) {\n    this.srcText = srcText;\n    this.options = options ?? {};\n    if (this.options.srcMap) {\n      this.srcMap = [];\n      this.expr.srcMap = this.srcMap;\n    }\n  }\n\n  readonly expr = new ChemExpr();\n\n  text = \"\";\n\n  pos = 0;\n\n  srcMap?: SrcMapItem[];\n\n  curState: CompilerState = stateBegin;\n\n  curEntity?: ChemObj;\n\n  curOp?: ChemOp;\n\n  curAgent?: ChemAgent;\n\n  agentMode?: \"begin\" | \"in\";\n\n  curNode?: ChemNode;\n\n  curBond?: ChemBond;\n\n  chargeOwner?: ChemChargeOwner; // Объект, к которому применится конструкция ^\n\n  curPart: Int = 0;\n\n  elementStartPos: Int = 0;\n\n  preComm?: ChemComment;\n\n  preCommPos?: number;\n\n  readonly chainSys = new ChainSys(this);\n\n  references: Record<string, ChemNode> = {};\n\n  readonly mulCounter: MulCounter = new MulCounter();\n\n  readonly varsDict: Record<string, Double> = {};\n\n  curWidth = 0;\n\n  readonly nodesBranch = new NodesBranch();\n\n  readonly bracketsCtrl = new BracketsCtrl();\n\n  readonly middlePoints: MiddlePoint[] = [];\n\n  private readonly stack: StackItem[] = [];\n\n  background?: ParamsChemBackground;\n\n  push(item: StackItem) {\n    this.stack.unshift(item);\n  }\n\n  pop(): StackItem | undefined {\n    return this.stack.shift();\n  }\n\n  private altFlag: boolean = false;\n\n  setAltFlag() {\n    this.altFlag = true;\n  }\n\n  getAltFlag(): boolean {\n    const value = this.altFlag;\n    this.altFlag = false;\n    return value;\n  }\n\n  varSlope: Double = 0.0;\n\n  varLength: Double = 1.0;\n\n  varMass?: Double; // special mass for next element - $M()\n\n  varAtomNumber?: Int | \"\"; // number in $nM(mass, number)\n\n  varColor?: string;\n\n  varItemColor?: string;\n\n  varItemColor1?: string;\n\n  varAtomColor?: string;\n\n  varAtomColor1?: string;\n\n  varAlign?: BondAlign;\n\n  varPadding: number[] = [];\n\n  centralNode: boolean = false;\n\n  varDots?: LewisDot[] = undefined;\n\n  varPos?: CoeffPosOrAngle = undefined;\n\n  entityBegin?: number;\n\n  eject<K extends \"varPos\" | \"varDots\" | \"entityBegin\" | \"preCommPos\">(\n    key: K\n  ): ChemCompiler[K] {\n    const v = this[key];\n    this[key] = undefined;\n    return v;\n  }\n\n  curChar(): Char {\n    return this.text[this.pos]!;\n  }\n\n  nextChar(): Char {\n    return this.text[this.pos + 1]!;\n  }\n\n  subStr(startPos: Int): string {\n    return this.text.slice(startPos, this.pos);\n  }\n\n  isFinish(): boolean {\n    return this.pos >= this.text.length;\n  }\n\n  /**\n   * Специальная функция сравнения, соответствует ли указанная строка value\n   * содержимому text, начиная с позиции pos\n   */\n  isCurPosEq(value: string): boolean {\n    return (\n      value ===\n      this.text.slice(\n        this.pos,\n        Math.min(this.text.length, this.pos + value.length)\n      )\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  error(msgId: string, params: LangParams): never {\n    const newParams = { ...params };\n    const { pos } = newParams;\n    if (typeof pos === \"number\") {\n      newParams.pos = pos + 1;\n    }\n    throw new ChemError(msgId, newParams);\n  }\n\n  setState(newState: CompilerState, deltaPos: Int = 0): Int {\n    this.curState = newState;\n    return deltaPos;\n  }\n\n  addSrcMapItem(obj: ChemObj, begin?: number, part?: SpecPart) {\n    const { srcMap, pos: end } = this;\n    if (begin !== undefined && srcMap) {\n      srcMap.push({ begin, end, obj, part });\n    }\n  }\n}\n\nexport const createTestCompiler = (text: string): ChemCompiler => {\n  const compiler = new ChemCompiler(text);\n  prepareText(compiler);\n  return compiler;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemCompiler } from \"./ChemCompiler\";\nimport { ChemCompilerOptions } from \"./ChemCompilerOptions\";\nimport { closeEntity } from \"./main/entity\";\nimport { prepareText } from \"./parse/prepareText\";\n\nexport const compile = (\n  text: string,\n  options?: ChemCompilerOptions\n): ChemExpr => {\n  const compiler = new ChemCompiler(text, options);\n  try {\n    prepareText(compiler);\n    while (!compiler.isFinish()) {\n      const step = compiler.curState(compiler);\n      compiler.pos += step;\n    }\n    closeEntity(compiler);\n  } catch (e) {\n    compiler.expr.error = e;\n  }\n  return compiler.expr;\n};\n","/**\n * Границы:\n *  Фон по-умолчанию применяется к следующему узлу, но можно указать иные узлы.\n *  Либо: весь агент\n *  Если функция в конце выражения или объявляется несколько подряд, то у них нет узла и их надо указать явно.\n * фон должен захватить все указанные узлы\n * Фигура: rect (default), round, ellipse\n * r (borderRadius) для rect\n * padding\n * fill\n * stroke\n * width\n *\n * Если формула нескольео раз использует похожий набор параметров, можно использовать макрос\n */\n\nimport { ChemNode } from \"../../core/ChemNode\";\nimport {\n  ChemBackground,\n  ParamsChemBackground,\n} from \"../../core/ChemBackground\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\nimport { findNodeEx } from \"../main/findNode\";\nimport { parsePadding } from \"../parse/parsePadding\";\n\nexport const funcBackground = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  if (compiler.background) {\n    // Возможно указать несколько фонов подряд.\n    // Тогда фоновая команда создается не дожидаясь объявления узла.\n    // Само собой, нужно корректно указывать узлы.\n    compiler.curAgent?.commands.push(new ChemBackground(compiler.background));\n  }\n  compiler.background = parseBackgroundArgs(compiler, args, pos);\n};\n\nconst shapeNames = new Set([\"rect\", \"round\", \"ellipse\"]);\n\nexport const parseBackgroundArgs = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n): ParamsChemBackground => {\n  const params: ParamsChemBackground = {};\n  args.forEach((arg, i) => {\n    const curPos = pos[i]!;\n    const argt = arg.trim();\n    if (argt === \"*\") {\n      params.isAll = true;\n    } else {\n      const divPos = arg.indexOf(\":\");\n      if (divPos < 0) {\n        if (shapeNames.has(argt)) {\n          params.shape = argt;\n        } else if (!params.fill) {\n          params.fill = arg;\n        }\n      } else {\n        const key = arg.slice(0, divPos);\n        const val = arg.slice(divPos + 1);\n        const valPos = curPos + divPos + 1;\n        switch (key) {\n          case \"\":\n          case \"to\":\n            params.nodes = parseNodes(compiler, val, valPos);\n            break;\n          case \"fill\":\n          case \"f\":\n            params.fill = val.trim();\n            break;\n          case \"stroke\":\n          case \"s\":\n            params.stroke = val.trim();\n            break;\n          case \"width\":\n          case \"w\":\n            params.strokeWidth = parseNum(compiler, val, valPos);\n            break;\n          case \"padding\":\n          case \"p\":\n            params.padding = parsePadding(compiler, val, valPos);\n            break;\n          case \"r\":\n            params.borderRadius = parseNum(compiler, val, valPos);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  });\n  return params;\n};\n\nconst parseNodes = (\n  compiler: ChemCompiler,\n  nodesList: string,\n  pos: Int\n): ChemNode[] => {\n  const chunks = nodesList.split(\";\");\n  let curPos = 0;\n  return chunks.map((nodeDef) => {\n    const node = findNodeEx(compiler, nodeDef, curPos + pos);\n    curPos += nodeDef.length + 1;\n    return node;\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\n\nexport const funcC = (compiler: ChemCompiler) => {\n  compiler.centralNode = true;\n};\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const funcColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varColor = value;\n};\n\nexport const funcItemColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varItemColor = value;\n};\n\nexport const funcItemColor1 = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varItemColor1 = value;\n};\n\nexport const funcAtomColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varAtomColor = value;\n};\n\nexport const funcAtomColor1 = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varAtomColor1 = value;\n};\n","import { BondAlign } from \"../../core/ChemBond\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst aligns = { r: 1, R: 1, l: 1, L: 1, m: 1, M: 1 };\n\nexport const funcDblAlign = (\n  compiler: ChemCompiler,\n  args: string[]\n  // @Suppress(\"UNUSED_PARAMETER\") pos: List<Int>\n) => {\n  compiler.varAlign =\n    args[0]! in aligns ? (args[0]![0]!.toLowerCase() as BondAlign) : undefined;\n};\n","import { LewisDot } from \"../../core/ChemNodeItem\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\n/*\n 1. Compatible for ver 0.0\n  UTDBLRutdblr for pairs of points top, bottom, left and right\n  ! = all 8 positions\n  (L) = :O, (Lb) = .O, (R) = O:, (LR) = :O:, (LbRb) = .O., (T) = (U) = Ö \n  LR = !UD\n 2. Compatible for 1.0\n  List of angles\n  (22,-22) = O:\n 3. Features of 2.0:\n  - using colors: $dots(c:red,UD) or $dots(c:blue,22,-22)\n  - using combination of different parameters: (c:green,T,c:red,180)\n*/\n\n// Цвета по приоритетности (при отрисовке): цвет точки, цвет атома, цвет элемента, дефолтный цвет\n\nconst rxCompact = /^!?([LR][dbtu]?|[UTDB][lr]?)+$/;\n\nexport const splitDotPositions = (descr: string): number[] => {\n  //    5  6  U=T\n  // L 4 ## 7  R\n  //   3 ## 0\n  //    2  1  B=D\n  const result: number[] = [];\n  const isRev = descr[0] === \"!\";\n  let i = isRev ? 1 : 0;\n  const check2 = (match: string, n: number) => {\n    if (match.indexOf(descr[i]!) >= 0) {\n      result.push(n);\n      i++;\n      return true;\n    }\n    return false;\n  };\n  const checkEx = (m1: string, n1: number, m2: string, n2: number): void => {\n    // eslint-disable-next-line no-unused-expressions\n    check2(m1, n1) || check2(m2, n2) || result.push(n1, n2);\n  };\n  while (i < descr.length) {\n    const c = descr[i++];\n    if (c === \"R\") {\n      checkEx(\"db\", 0, \"tu\", 7);\n    } else if (c === \"L\") {\n      checkEx(\"db\", 3, \"tu\", 4);\n    } else if (c === \"U\" || c === \"T\") {\n      checkEx(\"l\", 5, \"r\", 6);\n    } else if (c === \"B\" || c === \"D\") {\n      checkEx(\"r\", 1, \"l\", 2);\n    }\n  }\n  if (!isRev) {\n    return result;\n  }\n  const revSet = result.reduce((acc, n) => {\n    acc.delete(n);\n    return acc;\n  }, new Set([0, 1, 2, 3, 4, 5, 6, 7]));\n  return Array.from(revSet);\n};\n\ninterface ResDotArgDirs {\n  cmd: \"dirs\";\n  dirs: number[]; // directions from 0 to 7\n}\ninterface ResDotArgNum {\n  cmd: \"num\";\n  num: number;\n}\ninterface ResDotArgColor {\n  cmd: \"color\";\n  color?: string;\n}\ninterface ResDotArgMargin {\n  cmd: \"margin\";\n  margin?: number;\n}\ntype ResDotArg =\n  | ResDotArgDirs\n  | ResDotArgNum\n  | ResDotArgColor\n  | ResDotArgMargin;\n\nexport const parseSingleDotArg = (\n  compiler: ChemCompiler,\n  arg: string,\n  pos: Int\n): ResDotArg | undefined => {\n  if (!arg) return undefined;\n  if (arg.startsWith(\"c:\") || arg.startsWith(\"color:\")) {\n    const color = arg.slice(arg.indexOf(\":\") + 1);\n    return { cmd: \"color\", color: color || undefined };\n  }\n  if (arg.startsWith(\"m:\") || arg.startsWith(\"margin:\")) {\n    const val = arg.slice(arg.indexOf(\":\") + 1);\n    const margin = val ? parseNum(compiler, val, pos) : undefined;\n    return { cmd: \"margin\", margin };\n  }\n  if (arg === \"!\" || rxCompact.test(arg)) {\n    return { cmd: \"dirs\", dirs: splitDotPositions(arg) };\n  }\n  return { cmd: \"num\", num: parseNum(compiler, arg, pos) };\n};\n\nexport const parseDotsArgs = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n): LewisDot[] => {\n  const dots: LewisDot[] = [];\n  let color: string | undefined;\n  let margin: number | undefined;\n  const params = () => {\n    const res: { color?: string; margin?: number } = {};\n    if (color) res.color = color;\n    if (margin) res.margin = margin;\n    return res;\n  };\n  const addAngle = (angle: number) => {\n    dots.push({ ...params(), angle });\n  };\n  const addPos = (dotPos: number) => {\n    dots.push({ ...params(), pos: dotPos });\n  };\n  args.forEach((arg, i) => {\n    const r: ResDotArg | undefined = parseSingleDotArg(compiler, arg, pos[i]!);\n    switch (r?.cmd) {\n      case \"dirs\":\n        r.dirs.forEach((dir) => addPos(dir));\n        break;\n      case \"num\":\n        addAngle(r.num);\n        break;\n      case \"color\":\n        color = r.color;\n        break;\n      case \"margin\":\n        margin = r.margin;\n        break;\n      default:\n        break;\n    }\n  });\n  return dots;\n};\n\nexport const funcDots = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  const dots: LewisDot[] = parseDotsArgs(compiler, args, pos);\n  compiler.varDots = dots;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcL = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  compiler.varLength =\n    args.length === 0 ? 1.0 : parseNum(compiler, args[0]!, pos[0]!);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcM = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  if (args.length > 0) {\n    compiler.varMass = parseNum(compiler, args[0]!, pos[0]!);\n  }\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcPadding = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  compiler.varPadding = args.map((arg, i) => parseNum(compiler, arg, pos[i]!));\n};\n","import { CoeffPos, rxCoeffPos } from \"../../types/CoeffPos\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\n// В случае использования угла не действуют supKX и subKX\n\nexport const funcPos = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  const arg = args[0];\n  if (!arg) return;\n  if (rxCoeffPos.test(arg)) {\n    compiler.varPos = arg as CoeffPos;\n  } else {\n    compiler.varPos = parseNum(compiler, arg, pos[0]!);\n  }\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcSlope = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  compiler.varSlope =\n    args.length === 0 ? 0.0 : parseNum(compiler, args[0]!, pos[0]!);\n};\n","import { getVersion } from \"../../getVersion\";\nimport { Int } from \"../../types\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst toIntOrZero = (s: string = \"\"): Int => +s || 0;\n\n// Эта функция должна обеспечивть совместимость с предыдущими версиями\n// Возможно передать в одном параметре оба номера через точку 1.1\n// Но можно и через запятую. Тогда это два параметра\nexport const parseVerParameter = (args: string[]): [Int, Int] => {\n  const [a, b] = args;\n  const verStr: string =\n    ifDef(a, (v1) => ifDef(b, (v2) => `${v1}.${v2}`) ?? a) ?? b ?? \"0.0\";\n  const verList = verStr.split(\".\");\n  const verList2 = [\n    verList.length === 0 ? \"0\" : verList[0]!,\n    verList.length < 2 ? \"0\" : verList[1]!,\n  ];\n  return [toIntOrZero(verList2[0]), toIntOrZero(verList2[1])];\n};\n\nexport const funcVer = (compiler: ChemCompiler, args: string[]) => {\n  const [high, low] = parseVerParameter(args);\n  const currentVersion = getVersion();\n  if (\n    high > currentVersion[0]! ||\n    (high === currentVersion[0] && low > currentVersion[1]!)\n  ) {\n    compiler.error(\"Invalid version\", {\n      cur: `${currentVersion[0]}.${currentVersion[1]}`,\n      need: `${high}.${low}`,\n    });\n  }\n};\n","// Масса следующего элемента плюс атомный номер   238 #  #\n// Например $nM(238)U                                 #  #\n//                                                 92  ##\n// Или можно $nM(1,0){n}\n\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { funcM } from \"./funcM\";\n\nexport const funcnM = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  funcM(compiler, args, pos);\n  // \"\" означает, что надо использовать массу того атома, к которому применяется функция\n  // в отличие от undefined, который означает, что номер элемента вообще не выводится\n  compiler.varAtomNumber = args.length > 1 ? cvt(args[1]!) : \"\";\n};\n\nconst cvt = (s: string): number | undefined => {\n  if (!s) return undefined;\n  const n = +s;\n  return Number.isNaN(n) ? undefined : n;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { funcBackground } from \"./funcBackground\";\nimport { funcC } from \"./funcC\";\nimport {\n  funcAtomColor,\n  funcAtomColor1,\n  funcColor,\n  funcItemColor,\n  funcItemColor1,\n} from \"./funcColor\";\nimport { funcDblAlign } from \"./funcDblAlign\";\nimport { funcDots } from \"./funcDots\";\nimport { funcL } from \"./funcL\";\nimport { funcM } from \"./funcM\";\nimport { funcnM } from \"./funcnM\";\nimport { funcPadding } from \"./funcPadding\";\nimport { funcPos } from \"./funcPos\";\nimport { funcSlope } from \"./funcSlope\";\nimport { funcVer } from \"./funcVer\";\n\ntype ChemFunc = (compiler: ChemCompiler, args: string[], argPos: Int[]) => void;\n\nexport const funcsDict: Record<string, ChemFunc> = {\n  atomColor: funcAtomColor,\n  atomColor1: funcAtomColor1,\n  background: funcBackground,\n  bg: funcBackground, // short form of 'background'\n  C: funcC,\n  color: funcColor,\n  dblAlign: funcDblAlign,\n  dots: funcDots,\n  itemColor: funcItemColor,\n  itemColor1: funcItemColor1,\n  L: funcL,\n  M: funcM,\n  nM: funcnM,\n  padding: funcPadding,\n  pos: funcPos,\n  slope: funcSlope,\n  ver: funcVer,\n};\n","import { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemNode } from \"../../core/ChemNode\";\n\nexport class BracketsCtrl {\n  private queue: (ChemBracketBegin | ChemBracketEnd)[] = [];\n\n  clear() {\n    this.queue.length = 0;\n  }\n\n  onNode(node: ChemNode) {\n    this.queue.forEach((obj) => {\n      obj.nodes[1] = node;\n    });\n    this.clear();\n  }\n\n  onBracket(obj: ChemBracketBegin | ChemBracketEnd) {\n    this.queue.push(obj);\n  }\n}\n","import { Int } from \"../../types\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { ChemNode } from \"../../core/ChemNode\";\n\n/*\n Множители появляются:\n - после символа *;\n - сразу после открытия скобки (это новая фича для версии 1.2)\n Закрываются автоматически:\n - перед символом *\n - перед закрытием СООТВЕТСТВУЮЩЕЙ скобки\n - в конце агента\n */\n\nexport class MulCounter {\n  private mul?: ChemMul;\n\n  private bracketCounter: Int = 0;\n\n  onOpenBracket() {\n    if (this.mul) {\n      ++this.bracketCounter;\n    }\n  }\n\n  onNode(node: ChemNode) {\n    const { mul } = this;\n    if (mul && !mul.nodes[1]) {\n      mul.nodes[1] = node;\n    }\n  }\n\n  onCloseBracket() {\n    if (this.mul) {\n      --this.bracketCounter;\n    }\n  }\n\n  close() {\n    this.mul = undefined;\n  }\n\n  create(newMul: ChemMul) {\n    this.mul = newMul;\n  }\n\n  getMulForBracket(): ChemMul | undefined {\n    return this.bracketCounter > 0 ? undefined : this.mul;\n  }\n\n  getMulForced(): ChemMul | undefined {\n    return this.mul;\n  }\n}\n","import { ChemNode } from \"../../core/ChemNode\";\n\nexport class NodesBranch {\n  private readonly nbStack: Array<ChemNode[]> = []; // mutableListOf<MutableList<ChemNode>>()\n\n  nodes: ChemNode[] = [];\n\n  onBranchBegin() {\n    const copy = [...this.nodes];\n    this.nbStack.unshift(copy);\n  }\n\n  onBranchEnd() {\n    const svNodes = this.nbStack.shift();\n    if (svNodes) this.nodes = svNodes;\n  }\n\n  onSubChain() {\n    this.nodes.length = 0;\n  }\n\n  onNode(node: ChemNode) {\n    this.nodes.push(node);\n  }\n}\n","import { Int } from \"../../types\";\n\nexport abstract class StackItem {\n  constructor(public readonly pos: Int) {}\n\n  abstract msgInvalidClose(): string;\n}\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemSubObj } from \"../../core/ChemSubObj\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { getNodeForced } from \"./node\";\nimport { closeItem } from \"./item\";\nimport { getAtomColor, getItemColor } from \"./colors\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const addNodeItem = (\n  compiler: ChemCompiler,\n  subObj: ChemSubObj\n): ChemNodeItem => {\n  closeItem(compiler);\n  const item = new ChemNodeItem(subObj);\n  ifDef(compiler.varMass, (it) => {\n    item.mass = it;\n    compiler.varMass = undefined;\n  });\n  item.color = getItemColor(compiler);\n  item.atomColor = getAtomColor(compiler);\n  item.atomNum = compiler.varAtomNumber;\n  item.bCenter = compiler.getAltFlag();\n  item.dots = compiler.varDots;\n  compiler.varDots = undefined;\n  compiler.varAtomNumber = undefined;\n  getNodeForced(compiler, false).items.push(item);\n  return item;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { onCreateEntity, closeEntity } from \"./entity\";\nimport { addNodeItem } from \"./addNodeItem\";\nimport { closeNode, openNode, updateAutoNode } from \"./node\";\nimport { checkMul, startMul } from \"./multipier\";\nimport { checkBranch, closeBranch } from \"./branch\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { checkMiddlePoints } from \"./middlePoint\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { ChemBackground } from \"../../core/ChemBackground\";\n\nexport const createAgent = (compiler: ChemCompiler): ChemAgent => {\n  let { pos } = compiler;\n  const { preComm } = compiler;\n  closeEntity(compiler);\n  const agent = new ChemAgent();\n  agent.part = compiler.curPart;\n  compiler.curAgent = agent;\n  onCreateEntity(compiler, agent);\n  if (preComm) {\n    pos = compiler.eject(\"preCommPos\") ?? pos;\n    addNodeItem(compiler, preComm);\n  }\n  compiler.references = {};\n  compiler.varMass = undefined;\n  compiler.curWidth = 0;\n  compiler.centralNode = false;\n  compiler.varPadding = [];\n  compiler.varDots = undefined;\n  compiler.nodesBranch.onSubChain();\n  compiler.bracketsCtrl.clear();\n  if (compiler.srcMap) {\n    compiler.entityBegin = pos;\n  }\n  return agent;\n};\n\nexport const closeChain = (compiler: ChemCompiler) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    if (curBond.nodes.length === 2 && !curBond.nodes[1]) {\n      openNode(compiler, true);\n    }\n  }\n  compiler.curBond = undefined;\n  closeNode(compiler);\n  compiler.chainSys.closeChain();\n  compiler.nodesBranch.onSubChain();\n  compiler.bracketsCtrl.clear();\n};\n\nexport const onCloseAgent = (compiler: ChemCompiler) => {\n  const { curAgent } = compiler;\n  if (curAgent) {\n    checkMul(compiler);\n    checkMiddlePoints(compiler);\n    closeChain(compiler);\n    compiler.curAgent = undefined;\n    compiler.getAltFlag();\n    compiler.curBond = undefined;\n    checkBranch(compiler);\n    finalUpdateBondsForNodes(curAgent);\n    finalUpdateAutoNodes(curAgent);\n    if (compiler.background) {\n      curAgent.commands.push(new ChemBackground(compiler.background));\n    }\n    compiler.background = undefined;\n    curAgent.bonds.forEach((b, i) => {\n      b.index = i;\n    });\n    compiler.addSrcMapItem(curAgent, compiler.entityBegin);\n    compiler.agentMode = undefined;\n  }\n};\n\nexport const star = (compiler: ChemCompiler): Int => {\n  compiler.pos++;\n  if (compiler.curChar() === \")\") {\n    return closeBranch(compiler);\n  }\n  checkMul(compiler);\n  startMul(compiler, scanCoeff(compiler) ?? new ChemK(1), false);\n  return compiler.setState(stateAgentMid);\n};\n\nexport const finalUpdateBondsForNodes = (agent: ChemAgent) => {\n  // update bonds field for all nodes\n  agent.walk({\n    bond(obj) {\n      obj.nodes.forEach((it) => it?.addBond(obj));\n    },\n  });\n};\n\nexport const finalUpdateAutoNodes = (agent: ChemAgent) => {\n  agent.walk({\n    nodePre(obj) {\n      if (obj.autoMode) {\n        updateAutoNode(obj);\n      }\n    },\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { Int } from \"../../types\";\nimport { createSimpleBond, scanSimpleBond } from \"./bondSimple\";\nimport { closeChain, star } from \"./agent\";\nimport { createLabel } from \"./createLabel\";\nimport { closeBranch, openBranch } from \"./branch\";\nimport { addNodeItem } from \"./addNodeItem\";\nimport { instChemComma } from \"../../core/ChemComma\";\nimport { getNodeForced } from \"./node\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { stateElement } from \"../state/stateElement\";\nimport { stateCommentIn } from \"../state/stateCommentIn\";\nimport { stateCustom } from \"../state/stateCustom\";\nimport { stateAgentSpace } from \"../state/stateAgentSpace\";\nimport { stateNodeRef } from \"../state/stateNodeRef\";\nimport { stateCharge } from \"../state/stateCharge\";\nimport {\n  closeBracketShort,\n  openParentheses,\n  openSquareBracket,\n} from \"./brackets\";\nimport { stateUniBond } from \"../state/stateUniBond\";\nimport { stateFuncName } from \"../state/stateFuncName\";\n\nexport const agentAnalyse = (\n  compiler: ChemCompiler,\n  onDefault: () => Int\n): Int => {\n  compiler.agentMode = \"in\";\n  const c = compiler.curChar();\n  const pos0 = compiler.pos;\n  const bond = scanSimpleBond(compiler);\n  if (bond) {\n    createSimpleBond(compiler, bond, pos0);\n    return compiler.setState(stateAgentMid);\n  }\n  if (c >= \"A\" && c <= \"Z\") {\n    // Извлечь первый заглавный символ элемента. Следующие должны быть маленькими\n    compiler.elementStartPos = compiler.pos;\n    return compiler.setState(stateElement, 1);\n  }\n  switch (c) {\n    case \"`\":\n      compiler.setAltFlag();\n      return compiler.setState(stateAgentMid, 1);\n    case \"{\":\n      return compiler.setState(stateCustom, 1);\n    case '\"':\n      return compiler.setState(stateCommentIn, 1);\n    case \";\":\n      closeChain(compiler);\n      return compiler.setState(stateAgentSpace, 1);\n    case \":\":\n      return createLabel(compiler);\n    case \"#\":\n      return compiler.setState(stateNodeRef, 1);\n    case \"^\":\n      return compiler.setState(stateCharge, 1);\n    case \"$\":\n      return compiler.setState(stateFuncName, 1);\n    case \"<\":\n      return openBranch(compiler);\n    case \">\":\n      return closeBranch(compiler);\n    case \"(\":\n      return openParentheses(compiler);\n    case \"[\":\n      return openSquareBracket(compiler);\n    case \")\":\n    case \"]\":\n    case \"}\":\n      return closeBracketShort(compiler);\n    case \"*\":\n      return star(compiler);\n    case \",\":\n      return comma(compiler);\n    case \"_\":\n      return compiler.setState(stateUniBond, 1);\n    case \"c\":\n      getNodeForced(compiler, true);\n      return compiler.setState(stateAgentMid, 1);\n\n    default:\n      return onDefault();\n  }\n};\n\nconst comma = (compiler: ChemCompiler): Int => {\n  addNodeItem(compiler, instChemComma);\n  return compiler.setState(stateAgentMid, 1);\n};\n","import { Double, Int } from \"../../types\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { makeBondStep } from \"./bondSimple\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { getLastBond } from \"./bondUniversal\";\nimport { is0 } from \"../../math\";\n\n// -1, `-1, 0, 0, 1, `1\nconst horizAngles: Double[] = [-60.0, 120.0, 0.0, 0.0, 60.0, -120.0];\n\nconst newAngleDeg = (bond: ChemBond): Double =>\n  horizAngles[(bond.slope + 1) * 2 + (bond.isNeg ? 1 : 0)]!;\n\nconst correct = (bond: ChemBond, length?: Double) => {\n  bond.dir = makeBondStep(newAngleDeg(bond), length ?? bond.dir!.length());\n  bond.isCorr = true;\n  ifDef(bond.nodes[1], (it) => {\n    it.pt = bond.calcPt();\n  });\n};\n\nconst correctPrev = (\n  compiler: ChemCompiler,\n  prevBond: ChemBond,\n  length?: Double\n) => {\n  if (prevBond.nodes[1]?.fixed) {\n    return;\n  }\n  const corrNode = prevBond.nodes[1];\n  if (!corrNode) {\n    correct(prevBond, length);\n    return;\n  }\n  const { subChain } = corrNode;\n  const oldPos = corrNode.pt;\n  correct(prevBond, length);\n  const step = corrNode.pt.minus(oldPos);\n  const allNodes = compiler.curAgent!.nodes;\n  const dstNodes = allNodes\n    .slice(corrNode.index + 1)\n    .filter((it) => it.subChain === subChain);\n  dstNodes.reverse();\n  dstNodes.forEach((it) => {\n    it.pt.iadd(step);\n  });\n};\n\nexport const autoCorrection = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  slopeSign: Int\n) => {\n  if (compiler.varSlope !== 0.0) {\n    // Если указан угол наклона при помощи $slope(x)\n    return;\n  }\n  const prevBond = getLastBond(compiler);\n  // Если нет предыдущей связи, то коррекция невозможна\n  if (!prevBond) return;\n  if (!prevBond.isAuto) {\n    // Коррекция возможно только если предыдущая связь создана из простого описания\n    return;\n  }\n\n  const { dir } = prevBond;\n  if (prevBond.isAuto && dir && is0(dir.y) && slopeSign !== 0) {\n    // Стыковка горизонтальной связи с наклонной\n    correct(bond, compiler.varLength);\n    return;\n  }\n  if (\n    prevBond.slope !== 0 &&\n    prevBond.isCorr &&\n    slopeSign !== 0 &&\n    prevBond.isNeg !== bond.isNeg\n  ) {\n    // Стыковка предыдущей откорректированной наклонной связи\n    // с тем же наклоном, но в обратном направлении\n    correct(bond, compiler.varLength);\n    return;\n  }\n  // Варианты с коррекцией предыдущей связи\n  if (\n    prevBond.slope !== 0 &&\n    !prevBond.isCorr &&\n    slopeSign !== 0 &&\n    prevBond.isNeg !== bond.isNeg &&\n    prevBond.slope !== bond.slope\n  ) {\n    correctPrev(compiler, prevBond);\n    correct(bond, compiler.varLength);\n    return;\n  }\n  // Стыковка с горизонтальной связью\n  if (prevBond.slope !== 0 && !prevBond.isCorr && bond.isHorizontal()) {\n    correctPrev(compiler, prevBond);\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { closeNode, openNode } from \"./node\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { removeItem } from \"../../utils/removeItem\";\nimport { applyMiddlePoints } from \"./middlePoint\";\n\nexport const createCommonBond = (compiler: ChemCompiler): ChemBond => {\n  const bond = new ChemBond();\n  bond.color = compiler.varColor;\n  return bond;\n};\n\nexport const changeBondToHard = (compiler: ChemCompiler, bond: ChemBond) => {\n  bond.soft = false;\n  compiler.chainSys.changeBondToHard(bond);\n};\n\nexport const bindNodeToBond = (\n  compiler: ChemCompiler,\n  node: ChemNode,\n  chemBond: ChemBond\n) => {\n  compiler.curNode = node;\n\n  chemBond.nodes[1] = node;\n  const node0 = chemBond.nodes[0];\n  const auto0: boolean = node0?.autoMode ?? false;\n  // Если хотя бы один узел автоматический, то связь не мягкая\n  if (chemBond.soft && (auto0 || node.autoMode)) {\n    changeBondToHard(compiler, chemBond);\n  }\n  if (chemBond.soft) {\n    compiler.nodesBranch.onSubChain();\n    compiler.nodesBranch.onNode(node);\n  }\n  compiler.curBond = undefined;\n  // Для жесткой связи можно вычислить координаты второго узла относительно первого\n  const { dir } = chemBond;\n  if (dir && node0 && !chemBond.soft && !dir.isZero()) {\n    node.pt = node0.pt.plus(dir);\n  }\n};\n\nexport const bindNodeToCurrentBond = (\n  compiler: ChemCompiler,\n  node?: ChemNode\n) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    bindNodeToBond(compiler, node ?? openNode(compiler, true), curBond);\n  }\n};\n\nexport const findBondBetweenNodes = (\n  compiler: ChemCompiler,\n  nodeA: ChemNode,\n  nodeB: ChemNode\n): ChemBond | undefined =>\n  compiler.curAgent!.bonds.find((it) => {\n    const { nodes } = it;\n    return (\n      !it.middlePoints &&\n      nodes.length === 2 &&\n      ((nodes[0] === nodeA && nodes[1] === nodeB) ||\n        (nodes[0] === nodeB && nodes[1] === nodeA))\n    );\n  });\n\nexport const getNodeForBondStart = (\n  compiler: ChemCompiler,\n  bond?: ChemBond\n): ChemNode => {\n  const { curNode } = compiler;\n  if (curNode) {\n    // Если текущий узел есть, то использовать его\n    return curNode;\n  }\n  // Возможна ситуация, когда связь стыкуется к ранее закрытой скобке\n  const lastCmd = lastItem(compiler.curAgent!.commands);\n  const bracketEnd: ChemBracketEnd | undefined =\n    lastCmd instanceof ChemBracketEnd ? lastCmd : undefined;\n  if (bracketEnd) {\n    const { nodeIn } = bracketEnd;\n    if (nodeIn) {\n      bracketEnd.bond = bond;\n      return nodeIn;\n    }\n  }\n  return openNode(compiler, true);\n};\n\n// Предполагается, что свойства bond уже заполнены. В первую очередь: dir, n, soft\nexport const onOpenBond = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  begin: number\n) => {\n  if (compiler.srcMap) {\n    compiler.srcMap.push({ begin, end: compiler.pos, obj: bond });\n  }\n  const oldNode = getNodeForBondStart(compiler, bond);\n  closeNode(compiler);\n  applyMiddlePoints(compiler, bond);\n  if (bond.n === 2.0 && !bond.align) {\n    bond.align = compiler.varAlign;\n  }\n  bond.nodes[0] = oldNode;\n  if (bond.isAuto && oldNode.autoMode) {\n    // Если первый узел простой связи является автоматическим, то связь не мягкая\n    bond.soft = false;\n  }\n  bond.color = compiler.varColor;\n  /*\n    Здесь нельзя делать предположений о том, какой будет узел на другом конце.\n    Хотя вектор уже известен, но далее может появиться ссылка и связь может стать переходной.\n     */\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = bond;\n  compiler.chainSys.addBond(bond);\n};\n\nexport const mergeBonds = (\n  compiler: ChemCompiler,\n  oldBond: ChemBond,\n  newBond: ChemBond,\n  newNode: ChemNode\n) => {\n  // При наложении связей от новой только добавляется кратность.\n  // Остальные характеристики значения не имеют\n  oldBond.n += newBond.n;\n  compiler.curNode = newNode;\n  compiler.curBond = oldBond;\n  // узел фиксируется, чтобы его не сместило при автокоррекции\n  newNode.fixed = true;\n  newBond.isAuto = false;\n  newBond.soft = false;\n  newBond.nodes[1] = newNode;\n\n  // Конечные координаты отрезка должны совпадать со старой связью.\n  // Но направление может поменяться т.к. это имеет значение для отрисовки следующих связей\n  const [nbn0, nbn1] = newBond.nodes;\n  if (nbn0 && nbn1) {\n    newBond.dir = nbn1.pt.minus(nbn0.pt);\n  }\n\n  compiler.chainSys.addBond(newBond);\n  removeItem(compiler.curAgent!.bonds, newBond);\n  removeItem(compiler.curAgent!.commands, newBond);\n};\n","import { Char, Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { isDigit } from \"../parse/isDigit\";\nimport { createCommonBond, onOpenBond } from \"./bondCommon\";\nimport { createPolygonStep } from \"./bondUniversal\";\nimport { scanBondSuffix } from \"../parse/scanBondSuffix\";\n\nexport const createPolygonalBond = (compiler: ChemCompiler) => {\n  const beginPos = compiler.pos - 1;\n  const mode: Char = compiler.curChar();\n  let multiplicity = 1;\n  let sign: Int = 0;\n  if (mode === \"p\") sign = 1;\n  else if (mode === \"q\") sign = -1;\n  if (!sign) {\n    // Эта ошибка не может возникнуть из-за ошибки пользователя. Только если ошибка в компиляторе.\n    compiler.error(\"Invalid polygonal bond descriptor [c]\", { c: mode });\n  }\n  compiler.pos++;\n  // Далее возможен повторный символ, который означает двойную связь\n  if (compiler.curChar() === mode) {\n    multiplicity++;\n    compiler.pos++;\n  }\n  // Далее возможно указание количество углов полигона (Если не указано, то 5)\n  let strCount = \"\";\n  while (isDigit(compiler.curChar())) {\n    strCount += compiler.curChar();\n    compiler.pos++;\n  }\n  const count: Int = +strCount || 0;\n\n  const bond = createCommonBond(compiler);\n  bond.n = multiplicity as Double;\n  bond.dir = createPolygonStep(\n    compiler,\n    sign * (count || 5),\n    compiler.varLength\n  );\n\n  scanBondSuffix(compiler, bond);\n  bond.tx = compiler.subStr(beginPos);\n\n  onOpenBond(compiler, bond, beginPos);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { getNodeForced } from \"./node\";\nimport { createCommonBond } from \"./bondCommon\";\n\nexport const findRingNodes = (\n  compiler: ChemCompiler\n): (ChemNode | undefined)[] | undefined => {\n  const curNode = getNodeForced(compiler, true);\n  const nodesFull = compiler.nodesBranch.nodes;\n  const nodes = nodesFull.slice(0, nodesFull.length - 1);\n  const j = nodes.lastIndexOf(curNode);\n  return j < 0 ? undefined : nodes.slice(j);\n};\n\nexport const findRingNodesEx = (\n  compiler: ChemCompiler\n): (ChemNode | undefined)[] =>\n  findRingNodes(compiler) ??\n  compiler.error(\"Cant close ring\", { pos: compiler.pos - 2 });\n\nexport const createRingBond = (compiler: ChemCompiler, deltaPos: Int) => {\n  compiler.pos += deltaPos;\n  const bond = createCommonBond(compiler);\n  bond.nodes = findRingNodesEx(compiler);\n  bond.n = 1.0;\n  bond.tx = \"o\";\n  bond.ext = \"o\";\n  bond.isCycle = true;\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = undefined;\n};\n","import { Double, Int } from \"../../types\";\nimport { pointFromDeg, Point } from \"../../math/Point\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { createCommonBond, onOpenBond } from \"./bondCommon\";\nimport { scanBondSuffix } from \"../parse/scanBondSuffix\";\nimport { autoCorrection } from \"./autoCorrection\";\n\n/**\n * Вектор связи.\n * @param angleDegree Точное значениеугла в градусах. Не допускается 0\n * @param length Длина из compiler.varLength. Значение 0 воспринимается как 1\n */\nexport const makeBondStep = (angleDegree: Double, length: Double) =>\n  pointFromDeg(angleDegree).times(length === 0.0 ? 1.0 : length);\n\n// 0=(кратность), 1=(угол в градусах), 2=(знак наклона), 3=(признак мягкой связи), 4=(текст)\nclass BondDef {\n  constructor(\n    public readonly n: Int,\n    public readonly angle: Int,\n    public readonly slope: Int,\n    public readonly soft: boolean = false,\n    public readonly text?: string\n  ) {}\n\n  create(compiler: ChemCompiler, bondId: string): ChemBond {\n    const bond = createCommonBond(compiler);\n    bond.tx = this.text ?? bondId;\n    bond.n = this.n as Double;\n    bond.soft = this.soft;\n    bond.dir = this.calcDir(compiler, bond);\n    bond.slope = this.slope;\n    bond.isAuto = true;\n    bond.isText = this.angle === 0 && this.slope === 0;\n    autoCorrection(compiler, bond, this.slope);\n    return bond;\n  }\n\n  calcDir(compiler: ChemCompiler, bond: ChemBond): Point {\n    let angleDegree: Double;\n    if (this.slope === 0) {\n      angleDegree = this.angle as Double;\n    } else {\n      bond.slope = this.slope;\n      const srcAngle = compiler.varSlope === 0.0 ? 30.0 : compiler.varSlope;\n      angleDegree = srcAngle * this.slope;\n    }\n    if (compiler.getAltFlag()) {\n      angleDegree += 180.0;\n      bond.isNeg = true;\n    }\n    return makeBondStep(angleDegree, compiler.varLength);\n  }\n}\n\nconst soft1 = new BondDef(1, 0, 0, true, \"-\");\nconst soft3 = new BondDef(3, 0, 0, true, \"≡\");\n\nconst bondDefDict: Record<string, BondDef> = {\n  \"-\": soft1,\n  \"–\": soft1, // special character u2013\n  \"−\": soft1, // u2212\n  \"=\": new BondDef(2, 0, 0, true),\n  \"%\": soft3,\n  \"≡\": soft3,\n  \"--\": new BondDef(1, 0, 0, false, \"-\"),\n  \"==\": new BondDef(2, 0, 0, false, \"=\"),\n  \"%%\": new BondDef(3, 0, 0, false, \"≡\"),\n  \"|\": new BondDef(1, 90, 0),\n  \"||\": new BondDef(2, 90, 0),\n  \"|||\": new BondDef(3, 90, 0),\n  \"/\": new BondDef(1, 0, -1),\n  \"//\": new BondDef(2, 0, -1),\n  \"///\": new BondDef(3, 0, -1),\n  \"\\\\\": new BondDef(1, 0, 1),\n  \"\\\\\\\\\": new BondDef(2, 0, 1),\n  \"\\\\\\\\\\\\\": new BondDef(3, 0, 1),\n};\n\nexport const scanSimpleBond = (\n  compiler: ChemCompiler\n): ChemBond | undefined => {\n  let bondId = \"\";\n  let bondDef: BondDef | null = null;\n  for (;;) {\n    const curBondId = bondId + compiler.curChar();\n    // Постепенно увеличиваем длину описания\n    // Как только получается несуществующее описание, то закончить цикл\n    const curBondDef = bondDefDict[curBondId];\n    if (!curBondDef) return bondDef?.create(compiler, bondId);\n    bondId = curBondId;\n    bondDef = curBondDef;\n    compiler.pos++;\n  }\n};\n\nexport const createSimpleBond = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  begin: number\n) => {\n  scanBondSuffix(compiler, bond);\n  onOpenBond(compiler, bond, begin);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { findNodeEx } from \"./findNode\";\nimport { findRingNodes } from \"./bondRing\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { getNodeForced } from \"./node\";\nimport { ArgsInfo, scanArgs } from \"../parse/scanArgs\";\nimport { makeParamsDict, setBondProperties } from \"./bondUniversal\";\nimport { createCommonBond } from \"./bondCommon\";\n\nconst nodesInterval = (\n  compiler: ChemCompiler,\n  refs: string[],\n  pos: Int\n): ChemNode[] => {\n  const nodeA = findNodeEx(compiler, refs[0]!, pos);\n  const nodeB = findNodeEx(compiler, refs[1]!, pos + refs[0]!.length + 1);\n  const first = Math.min(nodeA.index, nodeB.index);\n  const last = Math.max(nodeA.index, nodeB.index);\n  return compiler.curAgent!.nodes.slice(first, last + 1);\n};\n\n/**\n * Список вершин, которые будут включены в сплайновую связь\n * Разделитель - точка с запятой\n * Можно указать интервал через двоеточие\n * Пример: #1:4;6\n */\nexport const parseNodesListDef = (\n  compiler: ChemCompiler,\n  value: string,\n  valuePos: Int\n): (ChemNode | undefined)[] | undefined => {\n  if (!value) {\n    return undefined;\n  }\n  const chunks = value.split(\";\");\n  let curPos = valuePos;\n  const nodes: ChemNode[] = chunks.reduce(\n    (srcList: ChemNode[], chunk: string) => {\n      const refs = chunk.split(\":\");\n      const dstList: ChemNode[] =\n        refs.length === 1\n          ? [...srcList, findNodeEx(compiler, chunk, curPos)]\n          : [...srcList, ...nodesInterval(compiler, refs, curPos)];\n\n      curPos += chunk.length + 1;\n      return dstList;\n    },\n    []\n  );\n  return nodes;\n};\n\ninterface NodesList {\n  nodes: (ChemNode | undefined)[];\n  isCycle: boolean;\n}\n\nconst autoLocateNodes = (compiler: ChemCompiler): NodesList =>\n  ifDef(findRingNodes(compiler), (nodes) => ({ nodes, isCycle: true })) ?? {\n    nodes: [...compiler.nodesBranch.nodes],\n    isCycle: false,\n  };\n\nconst checkCycledList = (nodes: (ChemNode | undefined)[]): NodesList =>\n  nodes.length > 1 && nodes[0] === lastItem(nodes)\n    ? { nodes: nodes.slice(0, nodes.length - 1), isCycle: true }\n    : { nodes, isCycle: false };\n\nexport const createSplineBond = (compiler: ChemCompiler) => {\n  // compiler.curChar == 's'\n  compiler.pos++;\n  getNodeForced(compiler, true);\n  let args: ArgsInfo;\n  if (compiler.curChar() !== \"(\") {\n    args = { args: [], argPos: [] };\n  } else {\n    compiler.pos++;\n    args = scanArgs(compiler);\n  }\n  const params = makeParamsDict(args.args, args.argPos);\n  const bond = createCommonBond(compiler);\n  bond.isCycle = false;\n  bond.tx = \"s\";\n  setBondProperties(compiler, bond, params);\n  const nodes: (ChemNode | undefined)[] | undefined = ifDef(\n    params[\"#\"],\n    (param) => parseNodesListDef(compiler, param.value, param.valuePos)\n  );\n  const nodesList: NodesList = nodes\n    ? checkCycledList(nodes)\n    : autoLocateNodes(compiler);\n  bond.nodes = nodesList.nodes;\n  bond.isCycle = \"o\" in params || nodesList.isCycle;\n  bond.ext = \"s\";\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = undefined;\n};\n","import { BondAlign, ChemBond } from \"../../core/ChemBond\";\nimport { Int, Char, Double } from \"../../types\";\nimport { Point, pointFromDeg, pointFromRad } from \"../../math/Point\";\nimport { rad2deg } from \"../../math/radians\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { listToDict } from \"../../utils/listToDict\";\nimport { findNodeEx } from \"./findNode\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { parseNum } from \"../parse/parseNum\";\nimport {\n  createCommonBond,\n  getNodeForBondStart,\n  onOpenBond,\n} from \"./bondCommon\";\n/*\nГеометрические параметры: A, a, L, P, p, x, y\nНесовместимы между собой: p, P, a, A. (В порядке убывания приоритета) Зато их можно комбинировать их с x, y\nL обычно использования совместно с A или a. Может быть использовано с P, хотя в этом мало пользы.\n */\n\nexport interface UniBondParam {\n  key: Char;\n  value: string;\n  valuePos: Int;\n}\n\ntype BondParams = Record<Char, UniBondParam | undefined>;\n\nexport const makeParamsDict = (args: string[], argPos: Int[]): BondParams => {\n  const paramsList = args\n    .map((descr, index) =>\n      !descr\n        ? null\n        : {\n            key: descr[0],\n            value: descr.substring(1),\n            valuePos: argPos[index]! + 1,\n          }\n    )\n    .filter((it) => it) as UniBondParam[];\n  return listToDict(paramsList, ({ key }) => key);\n};\n\nexport const calcPolygonDir = (prevDir: Point, count: Int): Point =>\n  pointFromRad(prevDir.polarAngle() + (Math.PI * 2) / count).times(\n    prevDir.length()\n  );\n\n/**\n * @param count Can be negative for counter-clock wise\n */\nexport const createPolygonStep = (\n  compiler: ChemCompiler,\n  count: Int,\n  defaultLength: Double\n): Point => {\n  const prevDir = getLastBond(compiler)?.dir;\n  return (\n    ifDef(prevDir, (it) => calcPolygonDir(it, count)) ??\n    new Point(defaultLength, 0.0)\n  );\n};\n\nexport const parseRefsList = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Point => {\n  if (!value) {\n    compiler.error(\"Invalid node reference '[ref]'\", { ref: \"\", pos });\n  }\n  let paramPos = pos;\n  const points = value.split(\";\").map((ref) => {\n    const node = findNodeEx(compiler, ref, paramPos);\n    paramPos += ref.length + 1;\n    return node.pt;\n  });\n  const vectorSum = points.reduce((sum, vec) => sum.iadd(vec), new Point());\n  const midPt = vectorSum.times(1.0 / (points.length as Double));\n  // Здесь используется допущение, что перед любой универсальной связью проверяется наличие узла\n  const curNode =\n    compiler.curNode ?? compiler.error(\"Expected node before bond\", { pos });\n  return midPt.minus(curNode.pt);\n};\n\nexport const parseAxisCoordinate = (\n  compiler: ChemCompiler,\n  isX: boolean,\n  value: string,\n  pos: Int\n): Double => {\n  if (!value.startsWith(\"#\")) return parseNum(compiler, value, pos);\n\n  const center = parseRefsList(compiler, value.slice(1), pos + 1);\n  return isX ? center.x : center.y;\n};\n\nexport const getLastBond = (compiler: ChemCompiler): ChemBond | undefined =>\n  // compiler.curBond\n  compiler.chainSys.getLastBond();\n\nexport const calcBondDirection = (\n  compiler: ChemCompiler,\n  params: BondParams\n): Point => {\n  const getLength = (): Double => {\n    const it = params.L;\n    return it ? parseNum(compiler, it.value, it.valuePos) : compiler.varLength;\n  };\n\n  const fromAngle = (a: Double): Point => pointFromDeg(a).times(getLength());\n\n  const getPrevBond = (): ChemBond | undefined => getLastBond(compiler);\n\n  const dir: Point =\n    ifDef(params.p, (it) => parseRefsList(compiler, it.value, it.valuePos)) ??\n    ifDef(params.P, (it) => {\n      // Polygonal bond\n      const n: Int =\n        it.value === \"\" ? 5 : parseNum(compiler, it.value, it.valuePos);\n      return createPolygonStep(compiler, n || 5, getLength());\n    }) ??\n    ifDef(params.a, (aParam) => {\n      const a =\n        ifDef(getPrevBond()?.dir, (it) => rad2deg(it.polarAngle())) ?? 0.0;\n      return fromAngle(a + parseNum(compiler, aParam.value, aParam.valuePos));\n    }) ??\n    ifDef(params.A, (it) =>\n      fromAngle(parseNum(compiler, it.value, it.valuePos))\n    ) ??\n    ifDef(params.L, () => fromAngle(0)) ??\n    new Point(0, 0);\n\n  ifDef(params.x, (it) => {\n    dir.x += parseAxisCoordinate(compiler, true, it.value, it.valuePos);\n  });\n  ifDef(params.y, (it) => {\n    dir.y += parseAxisCoordinate(compiler, false, it.value, it.valuePos);\n  });\n  return dir;\n};\n\nconst doubleBondSuffizes = { x: 1, l: 1, r: 1, m: 1 };\n\nexport const parseBondMultiplicity = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  param: UniBondParam\n) => {\n  const { value } = param;\n  const getMode = (): Char => value[1]!.toLowerCase();\n  if (\n    value.length === 2 &&\n    value[0] === \"2\" &&\n    getMode() in doubleBondSuffizes\n  ) {\n    if (getMode() === \"x\") {\n      bond.setCross();\n    } else {\n      bond.align = getMode() as BondAlign;\n    }\n    bond.n = 2.0;\n  } else if (!value) {\n    bond.n = 1.0;\n  } else {\n    bond.n = parseNum(compiler, value, param.valuePos);\n  }\n};\n\nconst styleSuffixes = { m: 1, l: 1, r: 1 };\n\nexport const parseStyle = (bond: ChemBond, value: string) => {\n  if (value && value[value.length - 1]!.toLowerCase() in styleSuffixes) {\n    bond.align = value[value.length - 1]!.toLowerCase() as BondAlign;\n    bond.style = value.slice(0, value.length - 1);\n  } else {\n    bond.style = value;\n  }\n};\n\nexport const setBondProperties = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  params: BondParams\n) => {\n  ifDef(params.N, (it) => parseBondMultiplicity(compiler, bond, it));\n  ifDef(params.h, (it) => {\n    bond.soft = true; // <- this feature of ver 0.0\n    // h+, h- : feature of ver 2.0\n    const connection = (sign: -1 | 1) => {\n      bond.n = 0;\n      if (bond.dir && bond.dir.x === 0) {\n        bond.dir.x = sign * 0.02;\n      }\n    };\n    if (it.value === \"+\") {\n      connection(1);\n    } else if (it.value === \"-\") {\n      connection(-1);\n    }\n  });\n  ifDef(params.T, (it) => {\n    bond.tx = it.value;\n  });\n  if (bond.n === 1.0 && \"H\" in params) bond.setHydrogen();\n  ifDef(params.C, (it) => {\n    // Сoordination chemical bond\n    switch (it.value) {\n      case \"-\":\n        bond.arr0 = true; // _(C-)   A<---B\n        break;\n      case \"+\": // _(C+)   A<-->B\n        bond.arr0 = true;\n        bond.arr1 = true;\n        break;\n      default: // _(C)   A--->B\n        bond.arr1 = true;\n        break;\n    }\n  });\n  if (params[\"<\"]) {\n    bond.arr0 = true;\n  }\n  if (params[\">\"]) {\n    bond.arr1 = true;\n  }\n  if (params[\"~\"]) {\n    bond.style = \"~\";\n  }\n  ifDef(params.S, (it) => parseStyle(bond, it.value));\n\n  const setWidth = (id: string, sign: Int, isGlobal: boolean) => {\n    const makePair = (): [Int | null, Int | null] => {\n      switch (id) {\n        case \"+\":\n          return [0, sign];\n        case \"-\":\n          return [sign, 0];\n        case \"0\":\n        case \"1\":\n          return [0, 0];\n        case \"2\":\n          return [sign, sign];\n        default:\n          return [null, null];\n      }\n    };\n    const [first, second] = makePair();\n    bond.w0 = first ?? compiler.curWidth;\n    bond.w1 = second ?? compiler.curWidth;\n    if (isGlobal) {\n      compiler.curWidth = second ?? compiler.curWidth;\n    }\n    return true;\n  };\n  const [id, sign, isGlobal] = ifDef(params.w, (it) => [it.value, 1, false]) ??\n    ifDef(params.d, (it) => [it.value, -1, false]) ??\n    ifDef(params.W, (it) => [it.value, 1, true]) ??\n    ifDef(params.D, (it) => [it.value, -1, true]) ?? [\"\", 0, false];\n  setWidth(id, sign, isGlobal);\n};\n\nexport const createUniversalBond = (\n  compiler: ChemCompiler,\n  args: string[],\n  argPos: Int[],\n  begin: number\n) => {\n  const bond = createCommonBond(compiler);\n  if (!compiler.curNode) {\n    compiler.curNode = getNodeForBondStart(compiler, bond);\n  }\n  const params = makeParamsDict(args, argPos);\n  bond.dir = calcBondDirection(compiler, params);\n  setBondProperties(compiler, bond, params);\n  onOpenBond(compiler, bond, begin);\n};\n","/*\n\nСкобки вкладываются совместно с ветками. То есть, если открыта ветка, а в ней скобка,\nто сначала закрывается скобка, а потом ветка.\n\nУ скобок могут быть входящая и исходящая связь, но не обязательно.\n(NH4)2SO4 - нет связей\n\nH-(CH2)4-H - Есть обе связи. Причем они мягкие. Поэтому рисуются не к узлу, а к скобке.\n\nH^+_(x1.4,N0)[Cu^+<`|hBr^-><|hBr^->]^-\n     +  Br +\n     |  |  |\n  H--|--Cu |\n     |  |  |\n     +  Br +\nЗдесь есть только входящая связь, соединяющая узел снаружи и внутри скобки\n\nКроме того, если после скобок объявить ветки, то можно сделать несколько исходящих связей.\n */\nimport { Int } from \"../../types\";\nimport { StackItem } from \"./StackItem\";\nimport { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { openBranch } from \"./branch\";\nimport { closeNode, openNode } from \"./node\";\nimport { ChemMulEnd } from \"../../core/ChemMul\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { checkMulBeforeBracket } from \"./multipier\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { stateBracketBegin } from \"../state/stateBracketBegin\";\n\nclass BracketDecl extends StackItem {\n  constructor(pos: Int, public readonly begin: ChemBracketBegin) {\n    super(pos);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override msgInvalidClose(): string {\n    return \"It is necessary to close the bracket\";\n  }\n}\n\nexport const openParentheses = (compiler: ChemCompiler): Int => {\n  // Здесь возможны следующие случаи\n  // - (* - открыть ветку\n  // - скобка для конструкций типа Ca(OH)2\n\n  // * степень окисления текущего элемента узла тоже в круглых скобках,\n  // но допустимо только после описания элемента. Поэтому см statePostItem\n  compiler.pos++;\n  if (compiler.curChar() === \"*\") {\n    return openBranch(compiler);\n  }\n  openBracket(compiler, \"(\", compiler.pos - 1);\n  return compiler.setState(stateBracketBegin);\n};\n\nexport const openSquareBracket = (compiler: ChemCompiler): Int => {\n  openBracket(compiler, \"[\", compiler.pos++);\n  return compiler.setState(stateBracketBegin);\n};\n\nexport const openBrace = (compiler: ChemCompiler): Int => {\n  openBracket(compiler, \"{\", compiler.pos - 1);\n  compiler.pos++;\n  return compiler.setState(stateBracketBegin);\n};\n\nconst openBracket = (compiler: ChemCompiler, text: string, pos: Int) => {\n  const begin = new ChemBracketBegin(text);\n  begin.color = compiler.varColor;\n  compiler.mulCounter.onOpenBracket();\n  compiler.curAgent!.commands.push(begin);\n  compiler.push(new BracketDecl(pos, begin));\n  compiler.bracketsCtrl.onBracket(begin);\n  if (compiler.varPadding.length) {\n    begin.padding = compiler.varPadding;\n    compiler.varPadding = [];\n  }\n  if (compiler.curBond) {\n    begin.bond = compiler.curBond;\n    // eslint-disable-next-line prefer-destructuring\n    begin.nodes[0] = begin.bond.nodes[0];\n  } else {\n    begin.nodes[0] = compiler.curNode;\n    closeNode(compiler);\n    compiler.chainSys.createSubChain();\n  }\n};\n\nconst bracketPairs: Record<string, string> = { \"(\": \")\", \"[\": \"]\", \"{\": \"}\" };\n\nexport const getNodeForBracketEnd = (compiler: ChemCompiler): ChemNode => {\n  const { curNode } = compiler;\n  if (curNode) {\n    return curNode;\n  }\n  const { commands } = compiler.curAgent!;\n  let lastCmd = lastItem(commands);\n  if (lastCmd instanceof ChemMulEnd) {\n    lastCmd = commands[commands.length - 2];\n  }\n  if (lastCmd instanceof ChemBracketEnd) {\n    const { nodeIn } = lastCmd;\n    if (nodeIn) return nodeIn;\n  }\n  return openNode(compiler, true);\n};\n\nexport const closeBracket = (\n  compiler: ChemCompiler,\n  text: string,\n  pos: Int\n): ChemBracketEnd =>\n  ifDef(compiler.pop(), (decl) => {\n    if (decl instanceof BracketDecl) {\n      const needCloseText: string =\n        bracketPairs[decl.begin.text] ??\n        // Такая ошибка не должна возникнуть, если правильно заполнен словарь bracketPairs\n        compiler.error(\"Invalid bracket pair [s]\", {\n          s: decl.begin.text + text,\n        });\n      if (needCloseText !== text) {\n        // Тип открытой скобки должен соответствовать типу закрытой\n        compiler.error(\"Expected [must] instead of [have]\", {\n          must: needCloseText,\n          have: text,\n          pos,\n          pos0: decl.pos,\n        });\n      }\n\n      checkMulBeforeBracket(compiler);\n      compiler.mulCounter.onCloseBracket();\n      const bracketEnd = new ChemBracketEnd(\n        text,\n        decl.begin,\n        getNodeForBracketEnd(compiler)\n      );\n      const { commands } = compiler.curAgent!;\n      commands.push(bracketEnd);\n      decl.begin.end = bracketEnd;\n      closeNode(compiler);\n      compiler.chargeOwner = bracketEnd;\n      compiler.bracketsCtrl.onBracket(bracketEnd);\n      return bracketEnd;\n    }\n    return compiler.error(\"Cant close bracket before branch\", {\n      pos,\n      pos0: decl.pos + 1,\n    });\n  }) ?? compiler.error(\"Invalid bracket close\", { pos });\n\nexport const closeBracketShort = (compiler: ChemCompiler): Int => {\n  const ch = compiler.curChar();\n  let step = 1;\n  if (ch === \"}\" && compiler.nextChar() === \"}\") {\n    step = 2;\n  }\n  const end = closeBracket(compiler, ch, compiler.pos);\n  compiler.pos += step;\n  scanPostItem(compiler, (it) => {\n    end.n = it;\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { StackItem } from \"./StackItem\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { closeNode } from \"./node\";\nimport { bindNodeToCurrentBond, getNodeForBondStart } from \"./bondCommon\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\n\nexport class BranchDecl extends StackItem {\n  constructor(\n    pos: Int,\n    public readonly node: ChemNode,\n    public readonly bond?: ChemBond\n  ) {\n    super(pos);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override msgInvalidClose() {\n    return \"It is necessary to close the branch\";\n  }\n}\n\n// Указатель установлен на символ < или * для случая (*\nexport const openBranch = (compiler: ChemCompiler): Int => {\n  const curNode: ChemNode = getNodeForBondStart(compiler, undefined);\n  compiler.push(new BranchDecl(compiler.pos, curNode, compiler.curBond));\n  compiler.chainSys.onBranchBegin();\n  compiler.nodesBranch.onBranchBegin();\n  return compiler.setState(stateAgentMid, 1);\n};\n\nexport const closeBranch = (compiler: ChemCompiler): Int => {\n  const decl = compiler.pop();\n  if (decl) {\n    if (decl instanceof BranchDecl) {\n      bindNodeToCurrentBond(compiler, compiler.curNode);\n      closeNode(compiler);\n\n      compiler.curNode = decl.node;\n      compiler.chainSys.onBranchEnd();\n      compiler.nodesBranch.onBranchEnd();\n      compiler.chainSys.setCurNode(decl.node);\n\n      return compiler.setState(stateAgentMid, 1);\n    }\n    // Ошибка: ветка закрывается до того, как закрыта скобка...\n    compiler.error(\"Cant close branch before bracket\", {\n      pos: compiler.pos,\n      pos0: decl.pos + 1,\n    });\n  }\n  return compiler.error(\"Invalid branch close\", { pos: compiler.pos });\n};\n\nexport const checkBranch = (compiler: ChemCompiler) => {\n  const it = compiler.pop();\n  if (it) {\n    compiler.error(it.msgInvalidClose(), { pos: it.pos });\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemOp } from \"../../core/ChemOp\";\nimport { closeEntity, onCreateEntity } from \"./entity\";\n\nexport class OpDef {\n  constructor(\n    public readonly src: string,\n    public readonly dst: string | null = null,\n    public readonly div: boolean = false\n  ) {}\n\n  opCode() {\n    return this.dst ?? this.src;\n  }\n}\n\n// <-- must be before <-\n\nexport const opsList: OpDef[] = [\n  new OpDef(\"+\"),\n  new OpDef(\"-->\", \"—→\", true),\n  new OpDef(\"--|>\", \"—→\", true),\n  new OpDef(\"->\", \"→\", true),\n  new OpDef(\"®\", \"→\", true),\n  new OpDef(\"→\", null, true),\n  new OpDef(\"=\", null, true),\n  new OpDef(\"↔\", null, true),\n  new OpDef(\"<-->\", \"←→\", true), // v2.2\n  new OpDef(\"<->\", \"↔\", true),\n  new OpDef(\"<=>\", \"\\u21CC\", true),\n  new OpDef(\"<==>\", \"\\u21CC\", true),\n  new OpDef(\"*\", \"∙\"), // deprecated\n  new OpDef(\"!=\", \"≠\", true),\n  new OpDef(\"<|--\", \"←—\", true), // v2.2\n  new OpDef(\"<--\", \"←—\", true), // v2.2\n  new OpDef(\"<-\", \"←\", true), // &#x2190; v2.2\n];\n\nexport const onCloseOp = (compiler: ChemCompiler) => {\n  compiler.curOp = undefined;\n};\n\nexport const createChemOp = (compiler: ChemCompiler, def: OpDef) => {\n  const { preComm } = compiler;\n  closeEntity(compiler);\n  const op = new ChemOp(def.src, def.opCode(), def.div);\n  op.color = compiler.varColor;\n  op.commentPre = preComm;\n  if (compiler.srcMap) {\n    compiler.entityBegin =\n      compiler.eject(\"preCommPos\") ?? compiler.pos - def.src.length;\n  }\n  onCreateEntity(compiler, op);\n  compiler.curOp = op;\n  if (def.div) {\n    compiler.curPart++;\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const getItemColor = (compiler: ChemCompiler): string | undefined =>\n  ifDef(compiler.varItemColor1, (it) => {\n    compiler.varItemColor1 = undefined;\n    return it;\n  }) ??\n  compiler.varItemColor ??\n  compiler.varColor;\n\nexport const getAtomColor = (compiler: ChemCompiler): string | undefined =>\n  ifDef(compiler.varAtomColor1, (it) => {\n    compiler.varAtomColor1 = undefined;\n    return it;\n  }) ?? compiler.varAtomColor;\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { Int } from \"../../types\";\nimport { scanId } from \"../parse/scanId\";\nimport { getNodeForced } from \"./node\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\n\n// Condition of call: compiler.curChar() == ':'\nexport const createLabel = (compiler: ChemCompiler): Int => {\n  compiler.pos++;\n  const it = scanId(compiler);\n  if (it) {\n    compiler.references[it] = getNodeForced(compiler, true);\n  } else compiler.error(\"Invalid label\", { pos: compiler.pos });\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemObj } from \"../../core/ChemObj\";\nimport { onCloseOp } from \"./chemOp\";\nimport { onCloseAgent } from \"./agent\";\n\nexport const onCreateEntity = (compiler: ChemCompiler, entity: ChemObj) => {\n  compiler.curEntity = entity;\n  compiler.expr.entities.push(entity);\n};\n\nexport const closeEntity = (compiler: ChemCompiler) => {\n  if (compiler.curEntity) {\n    compiler.curEntity = undefined;\n    onCloseAgent(compiler);\n    onCloseOp(compiler);\n  }\n  compiler.preComm = undefined;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { findElement } from \"../../core/PeriodicTable\";\n\nexport const findNode = (\n  compiler: ChemCompiler,\n  ref: string\n): ChemNode | undefined => {\n  const { nodes } = compiler.curAgent!;\n  const n = +ref;\n  if (!Number.isNaN(n)) {\n    return nodes[n < 0 ? n + nodes.length : n - 1];\n  }\n  // Возможно, метка...\n  // Если была указана метка, совпадающая с обозначением элемента, то метка имеет приоритет выше\n  const node = compiler.references[ref];\n  if (node) return node;\n\n  // если указан элемент\n  const elem = findElement(ref);\n  if (elem) {\n    const elemNode = nodes.find(\n      (it) => it.items.length === 1 && it.items[0]!.obj === elem\n    );\n    if (elemNode) return elemNode;\n  }\n  return undefined;\n};\n\nexport const findNodeEx = (\n  compiler: ChemCompiler,\n  ref: string,\n  pos: Int\n): ChemNode => {\n  const node = findNode(compiler, ref);\n  if (!node) compiler.error(\"Invalid node reference '[ref]'\", { ref, pos });\n  return node;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { lastItem } from \"../../utils/lastItem\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\nexport const closeItem = (compiler: ChemCompiler) => {};\n\nexport const getLastItem = (compiler: ChemCompiler): ChemNodeItem | undefined =>\n  lastItem(compiler.curNode?.items);\n","/*\nСредние точки ставятся перед описанием связи.\nВ итоге общий вектор связи является суммой средних точек и самой связи\nСвязь, имеющая средние точки, не может быть мягкой\n */\n\nimport { Point } from \"../../math/Point\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { getNodeForced } from \"./node\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { calcBondDirection, makeParamsDict } from \"./bondUniversal\";\n\nexport const applyMiddlePoints = (compiler: ChemCompiler, bond: ChemBond) => {\n  const { middlePoints } = compiler;\n  if (middlePoints.length === 0) {\n    return;\n  }\n  const bondPoints: Point[] = middlePoints.map((it) => it.pt);\n  bondPoints.push(bond.dir!);\n  bond.middlePoints = bondPoints;\n  bond.dir = bondPoints.reduce((acc, pt) => acc.iadd(pt), new Point());\n  bond.soft = false;\n  middlePoints.length = 0;\n};\n\nexport const checkMiddlePoints = (compiler: ChemCompiler) => {\n  if (compiler.middlePoints.length !== 0) {\n    compiler.error(\"Invalid middle point\", {\n      pos: compiler.middlePoints[0]!.pos,\n    });\n  }\n};\n\nexport const createMiddlePoint = (compiler: ChemCompiler) => {\n  // compiler.curChar() == 'm'\n  const startPos = compiler.pos - 1;\n  compiler.pos++;\n  if (compiler.curChar() !== \"(\") {\n    compiler.error(\"Expected '(' after [S]\", {\n      pos: compiler.pos - 1,\n      S: \"_m\",\n    });\n  }\n  getNodeForced(compiler, true);\n  compiler.pos++;\n  const args = scanArgs(compiler);\n  const params = makeParamsDict(args.args, args.argPos);\n  const dir = calcBondDirection(compiler, params);\n  compiler.middlePoints.push({ pt: dir, pos: startPos });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { ChemMul, ChemMulEnd } from \"../../core/ChemMul\";\nimport { closeNode, openNode } from \"./node\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const startMul = (\n  compiler: ChemCompiler,\n  k: ChemK,\n  isFirst: boolean\n) => {\n  const mul = new ChemMul(k, isFirst, compiler.varColor);\n  const { curNode, curBond } = compiler;\n  // Если нет узла, но есть связь, то надо создать автоузел, закрывающий связь.\n  mul.nodes[0] = curNode || ifDef(curBond, () => openNode(compiler, true));\n\n  closeNode(compiler);\n  compiler.chainSys.closeSubChain();\n  compiler.curAgent!.commands.push(mul);\n  compiler.mulCounter.create(mul);\n  compiler.bracketsCtrl.clear();\n};\n\nexport const stopMul = (compiler: ChemCompiler, mul: ChemMul) => {\n  compiler.mulCounter.close();\n  compiler.curAgent!.commands.push(new ChemMulEnd(mul));\n};\n\nexport const checkMulBeforeBracket = (compiler: ChemCompiler) => {\n  const it = compiler.mulCounter.getMulForBracket();\n  if (it) {\n    stopMul(compiler, it);\n  }\n};\n\nexport const checkMul = (compiler: ChemCompiler) => {\n  const it = compiler.mulCounter.getMulForced();\n  if (it) {\n    stopMul(compiler, it);\n  }\n};\n","import { Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { PeriodicTable } from \"../../core/PeriodicTable\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { checkMiddlePoints } from \"./middlePoint\";\nimport {\n  bindNodeToBond,\n  bindNodeToCurrentBond,\n  changeBondToHard,\n  findBondBetweenNodes,\n  mergeBonds,\n} from \"./bondCommon\";\nimport { closeItem } from \"./item\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { createBackground } from \"../../core/ChemBackground\";\n\nexport const closeNode = (compiler: ChemCompiler) => {\n  closeItem(compiler);\n  compiler.curNode = undefined;\n  compiler.chargeOwner = undefined;\n};\n\nexport const openNode = (\n  compiler: ChemCompiler,\n  isAuto: boolean = false\n): ChemNode => {\n  const bond = compiler.curBond;\n  if (bond) {\n    const { dir } = bond;\n    if (bond.soft && isAuto) {\n      // if second node of bond is auto, then bond is not soft\n      changeBondToHard(compiler, bond);\n    }\n    if (dir && !dir.isZero()) {\n      if (!bond.soft) {\n        const pt = bond.calcPt();\n        const existsNode = compiler.chainSys.findNode(pt);\n        if (existsNode) {\n          compiler.nodesBranch.onNode(existsNode);\n          if (!bond.soft || existsNode.autoMode) {\n            if (!bond.middlePoints) {\n              existsNode.fixed = true; // Узел уже не может автокорректироваться, т.к. это деформирует ранее построенную структуру.\n              const oldNode = bond.nodes[0]!;\n              const oldBond = findBondBetweenNodes(\n                compiler,\n                oldNode,\n                existsNode\n              );\n              if (oldBond) {\n                mergeBonds(compiler, oldBond, bond, existsNode);\n                return existsNode;\n              }\n            }\n          }\n          bindNodeToBond(compiler, existsNode, bond);\n          return existsNode;\n        }\n      }\n      // 0\\    /3  Возможна ситуация, когда уже существует мягкая связь из того же узла в том же направлении\n      //   1==2    Здесь цепь 4-1-2-5 на участке 1-2 может мержится с мягкой связью\n      // 4/    \\5\n      const softBond = compiler.curAgent?.bonds.find(\n        ({ soft, nodes, dir: testDir }) =>\n          soft &&\n          nodes.length === 2 &&\n          nodes[0]?.index === bond.nodes[0]?.index &&\n          !!nodes[1] &&\n          testDir &&\n          dir.equals(testDir)\n      );\n      if (softBond) {\n        const existsNode = softBond.nodes[1]!;\n        mergeBonds(compiler, softBond, bond, existsNode);\n        compiler.chainSys.setCurNode(existsNode);\n        return existsNode;\n      }\n    }\n  }\n  closeNode(compiler);\n  checkMiddlePoints(compiler);\n  // previous closed bracket\n  {\n    const cmd = lastItem(compiler.curAgent!.commands);\n    if (cmd instanceof ChemBracketEnd) {\n      compiler.chainSys.createSubChain();\n    }\n  }\n  const node = compiler.curAgent!.addNode(new ChemNode());\n  node.index = compiler.curAgent!.nodes.length - 1;\n  node.autoMode = isAuto;\n  // Цвет узла зависит только от $color, т.к. $itemColor и $atomColor относятся не к узлу, а к его элементам.\n  node.color = compiler.varColor;\n\n  compiler.curNode = node;\n  compiler.chargeOwner = node;\n  compiler.chainSys.addNode(node);\n  compiler.nodesBranch.onNode(node);\n  compiler.mulCounter.onNode(node);\n  node.bCenter = compiler.centralNode;\n  compiler.centralNode = false;\n\n  bindNodeToCurrentBond(compiler, node);\n  compiler.bracketsCtrl.onNode(node);\n\n  if (compiler.background) {\n    compiler.curAgent!.commands.push(\n      createBackground(compiler.background, node)\n    );\n    compiler.background = undefined;\n  }\n  return node;\n};\n\nexport const getNodeForced = (\n  compiler: ChemCompiler,\n  isAuto: boolean\n): ChemNode => compiler.curNode ?? openNode(compiler, isAuto);\n\n// Вызывается в самом конце, когда уже заполнен список bonds\nexport const updateAutoNode = (node: ChemNode) => {\n  node.items.push(new ChemNodeItem(PeriodicTable.dict.C));\n  const multipleSum: Double = Array.from(node.bonds).reduce(\n    (sum, chemBond) => sum + chemBond.n,\n    0.0\n  );\n  // Заряд влияет на валентность узла: carbon monoxide ⁻C≡O⁺\n  const charge: Int = node.charge?.value ?? 0;\n  const countH: Int = 4 + charge - Math.round(multipleSum);\n  if (countH > 0) {\n    node.items.push(new ChemNodeItem(PeriodicTable.dict.H, new ChemK(countH)));\n  }\n};\n","import { Lang } from \"../../lang/Lang\";\nimport { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemComment } from \"../../core/ChemComment\";\nimport { scanTo } from \"./scan\";\n\nexport const createComment = (compiler: ChemCompiler): ChemComment => {\n  const src = scanComment(compiler);\n  const dst = convertComment(src);\n  compiler.pos++;\n  return new ChemComment(dst);\n};\n\n/** Извлекает комментарий\n * Изначально pos должен быть установлен на первый символ внутри кавычек\n * В конце он установлен на завершающую кавычку\n */\nconst scanComment = (compiler: ChemCompiler): string => {\n  const pos0 = compiler.pos;\n  if (!scanTo(compiler, '\"')) {\n    compiler.error(\"Comment is not closed\", { pos: pos0 - 1 });\n  }\n  return compiler.subStr(pos0);\n};\n\nconst replaceLimited = (\n  text: string,\n  firstLimiter: Char,\n  lastLimiter: Char,\n  transform: (s: string) => string | undefined\n): string => {\n  let i = 0;\n  let result = text;\n  while (i < result.length) {\n    const beginPos = result.indexOf(firstLimiter, i);\n    if (beginPos < 0 || beginPos === result.length) break;\n    const endPos = result.indexOf(lastLimiter, beginPos + 1);\n    if (endPos < 0) break;\n    const key = result.slice(beginPos + 1, endPos);\n    const value = transform(key);\n    if (value !== undefined) {\n      // соответствие найдено. Выполняем замену\n      result = result.slice(0, beginPos) + value + result.slice(endPos + 1);\n      i = beginPos + value.length;\n    } else {\n      // соответствие не найдено. Оставляем скобки в тексте\n      i = beginPos + 1;\n    }\n  }\n  return result;\n};\n\n// Часто встречающиеся символы.\n// Внедряются в текст без каких-то синтаксических ограничителей.\n// Этот список не рекомендуется расширять, т.к. это снижает производительность\nconst specChars: [RegExp, string][] = [\n  [/\\|\\^/g, \"↑\"],\n  [/ArrowUp/g, \"↑\"],\n  [/\\|v/g, \"↓\"],\n  [/ArrowDown/g, \"↓\"],\n  [/\\^o/g, \"°\"],\n];\n\n// Выполнить подстановку специальных символов:\n// - часто встречающиеся символы типа градуса или стрелки.\n// - символы в квадратных скобках. (греческие буквы)\n// - фразы для локализации в обратных апострофах\nconst convertComment = (text: string): string => {\n  // замена частых символов\n  let result: string = specChars.reduce(\n    (acc, [first, second]) => acc.replace(first, second),\n    text\n  );\n\n  // замена символов в квадратных скобках.\n  result = replaceGreek(result);\n  // Перевод фраз из словаря\n  result = replaceLimited(result, \"`\", \"`\", (it) => Lang.findPhrase(it) ?? it);\n  return result;\n};\n\nconst replaceSlashed = (text: string): string =>\n  text.replace(/\\\\([A-Za-z][a-z]*)/g, (x, y) => specCharsB[y] || x);\n\n/**\n * Support of \\Greek in v 2.2\n */\nexport const replaceGreek = (src: string): string =>\n  replaceSlashed(replaceLimited(src, \"[\", \"]\", (it) => specCharsB[it]));\n\n// Символы в квадратных скобках.\n// Здесь можно добавлять другие символы без снижения производительности.\n// (на производительность влияет размер текста и количество скобок в нем)\n\nexport const specCharsB: Record<string, string> = {\n  alpha: \"α\",\n  Alpha: \"Α\",\n  beta: \"β\",\n  Beta: \"Β\",\n  gamma: \"γ\",\n  Gamma: \"Γ\",\n  delta: \"δ\",\n  Delta: \"Δ\",\n  epsilon: \"ε\",\n  Epsilon: \"Ε\",\n  zeta: \"ζ\",\n  Zeta: \"Ζ\",\n  eta: \"η\",\n  Eta: \"Η\",\n  theta: \"θ\",\n  Theta: \"Θ\",\n  iota: \"ι\",\n  Iota: \"Ι\",\n  kappa: \"κ\",\n  Kappa: \"Κ\",\n  lambda: \"λ\",\n  Lambda: \"Λ\",\n  mu: \"μ\",\n  Mu: \"Μ\",\n  nu: \"ν\",\n  Nu: \"Ν\",\n  xi: \"ξ\",\n  Xi: \"Ξ\",\n  omicron: \"ο\",\n  Omicron: \"Ο\",\n  pi: \"π\",\n  Pi: \"Π\",\n  rho: \"ρ\",\n  Rho: \"Ρ\",\n  sigma: \"σ\",\n  Sigma: \"Σ\",\n  tau: \"τ\",\n  Tau: \"Τ\",\n  upsilon: \"υ\",\n  Upsilon: \"Υ\",\n  phi: \"φ\",\n  Phi: \"Φ\",\n  chi: \"χ\",\n  Chi: \"Χ\",\n  psi: \"ψ\",\n  Psi: \"Ψ\",\n  omega: \"ω\",\n  Omega: \"Ω\",\n};\n","import { Char } from \"../../types\";\n\nexport const isDigit = (c: Char): boolean => c >= \"0\" && c <= \"9\";\n","import { Char } from \"../../types\";\n\nexport const isSpace = (ch: Char): boolean =>\n  ch === \" \" || ch === \"\\t\" || ch === \"\\n\";\n","import { Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst numConstDict: Record<string, Double> = {\n  $32: Math.sqrt(3.0) / 2.0,\n  $3: Math.sqrt(3.0),\n  $3x2: Math.sqrt(3.0) * 2,\n  $2: Math.sqrt(2.0),\n  $22: Math.sqrt(2.0) / 2.0,\n  $2x2: Math.sqrt(2.0) * 2,\n  \"½\": 0.5,\n  \"¼\": 1.0 / 4.0,\n  \"¾\": 3.0 / 4,\n  \"⅓\": 1.0 / 3,\n  \"⅔\": 2.0 / 3,\n};\n\nconst invalidNumber = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): never => {\n  compiler.error(\"Invalid number [n]\", { n: value, pos });\n};\n\nconst parseNumConst = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Double => numConstDict[value] ?? invalidNumber(compiler, value, pos);\n\nconst useVariable = (compiler: ChemCompiler, name: string, pos: Int): Double =>\n  compiler.varsDict[name] ??\n  compiler.error(\"Undefined variable [name]\", { name, pos });\n\nconst declareVariable = (\n  compiler: ChemCompiler,\n  name: string,\n  value: string,\n  pos: Int\n): Double => {\n  if (!name) {\n    compiler.error(\"Expected variable name\", { pos });\n  }\n  const v = +value;\n  const n: Double = Number.isNaN(v)\n    ? parseNumConst(compiler, value, pos + name.length + 1)\n    : v;\n  compiler.varsDict[name] = n;\n  return n;\n};\n\nconst parseVariable = (\n  compiler: ChemCompiler,\n  expr: string,\n  pos: Int\n): Double => {\n  const k = expr.indexOf(\":\");\n  return k < 0\n    ? useVariable(compiler, expr, pos)\n    : declareVariable(compiler, expr.slice(0, k), expr.slice(k + 1), pos);\n};\n\nconst parseNumExt = (\n  compiler: ChemCompiler,\n  srcValue: string,\n  valuePos: Int\n): Double => {\n  let k: Double = 1.0;\n  let value: string = srcValue;\n  let curPos = valuePos;\n  if (srcValue.startsWith(\"-\")) {\n    k = -1.0;\n    curPos++;\n    value = value.slice(1);\n  }\n  if (value.startsWith(\"%\")) {\n    return parseVariable(compiler, value.slice(1), curPos + 1) * k;\n  }\n  return parseNumConst(compiler, value, curPos) * k;\n};\n\nexport const parseNum = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Double => {\n  const v = value.trim();\n  if (!v) return 0.0;\n  const n = +v;\n  return Number.isNaN(n) ? parseNumExt(compiler, v, pos) : n;\n};\n","import { Int, Double } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"./parseNum\";\n\nexport const parsePadding = (\n  compiler: ChemCompiler,\n  values: string,\n  pos: Int\n): Double[] => {\n  const chunks = values.split(\";\");\n  let curPos = 0;\n  return chunks.map((val) => {\n    const n = parseNum(compiler, val, curPos + pos);\n    curPos += val.length + 1;\n    return n;\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { mainPreProcess } from \"../preprocessor/mainPreProcess\";\n\nexport const prepareText = (compiler: ChemCompiler) => {\n  const src0 = `${compiler.srcText} `;\n  const src = mainPreProcess(src0);\n  compiler.text = src;\n  compiler.expr.src0 = src0;\n  compiler.expr.src = src;\n};\n","import { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const scan = (\n  compiler: ChemCompiler,\n  isValid: (c: Char) => boolean\n): boolean => {\n  while (!compiler.isFinish() && isValid(compiler.curChar())) {\n    compiler.pos++;\n  }\n  return !compiler.isFinish();\n};\n\nexport const scanTo = (compiler: ChemCompiler, fin: Char): boolean =>\n  scan(compiler, (it) => it !== fin);\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport interface ArgsInfo {\n  args: string[];\n  argPos: Int[];\n}\n\n/**\n * Извлечение списка аргументов.\n * При входе позиция указывает на символ, следующий за (\n * При выходе - на следующий за )\n */\nexport const scanArgs = (compiler: ChemCompiler): ArgsInfo => {\n  const p0 = compiler.pos;\n  let prev = p0;\n  const args: string[] = [];\n  const argPos: Int[] = [];\n  let level = 0;\n  const addArg = () => {\n    argPos.push(prev);\n    args.push(compiler.subStr(prev));\n    prev = compiler.pos + 1;\n  };\n  while (!compiler.isFinish()) {\n    const ch = compiler.curChar();\n    if (ch === \"(\") {\n      level++;\n    } else if (ch === \")\") {\n      if (level === 0) break;\n      level--;\n    } else if (ch === \",\" && level === 0) {\n      addArg();\n    }\n    compiler.pos++;\n  }\n  if (compiler.isFinish())\n    compiler.error(\"It is necessary to close the bracket\", { pos: p0 - 1 });\n  if (p0 !== compiler.pos) {\n    addArg();\n  }\n  compiler.pos++;\n  return { args, argPos };\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n/*\nСуффиксы позволяют указать одну из следующих модификаций для только что объявленной связи.\nВо всех версиях используется с краткими описаниями связей.\nНачиная с версии 1.0 может применяться к полигональным связям\n\nДля полигональной связи не может использоваться 0, т.к. он воспринимается как часть числа, означающего число углов полигона\nПоэтому для пустой связи нужно использовать o\n */\n\ntype Action = (bond: ChemBond) => void;\n// private data class SuffixDef(val suffix: String, val action: (bond: ChemBond) -> Unit)\n\nconst bondSuffixes: [string, Action][] = [\n  [\n    \"0\",\n    (bond) => {\n      bond.n = 0.0;\n    },\n  ],\n  [\n    \"o\",\n    (bond) => {\n      bond.n = 0.0;\n    },\n  ],\n  [\"h\", (bond) => bond.setHydrogen()],\n  [\n    \"ww\",\n    (bond) => {\n      bond.w0 = 1;\n    },\n  ],\n  [\n    \"w\",\n    (bond) => {\n      bond.w1 = 1;\n    },\n  ],\n  [\n    \"dd\",\n    (bond) => {\n      bond.w0 = -1;\n    },\n  ],\n  [\n    \"d\",\n    (bond) => {\n      bond.w1 = -1;\n    },\n  ],\n  [\"x\", (bond) => bond.setCross()],\n  [\n    \"~\",\n    (bond) => {\n      bond.style = \"~\";\n    },\n  ],\n  [\n    \"r\",\n    (bond) => {\n      bond.align = \"r\";\n    },\n  ],\n  [\n    \"m\",\n    (bond) => {\n      bond.align = \"m\";\n    },\n  ],\n  [\n    \"l\",\n    (bond) => {\n      bond.align = \"l\";\n    },\n  ],\n  [\n    \"vvv\",\n    (bond) => {\n      bond.arr0 = true;\n      bond.arr1 = true;\n    },\n  ],\n  [\n    \"vv\",\n    (bond) => {\n      bond.arr0 = true;\n    },\n  ],\n  [\n    \"v\",\n    (bond) => {\n      bond.arr1 = true;\n    },\n  ],\n];\n\nexport const scanBondSuffix = (compiler: ChemCompiler, bond: ChemBond) => {\n  for (;;) {\n    const rec = bondSuffixes.find(([suffix]) => compiler.isCurPosEq(suffix));\n    if (!rec) break;\n\n    const [suffix, action] = rec;\n    action(bond);\n    compiler.pos += suffix.length;\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemCharge, createCharge } from \"../../core/ChemCharge\";\nimport { CoeffPosOrAngle } from \"../../types/CoeffPos\";\n\n// Извлечение заряда из текущей позиции.\n// Возвращает объект ChemCharge или null\n\nexport const scanCharge = (\n  compiler: ChemCompiler,\n  coeffPos: CoeffPosOrAngle = \"RT\"\n): ChemCharge | undefined => {\n  if (compiler.isFinish()) return undefined;\n  const pos0 = compiler.pos;\n  let prevCharge: ChemCharge | undefined;\n  for (;;) {\n    compiler.pos++;\n    const charge = createCharge(compiler.subStr(pos0), coeffPos);\n    if (!charge) {\n      compiler.pos--;\n      break;\n    }\n    prevCharge = charge;\n    if (compiler.isFinish()) break;\n  }\n  return prevCharge;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { scanTo } from \"./scan\";\nimport { CoeffPos } from \"../../types/CoeffPos\";\n\nexport const scanCoeff = (compiler: ChemCompiler): ChemK | undefined => {\n  const getCoeffPos = (): CoeffPos | undefined =>\n    compiler.getAltFlag() ? \"LB\" : undefined;\n  let ch = compiler.text[compiler.pos];\n  if (ch === \"`\") {\n    compiler.setAltFlag();\n    ch = compiler.text[++compiler.pos];\n  }\n  const pos0 = compiler.pos;\n  if (ch) {\n    if (ch >= \"0\" && ch <= \"9\") {\n      // Числовой коэфф\n      compiler.pos++;\n      while (!compiler.isFinish()) {\n        ch = compiler.text[compiler.pos];\n        if (!ch || ch < \"0\" || ch > \"9\") break;\n        compiler.pos++;\n      }\n      const s = compiler.subStr(pos0);\n      return new ChemK(+s, getCoeffPos());\n    }\n    if (ch === \"'\") {\n      // Абстрактный коэфф.\n      compiler.pos++;\n      if (!scanTo(compiler, \"'\"))\n        compiler.error(\"Abstract coefficient is not closed\", { pos: pos0 });\n      const s = compiler.subStr(pos0 + 1);\n      compiler.pos++;\n      return new ChemK(s, getCoeffPos());\n    }\n  }\n  return undefined;\n};\n","import { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const isIdFirstChar = (c: Char): boolean => /[A-Za-z]/.test(c);\n\nconst isIdChar = (c: Char): boolean => /[A-Z\\d]/i.test(c);\n\nexport const isId = (text: string): boolean => {\n  if (!text || !isIdFirstChar(text[0]!)) return false;\n  return !Array.from(text.slice(1)).find((it) => !isIdChar(it));\n};\n\nexport const scanId = (compiler: ChemCompiler): string | undefined => {\n  const startPos = compiler.pos;\n  if (isIdFirstChar(compiler.curChar())) {\n    compiler.pos++;\n    while (isIdChar(compiler.curChar())) compiler.pos++;\n  }\n  const id = compiler.subStr(startPos);\n  return id === \"\" ? undefined : id;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { isDigit } from \"./isDigit\";\n\nexport const scanInt = (compiler: ChemCompiler): Int | undefined => {\n  const oldPos = compiler.pos;\n  if (compiler.curChar() === \"-\" && isDigit(compiler.text[oldPos + 1]!)) {\n    compiler.pos++;\n  }\n  while (isDigit(compiler.curChar())) {\n    compiler.pos++;\n  }\n  return compiler.pos === oldPos ? undefined : +compiler.subStr(oldPos);\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { OpDef, opsList } from \"../main/chemOp\";\nimport { isSpace } from \"./isSpace\";\n\nexport const scanOp = (compiler: ChemCompiler): OpDef | undefined => {\n  const res = opsList.find((it) => compiler.isCurPosEq(it.src));\n  if (res) {\n    const nextPos = compiler.pos + res.src.length;\n    const nextChar = compiler.text[nextPos];\n    if (nextChar && !isSpace(nextChar) && nextChar !== '\"') {\n      // it is not operation. For example =|`=`|\n      return undefined;\n    }\n    compiler.pos += res.src.length;\n  }\n  return res;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { scanCoeff } from \"./scanCoeff\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const scanPostItem = (\n  compiler: ChemCompiler,\n  onCoeff: (coeff: ChemK) => void\n): boolean =>\n  ifDef(scanCoeff(compiler), (it) => {\n    onCoeff(it);\n    return true;\n  }) ?? false;\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { isSpace } from \"./isSpace\";\n\nexport const skipSpaces = (compiler: ChemCompiler) => {\n  while (compiler.pos < compiler.text.length && isSpace(compiler.curChar()))\n    compiler.pos++;\n};\n","export class Macros {\n  constructor(public readonly name: string) {}\n\n  body: string = \"\";\n}\n\nexport const globalMacros: Record<string, Macros> = {};\n","import { Int } from \"../../types\";\nimport { ChemError } from \"../../core/ChemError\";\nimport { LangParams } from \"../../lang\";\n\nexport class PreProcCtx {\n  src: string = \"\";\n\n  dst: string = \"\";\n\n  pos: Int = 0;\n\n  readonly stack: string[] = [];\n\n  constructor(ctx: PreProcCtx);\n\n  constructor(aSrc: string);\n\n  constructor(aSrc: string, aPos: Int);\n\n  constructor(aSrc: PreProcCtx | string, aPos?: Int) {\n    if (aSrc instanceof PreProcCtx) {\n      this.src = aSrc.src;\n      this.pos = aSrc.pos;\n    } else {\n      this.src = aSrc;\n      if (aPos !== undefined) this.pos = aPos;\n    }\n  }\n\n  error(msg: string, errPos: Int = 0): never {\n    if (errPos !== 0) {\n      this.pos = errPos < 0 ? this.pos + errPos : errPos;\n    }\n    throw new ChemError(msg, { pos: this.pos });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  errorPar(msg: string, params: LangParams): never {\n    throw new ChemError(msg, params);\n  }\n\n  // считать указанное число символов\n  n(count: Int = 1): string {\n    if (count === 0) {\n      return \"\";\n    }\n    if (this.pos + count > this.src.length) {\n      this.error(\"Unexpected end of macros\");\n    }\n    const start = this.pos;\n    this.pos += count;\n    return this.src.slice(start, this.pos);\n  }\n\n  // поиск подстроки\n  search(cond: string): string | undefined {\n    const start = this.pos;\n    const stop = this.src.indexOf(cond, start);\n    if (stop < 0) {\n      return undefined;\n    }\n    this.pos = stop + cond.length;\n    return this.src.slice(start, stop);\n  }\n\n  searchEx(cond: string): string {\n    return (\n      this.search(cond) ??\n      this.errorPar(\"Expected [cond] character in macros\", { cond })\n    );\n  }\n\n  // Достигнут ли конец?\n  end(): boolean {\n    return this.pos < this.src.length;\n  }\n\n  // вывод в dst\n  write(text: string) {\n    this.dst += text;\n  }\n\n  // Записать в выходной буфер остаток исходной строки (от pos до конца)\n  writeFinish() {\n    this.write(this.src.slice(this.pos));\n    this.pos = this.src.length;\n  }\n\n  push() {\n    this.stack.unshift(this.dst);\n    this.dst = \"\";\n  }\n\n  pop(): string {\n    const tmp = this.dst;\n    this.dst = this.stack.shift() || \"\";\n    return tmp;\n  }\n\n  clear() {\n    this.dst = \"\";\n  }\n}\n","import { isIdFirstChar } from \"../parse/scanId\";\nimport { defMacro } from \"./defMacro\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\n// Функция, которая ищет конец макроопределения. При этом, на вывод не идут объявления @:\n// Конструкция @:A()...@() заменяется на @A()\n// Окончание либо по концу буфера, либо по конструкции, отличающейся от @: и @A\n\nexport const bodyPreprocess = (ctx: PreProcCtx) => {\n  for (;;) {\n    const plain = ctx.search(\"@\");\n    if (plain === undefined) {\n      // макросов больше нет\n      ctx.writeFinish(); // пишем остаток строки и заканчиваем обработку\n      break;\n    }\n    ctx.write(plain); // Выводим предшествующий текст\n    const c = ctx.n(); // Следующий символ\n    if (c === \":\") {\n      // Объявление нового макроса\n      defMacro(ctx);\n    } else if (isIdFirstChar(c[0]!)) {\n      // вызов существующего макроса\n      ctx.write(`@${c}`);\n    } else {\n      // Остальные символы расцениваются как окончание тела. их разбор делает вызывающий код\n      ctx.pos--;\n      break;\n    }\n  }\n};\n","// определение нового макроса\n// имя, формальные параметры, тело\n// если завершение @; то ничего не выводится\n// если (... , то выводится @name(...\n\nimport { isIdFirstChar } from \"../parse/scanId\";\nimport { bodyPreprocess } from \"./bodyPreprocess\";\nimport { globalMacros, Macros } from \"./Macros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\nexport const defMacro = (ctx: PreProcCtx) => {\n  const p0 = ctx.pos;\n  const name = ctx.searchEx(\"(\");\n  if (!isIdFirstChar(name[0]!)) {\n    ctx.error(\"Invalid macro name\", p0);\n  }\n  const macro = new Macros(name);\n\n  // считывание тела макроса\n  // параметры читаются вместе с телом и разбираются при каждом вызове\n  // это даёт возможность включить в них параметры вышестоящего макроса\n  ctx.push();\n  bodyPreprocess(ctx);\n  macro.body = ctx.pop();\n  // анализ окончания\n  const c = ctx.n();\n  if (c === \"(\") {\n    // Окончание с вызовом\n    ctx.write(`@${name}${c}`);\n  } else if (c !== \";\") {\n    ctx.error(\"Invalid macros end\");\n  }\n  globalMacros[name] = macro;\n};\n","import { isId } from \"../parse/scanId\";\nimport { globalMacros } from \"./Macros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\nimport { MacroParams, readFormalPars } from \"./readFormalPars\";\nimport { scanPar } from \"./scanPar\";\n\nexport const applyParamValues = (\n  def: MacroParams,\n  params: string[],\n  ctx: PreProcCtx\n): PreProcCtx => {\n  if (def.names.length === 0) {\n    return ctx;\n  }\n  let curIndex = 0;\n  // Подставляем фактические значения\n  params.forEach((paramValue) => {\n    const k = paramValue.indexOf(\":\");\n    let ready = false;\n    if (k >= 0) {\n      const id = paramValue.slice(0, k);\n      if (id in def.dict) {\n        def.dict[id] = paramValue.slice(k + 1);\n        ready = true;\n      }\n    }\n    if (!ready) {\n      const name = def.names[curIndex++];\n      // Индексный параметр может быть пропущен, если пуст.\n      // Тогда вместо него будет использовано значение по умолчанию\n      if (name !== undefined && !!paramValue) {\n        def.dict[name] = paramValue;\n      }\n    }\n  });\n  // Замена параметров на значения\n  ctx.writeFinish();\n  const exl = ctx.dst.split(\"&\");\n  exl.slice(1).forEach((s, index) => {\n    const i = index + 1;\n    const id = def.names.reduce(\n      (prev, f) =>\n        s.slice(0, Math.min(f.length, s.length)) === f && f.length > prev.length\n          ? f\n          : prev,\n      \"\"\n    );\n    // Если в формуле встретился знак &, с которым не связан ни один параметр, пропускаем\n    if (id) {\n      // Замена параметра на значение\n      exl[i] = def.dict[id] + exl[i]!.slice(id.length);\n    }\n  });\n  return new PreProcCtx(exl.join(\"\"));\n};\n\nexport const readRealParams = (ctx: PreProcCtx): string[] => {\n  const result: string[] = [];\n  if (ctx.n() !== \")\") {\n    ctx.pos--;\n    do {\n      const p0 = ctx.pos;\n      const p1 = scanPar(ctx.src, p0);\n      if (p1 >= ctx.src.length) {\n        ctx.error(\"Real params list is not closed\");\n      }\n      result.push(ctx.n(p1 - p0));\n    } while (ctx.n() !== \")\");\n  }\n  return result;\n};\n\n// Исполнение макроса\n// params - индексный список фактических параметров, в тексте которых могут быть имена\n// так сделано из-за того, что до вызова точно не известно число формальных параметров\nexport const execMacros = (src: string, params: string[]): string => {\n  const ctx0 = new PreProcCtx(src);\n  // Извлечение формальных параметров\n  const p = readFormalPars(ctx0);\n  const ctx1 = applyParamValues(p, params, ctx0);\n  // Расшифровка всех макросов @A()\n  for (;;) {\n    const c = ctx1.search(\"@\");\n    if (c === undefined) {\n      ctx1.writeFinish();\n      break;\n    }\n    // Встречено объявление. Это может быть только конструкция @A\n    ctx1.write(c);\n    const name = ctx1.searchEx(\"(\");\n    if (!isId(name)) {\n      ctx1.errorPar(\"Invalid macro [name]\", { name });\n    }\n    const macro = globalMacros[name];\n    if (macro) {\n      // Извлечение фактических параметров\n      const realParams = readRealParams(ctx1);\n      ctx1.write(execMacros(macro.body, realParams));\n    } else ctx1.errorPar(\"Macros not found: [name]\", { name });\n  }\n  return ctx1.dst;\n};\n","import { bodyPreprocess } from \"./bodyPreprocess\";\nimport { execMacros } from \"./execMacros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\nexport const mainPreProcess = (src: string): string => {\n  // основной алгоритм выполнения препроцессора для заданной строки\n  const ctx = new PreProcCtx(src);\n  bodyPreprocess(ctx);\n  if (ctx.pos !== src.length) {\n    ctx.error(\"Invalid preprocessor finish\");\n  }\n  const dummyBody = `)${ctx.dst}`;\n  return execMacros(dummyBody, []);\n};\n","import { isId } from \"../parse/scanId\";\nimport { PreProcCtx } from \"./PreProcCtx\";\nimport { scanPar } from \"./scanPar\";\n\n// Хотя names по составу является тем же списком, который можно получить из dict.keys,\n// но необходимо гарантировать точный порядок.\n// Например в JavaScript такой порядок сохраняется, а C++ или Python - нет\n// Поэтому список формальных параметров имеет словарь имя/значение и список имен\nexport interface MacroParams {\n  dict: Record<string, string>;\n  names: string[];\n}\n\n// Формальные параметры x[:XX]\nexport const readFormalPars = (ctx: PreProcCtx): MacroParams => {\n  const dict: Record<string, string> = {};\n  const names: string[] = [];\n  if (ctx.n() !== \")\") {\n    ctx.pos--;\n    for (;;) {\n      const p0 = ctx.pos;\n      const p1 = scanPar(ctx.src, p0);\n\n      if (p1 >= ctx.src.length) {\n        ctx.error(\"Formal params list is not closed\");\n      }\n      const param = ctx.n(p1 - p0); // Получено объявление очередного параметра\n      const k = param.indexOf(\":\");\n      const [first, second] =\n        k < 0\n          ? // без значения по умолчанию\n            [param, \"\"]\n          : [param.slice(0, k), param.slice(k + 1)];\n\n      // Контролируем правильность описания названия параметра\n      if (!isId(first)) {\n        ctx.errorPar(\"Invalid parameter name: [name]\", { name: first });\n      }\n      dict[first] = second;\n      names.push(first);\n      const c = ctx.n();\n      if (c === \")\") break;\n    }\n  }\n  return { dict, names };\n};\n","import { Int } from \"../../types\";\n\n// Определение границы параметра. Ограничителем является знак , или )\nexport const scanPar = (src: string, start: Int): Int => {\n  // нужно учитывать баланс скобок и кавычек\n  let lock = 0;\n  let isComment = false;\n  let pos = start;\n  while (pos < src.length) {\n    const c = src[pos];\n    if (c === '\"') isComment = !isComment;\n    else if (c === \"(\" && !isComment) lock++;\n    else if (c === \",\" && !isComment && lock === 0) break;\n    else if (c === \")\" && !isComment) {\n      if (lock > 0) lock--;\n      else break;\n    }\n    pos++;\n  }\n  return pos;\n};\n","import { ChemObj } from \"../../core/ChemObj\";\nimport { SrcMapItem } from \"./SrcMapItem\";\n\nexport const getSrcItemsForObject = (\n  needObj: ChemObj,\n  srcMap?: SrcMapItem[]\n): SrcMapItem[] => srcMap?.filter(({ obj }) => needObj === obj) ?? [];\n","export * from \"./SrcMapItem\";\nexport * from \"./getSrcItemsForObject\";\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createAgent } from \"../main/agent\";\nimport { stateAgentBegin } from \"./stateAgentBegin\";\n\nexport const stateAgent: CompilerState = (compiler) => {\n  createAgent(compiler);\n  compiler.agentMode = \"begin\";\n  return compiler.setState(stateAgentBegin);\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { CompilerState } from \"../ChemCompiler\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { stateAgentIn } from \"./stateAgentIn\";\nimport { stateFuncName } from \"./stateFuncName\";\n\n/**\n * Начало агента может включать функции и коэффициент\n * @param compiler\n * @returns\n */\nexport const stateAgentBegin: CompilerState = (compiler) => {\n  compiler.agentMode = \"begin\";\n  const agent = compiler.curAgent;\n  if (!agent) {\n    compiler.error(\"stateAgentBegin with empty agent\", {});\n  } else {\n    if (compiler.curChar() === \"$\") {\n      return compiler.setState(stateFuncName, 1);\n    }\n\n    ifDef(scanCoeff(compiler), (coeff) => {\n      agent.n = coeff;\n      if (coeff) coeff.color = compiler.varColor;\n      if (compiler.srcMap) {\n        compiler.addSrcMapItem(agent, compiler.entityBegin, \"agentK\");\n        compiler.entityBegin = compiler.pos;\n      }\n    });\n  }\n  return compiler.setState(stateAgentIn);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { agentAnalyse } from \"../main/agentAnalyse\";\n\nexport const stateAgentIn: CompilerState = (compiler) =>\n  agentAnalyse(compiler, () =>\n    compiler.error(\"Unknown element character '[C]'\", {\n      C: compiler.curChar(),\n      pos: compiler.pos,\n    })\n  );\n","import { CompilerState } from \"../ChemCompiler\";\nimport { agentAnalyse } from \"../main/agentAnalyse\";\nimport { closeEntity } from \"../main/entity\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateAgentMid: CompilerState = (compiler) =>\n  agentAnalyse(compiler, () => {\n    closeEntity(compiler);\n    return compiler.setState(stateBegin);\n  });\n","import { CompilerState } from \"../ChemCompiler\";\nimport { skipSpaces } from \"../parse/skipSpaces\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateAgentSpace: CompilerState = (compiler) => {\n  skipSpaces(compiler);\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createChemOp } from \"../main/chemOp\";\nimport { scanOp } from \"../parse/scanOp\";\nimport { skipSpaces } from \"../parse/skipSpaces\";\nimport { stateAgent } from \"./stateAgent\";\nimport { stateCommentPre } from \"./stateCommentPre\";\nimport { stateOpEnd } from \"./stateOpEnd\";\n\nexport const stateBegin: CompilerState = (compiler) => {\n  skipSpaces(compiler);\n  if (compiler.isFinish()) {\n    return 0;\n  }\n\n  if (compiler.curChar() === '\"') {\n    return compiler.setState(stateCommentPre, 1);\n  }\n\n  const opDef = scanOp(compiler);\n  if (opDef != null) {\n    createChemOp(compiler, opDef);\n    return compiler.setState(stateOpEnd);\n  }\n\n  // Иначе считаем, что это начало реагента\n  return compiler.setState(stateAgent);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { startMul } from \"../main/multipier\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateBracketBegin: CompilerState = (compiler) => {\n  ifDef(scanCoeff(compiler), (it) => {\n    startMul(compiler, it, true);\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemChargeOwner } from \"../../core/ChemChargeOwner\";\nimport { CompilerState } from \"../ChemCompiler\";\nimport { openNode } from \"../main/node\";\nimport { scanCharge } from \"../parse/scanCharge\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateCharge: CompilerState = (compiler) => {\n  const { pos, curNode, curBond } = compiler;\n  // Если нет явно объявленного владельца, то можно постараться создать автоузел\n  const chargeOwner: ChemChargeOwner =\n    compiler.chargeOwner ??\n    (!curNode && curBond\n      ? openNode(compiler, true)\n      : compiler.error(\"Expected node declaration before charge\", {\n          pos: pos - 1,\n        }));\n  // Наличие ` перед объявлением заряда означает, что заряд нужно вывести слева\n  const isLeft = compiler.getAltFlag();\n  const varPos = compiler.eject(\"varPos\");\n  chargeOwner.charge =\n    scanCharge(compiler, varPos ?? (isLeft ? \"LT\" : \"RT\")) ??\n    compiler.error(\"Invalid charge declaration\", { pos });\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { createComment } from \"../parse/comment\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateCommentIn: CompilerState = (compiler) => {\n  addNodeItem(compiler, createComment(compiler));\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createComment } from \"../parse/comment\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateCommentPre: CompilerState = (compiler) => {\n  compiler.preCommPos = compiler.pos - 1;\n  compiler.preComm = createComment(compiler);\n  return compiler.setState(stateBegin);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { ChemRadical } from \"../../core/ChemRadical\";\nimport { ChemCustom } from \"../../core/ChemCustom\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { openBrace } from \"../main/brackets\";\nimport { replaceGreek } from \"../parse/comment\";\nimport { scanMarkupEnd } from \"../../utils/markup\";\n\n/**\n * Создание абстрактного элемента или радикала\n */\nexport const stateCustom: CompilerState = (compiler) => {\n  if (compiler.curChar() === \"{\") {\n    //  {{\n    return openBrace(compiler);\n  }\n  const startPos = compiler.pos; // pos установлен на символ, следующий за '{'\n  compiler.pos = scanMarkupEnd(compiler.text, compiler.pos, \"}\") - 1;\n  if (compiler.text[compiler.pos] !== \"}\")\n    compiler.error(\"Abstract element is not closed\", { pos: startPos - 1 });\n  const s = replaceGreek(compiler.subStr(startPos));\n  const item = addNodeItem(compiler, ChemRadical.dict[s] ?? new ChemCustom(s));\n  compiler.pos++;\n  scanPostItem(compiler, (it) => {\n    item.n = it;\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scan } from \"../parse/scan\";\nimport { findElement } from \"../../core/PeriodicTable\";\nimport { ChemRadical } from \"../../core/ChemRadical\";\nimport { ChemSubObj } from \"../../core/ChemSubObj\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { statePostItem } from \"./statePostItem\";\n\n// Извлечение элемента. Позиция первого символа elementStartPos\nexport const stateElement: CompilerState = (compiler) => {\n  scan(compiler, (it) => it >= \"a\" && it <= \"z\");\n  const id = compiler.subStr(compiler.elementStartPos);\n  const elem: ChemSubObj =\n    findElement(id) ??\n    ChemRadical.dict[id] ??\n    compiler.error(\"Unknown element '[Elem]'\", {\n      pos: compiler.elementStartPos,\n      Elem: id,\n    });\n  const item = addNodeItem(compiler, elem);\n  compiler.addSrcMapItem(item, compiler.elementStartPos);\n  return compiler.setState(statePostItem);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scanTo } from \"../parse/scan\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { funcsDict } from \"../funcs/funcsDict\";\nimport { stateAgentBegin } from \"./stateAgentBegin\";\n\nexport const stateFuncName: CompilerState = (compiler) => {\n  const startPos = compiler.pos; // Указывает на следующий символ за $\n  if (!scanTo(compiler, \"(\"))\n    compiler.error(\"Expected '(' after [S]\", { S: \"$\", pos: startPos - 1 });\n  const name = compiler.subStr(startPos);\n  compiler.pos++;\n  const { args, argPos } = scanArgs(compiler);\n  // Если имя функции не найдено, функция игнорируется\n  // с целью совместимости со следующими версиями\n  ifDef(funcsDict[name], (func) => func(compiler, args, argPos));\n  if (compiler.agentMode === \"begin\") {\n    // Случай, когда функция описывается раньше чем создан агент\n    return compiler.setState(stateAgentBegin);\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler, CompilerState } from \"../ChemCompiler\";\nimport { isSpace } from \"../parse/isSpace\";\nimport { stateAgentSpace } from \"./stateAgentSpace\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemAtom } from \"../../core/ChemAtom\";\nimport { findElement } from \"../../core/PeriodicTable\";\nimport { scanId } from \"../parse/scanId\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { scanInt } from \"../parse/scanInt\";\nimport { mergeBonds } from \"../main/bondCommon\";\n\nconst onReferenceError = (\n  compiler: ChemCompiler,\n  ref: string,\n  pos: Int\n): never => compiler.error(\"Invalid node reference '[ref]'\", { ref, pos });\n\nconst bondNodesKey = (bond: ChemBond): string =>\n  bond.nodes.map((n) => n?.index ?? \"\").join(\",\");\n\nconst useRef = (compiler: ChemCompiler, node: ChemNode) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    curBond.soft = false;\n    curBond.nodes[1] = node;\n    // Здесь нужна проверка на мерж связей...\n    const curKey = bondNodesKey(curBond);\n    const prevBond = compiler.curAgent?.bonds.find(\n      (b) => bondNodesKey(b) === curKey\n    );\n    if (prevBond && prevBond !== curBond) {\n      compiler.chainSys.setCurNode(curBond.nodes[1]);\n      mergeBonds(compiler, prevBond, curBond, node);\n    } else {\n      compiler.chainSys.bondToRef(curBond);\n    }\n  } else {\n    compiler.chainSys.addNode(node);\n    compiler.nodesBranch.onNode(node);\n  }\n  compiler.curNode = node;\n  node.fixed = true;\n  compiler.nodesBranch.onNode(node);\n};\n\nconst useRefByNumber = (compiler: ChemCompiler, n: Int, startPos: Int) => {\n  const { nodes } = compiler.curAgent!;\n  const index: Int = n < 0 ? nodes.length + n : n - 1;\n  if (index < 0 || index >= nodes.length) {\n    onReferenceError(compiler, String(n), startPos);\n  }\n  useRef(compiler, nodes[index]!);\n};\n\nconst isAtomNode = (node: ChemNode, atom: ChemAtom): boolean =>\n  node.items.length === 1 && node.items[0]!.obj === atom;\n\nconst useRefByAtom = (\n  compiler: ChemCompiler,\n  atom: ChemAtom,\n  startPos: Int\n) => {\n  const { nodes } = compiler.curAgent!;\n  useRef(\n    compiler,\n    nodes.find((it) => isAtomNode(it, atom)) ??\n      onReferenceError(compiler, atom.id, startPos)\n  );\n};\n\nconst useRefById = (compiler: ChemCompiler, id: string, startPos: Int) => {\n  const ref = compiler.references[id];\n  if (ref) {\n    useRef(compiler, ref);\n  } else {\n    const elem = findElement(id);\n    if (elem) {\n      useRefByAtom(compiler, elem, startPos);\n    } else {\n      onReferenceError(compiler, id, startPos);\n    }\n  }\n};\n\nexport const stateNodeRef: CompilerState = (compiler) => {\n  if (isSpace(compiler.curChar())) {\n    return compiler.setState(stateAgentSpace);\n  }\n  const startPos = compiler.pos;\n  const n = scanInt(compiler);\n  if (n !== undefined) {\n    useRefByNumber(compiler, n, startPos);\n  } else {\n    const id = scanId(compiler);\n    if (id) {\n      useRefById(compiler, id, startPos);\n    } else onReferenceError(compiler, compiler.curChar(), startPos);\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createComment } from \"../parse/comment\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateOpEnd: CompilerState = (compiler) => {\n  if (compiler.curChar() === '\"') {\n    compiler.pos++;\n    compiler.curOp!.commentPost = createComment(compiler);\n  }\n  if (compiler.curOp) {\n    compiler.addSrcMapItem(compiler.curOp, compiler.eject(\"entityBegin\"));\n  }\n  return compiler.setState(stateBegin);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { getLastItem } from \"../main/item\";\nimport { scanCharge } from \"../parse/scanCharge\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const statePostItem: CompilerState = (compiler) => {\n  const item = getLastItem(compiler) ?? compiler.error(\"Invalid node\", {});\n  if (\n    scanPostItem(compiler, (it) => {\n      item.n = it;\n    })\n  )\n    return compiler.setState(statePostItem);\n\n  if (compiler.curChar() === \"(\") {\n    const bracketPos = compiler.pos;\n    compiler.pos++;\n    const charge = scanCharge(compiler);\n    if (charge && compiler.curChar() === \")\") {\n      item.charge = charge;\n      return compiler.setState(statePostItem, 1);\n    }\n    compiler.pos = bracketPos;\n  }\n\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createPolygonalBond } from \"../main/bondPolygonal\";\nimport { createRingBond } from \"../main/bondRing\";\nimport { createSplineBond } from \"../main/bondSpline\";\nimport { createUniversalBond } from \"../main/bondUniversal\";\nimport { createMiddlePoint } from \"../main/middlePoint\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateUniBond: CompilerState = (compiler) => {\n  const begin = compiler.pos - 1;\n  switch (compiler.curChar()) {\n    case \"(\":\n      {\n        compiler.pos++;\n        const { args, argPos } = scanArgs(compiler);\n        createUniversalBond(compiler, args, argPos, begin);\n      }\n      break;\n    case \"p\":\n    case \"q\":\n      createPolygonalBond(compiler);\n      break;\n    case \"m\":\n      createMiddlePoint(compiler);\n      break;\n    case \"o\":\n      createRingBond(compiler, 1);\n      break;\n    case \"s\":\n      createSplineBond(compiler);\n      break;\n    default:\n      createUniversalBond(compiler, [], [], begin);\n      break;\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { Int } from \"../types\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemNode } from \"./ChemNode\";\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemK } from \"./ChemK\";\nimport { Visitor } from \"./Visitor\";\nimport { StructAnalyzer } from \"./StructAnalyzer\";\n\nexport class ChemAgent extends ChemObj {\n  nodes: ChemNode[] = [];\n\n  bonds: ChemBond[] = [];\n\n  commands: ChemObj[] = [];\n\n  n: ChemK = new ChemK(1);\n\n  part: Int = 0;\n\n  stA: StructAnalyzer;\n\n  constructor() {\n    super();\n    this.stA = new StructAnalyzer(this);\n  }\n\n  setCoeff(k: ChemK | number) {\n    this.n = typeof k === \"number\" ? new ChemK(k) : k;\n  }\n\n  addNode(node: ChemNode): ChemNode {\n    this.nodes.push(node);\n    this.commands.push(node);\n    return node;\n  }\n\n  addBond(bond: ChemBond) {\n    this.bonds.push(bond);\n    this.commands.push(bond);\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.agentPre?.(this);\n    if (visitor.isStop) return;\n    for (const cmd of this.commands) {\n      cmd.walk(visitor);\n      if (visitor.isStop) return;\n    }\n    visitor.agentPost?.(this);\n  }\n}\n","import { Int, Double } from \"../types\";\nimport { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemAtom extends ChemSubObj {\n  readonly stable: boolean;\n\n  readonly epsilonMass: Double | undefined; // +/- Abridged standard atomic weight\n\n  constructor(\n    readonly n: Int, // Atomic number\n    readonly id: string, // Symbol of a chemical element: H, He, Li, Be...\n    readonly mass: Double, // Atomic mass in Daltons\n    options?: {\n      epsilonMass?: Double;\n      stable?: boolean;\n    }\n  ) {\n    super();\n    const { stable, epsilonMass } = options ?? {};\n    this.stable =\n      stable === undefined ? Math.floor(this.mass) !== this.mass : stable;\n    this.epsilonMass = epsilonMass;\n  }\n\n  walk<T extends Visitor>(visitor: T) {\n    visitor.atom?.(this);\n  }\n}\n","import { Double } from \"../types\";\nimport { ChemNode } from \"./ChemNode\";\nimport { ChemObj } from \"./ChemObj\";\n\nexport interface ParamsChemBackground {\n  shape?: string; // round, ellipse or rect\n  padding?: Double[]; // [all], [vert, horiz], [top, horiz, bottom], [top, l, bot, r]\n  isAll?: boolean;\n  nodes?: ChemNode[];\n  borderRadius?: Double;\n  fill?: string;\n  stroke?: string;\n  strokeWidth?: Double;\n}\n\n/**\n * $background()\n */\nexport class ChemBackground extends ChemObj {\n  constructor(public readonly params: ParamsChemBackground) {\n    super();\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  override walk(): void {}\n}\n\nexport const createBackground = (\n  params: ParamsChemBackground,\n  curNode: ChemNode\n): ChemBackground => {\n  if (!params.isAll) {\n    // eslint-disable-next-line no-param-reassign\n    params.nodes = params.nodes ?? [];\n    params.nodes.push(curNode);\n  }\n  return new ChemBackground(params);\n};\n","import { Double, Int } from \"../types\";\nimport { Point } from \"../math/Point\";\nimport { is0, toa } from \"../math\";\nimport { ChemNode } from \"./ChemNode\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemObj } from \"./ChemObj\";\nimport { isNodeHidden } from \"./isNodeHidden\";\n\nexport type BondAlign = \"x\" | \"r\" | \"m\" | \"l\";\n\nexport class ChemBond extends ChemObj {\n  n: Double = 1.0; // multiplicity of the bond\n\n  nodes: (ChemNode | undefined)[] = [undefined, undefined];\n\n  index?: Int; // index of bond in ChemAgent.bonds array\n  // TODO: может быть нарушена в closeAgent при удалении дублирующих связей !!!\n\n  dir?: Point; // bond vector\n\n  tx: string = \"\"; // text description\n\n  slope: Int = 0; // для связи, созданной из описания / = -1, для \\ = 1, для остальных =0\n\n  isText: boolean = false;\n\n  color?: string; // цвет связи\n\n  w0: Int = 0; // Толщина начала линии, 0 для обычной толщины, 1 для жирной\n\n  w1: Int = 0; // толщина конца линии\n\n  isAuto: boolean = false; // Признак связи, пригодной для автокоррекции\n\n  soft: boolean = false;\n\n  //  ~ : | I\n  style: string = \"\"; // Строковый стиль линии. Для двойных и тройных связей каждая линия указывается отдельно\n\n  align?: BondAlign; // Возможные режимы выравнивания двойной связи. x:перекрещенная, m:по центру, l:влево, r:вправо\n\n  arr0: boolean = false; // Стрелка в обратную сторону\n\n  arr1: boolean = false; // Стрелка по направлению линии\n\n  ext: \"\" | \"o\" | \"s\" = \"\"; // for _o = 'o', for _s = 's'\n\n  brk: boolean = false; // Устанавливается для конструкции типа -#a-#b-#c-, для связи, предшествующей существующему узлу\n\n  isNeg: boolean = false; // Использовался символ `\n\n  isCorr: boolean = false; // Выполнена коррекция наклона с 30 до 60 градусов\n\n  isCycle: boolean = false; // Циклическая связь. Всегда true для _o и может быть для _s\n\n  middlePoints?: Point[]; // Дополнительные точки для искривленных связей.\n  // Если связь имеет дополнительные точки, то она не будет мержиться с другими связями между этими же узлами\n\n  // Position calculate for second part of bond\n  calcPt(): Point {\n    return this.nodes[0]!.pt.plus(this.dir!);\n  }\n\n  // Get another node of bond\n  other(node: ChemNode): ChemNode | undefined {\n    if (this.nodes.length !== 2) return undefined;\n    if (this.nodes[0] === node) return this.nodes[1];\n    if (this.nodes[1] === node) return this.nodes[0];\n    return undefined;\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.bond?.(this);\n  }\n\n  setHydrogen() {\n    this.style = \":\";\n    this.n = 0.0;\n  }\n\n  setCross() {\n    this.align = \"x\";\n  }\n\n  isCross() {\n    return this.align === \"x\";\n  }\n\n  checkText() {\n    // Связь считается текстовой, если она расположена горизонтально и имеет длину =1\n    const { dir } = this;\n    this.isText = dir ? is0(dir.y) && is0(Math.abs(dir.x) - 1) : false;\n  }\n\n  linearText(): string {\n    if (this.isAuto) {\n      let res: string = this.tx;\n      if (this.isNeg) res = `\\`${res}`;\n      if (is0(this.n)) res += \"0\";\n      return res;\n    }\n    return this.tx;\n  }\n\n  isHorizontal(): boolean {\n    const { dir } = this;\n    return dir ? !is0(dir.x) && is0(dir.y) : false;\n  }\n\n  debugText(): string {\n    const bondTextStd = (it: ChemBond) =>\n      `${it.nodes[0]?.index}` +\n      `(${it.soft ? \"~\" : \"\"}${it.dir?.polarAngleDeg().toFixed(0)}` +\n      `${it.n !== 1.0 ? `*${toa(it.n)}` : \"\"})` +\n      `${it.nodes[1]?.index}`;\n\n    const bondTextExt = (bond: ChemBond) =>\n      `${bond.linearText()}${bond.nodes.map((it) => it?.index)}`;\n\n    return this.nodes.length === 2 ? bondTextStd(this) : bondTextExt(this);\n  }\n\n  isVisible(): boolean {\n    if (this.isVerticalConnection()) return false;\n    return !is0(this.n) || !!this.style;\n  }\n\n  /**\n   * Vertical connection of atoms without bond drawing.\n   * Most commonly used in /N<_(y-.5)H>\\ or \\N<_(y.5)H/>\n   */\n  isVerticalConnection(): boolean {\n    const { dir, nodes } = this;\n    if (!dir || nodes.length !== 2) return false;\n    if (!nodes[0] || isNodeHidden(nodes[0])) return false;\n    if (!nodes[1] || isNodeHidden(nodes[1])) return false;\n    return is0(dir.x) && is0(Math.abs(dir.y) - 0.5);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemChargeOwner } from \"./ChemChargeOwner\";\nimport { ChemCharge } from \"./ChemCharge\";\nimport { ChemNode, ChemNodeOptPair } from \"./ChemNode\";\nimport { ChemK } from \"./ChemK\";\n\n// Pairs of open and closed brackets\nexport const bracketPairs: Record<string, string> = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{{\": \"}}\",\n};\n\nexport interface CommonBracket {\n  text: string;\n  color?: string;\n  nodes: ChemNodeOptPair;\n  bond?: ChemBond;\n}\n\nexport class ChemBracketBegin extends ChemObj implements CommonBracket {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  end?: ChemBracketEnd;\n\n  isText?: boolean;\n\n  bond?: ChemBond;\n\n  color?: string;\n\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  padding?: number[];\n\n  override walk(visitor: Visitor) {\n    visitor.bracketBegin?.(this);\n  }\n}\n\nexport class ChemBracketEnd\n  extends ChemObj\n  implements ChemChargeOwner, CommonBracket\n{\n  constructor(\n    public readonly text: string,\n    public readonly begin: ChemBracketBegin,\n    nodeIn: ChemNode\n  ) {\n    super();\n    this.nodes[0] = nodeIn;\n  }\n\n  charge?: ChemCharge = undefined;\n\n  n: ChemK = new ChemK(1);\n\n  bond?: ChemBond;\n\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  // this.bond = null\n  override walk(visitor: Visitor) {\n    visitor.bracketEnd?.(this);\n  }\n\n  get nodeIn() {\n    return this.nodes[0];\n  }\n\n  get color(): string | undefined {\n    return this.begin.color;\n  }\n}\n\nexport const getBracketsContent = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): ChemObj[] => {\n  const { end } = begin;\n  let start = 0;\n  while (start < commands.length && commands[start] !== begin) start++;\n  let stop = start;\n  while (stop < commands.length && commands[stop] !== end) stop++;\n  return commands.slice(start + 1, stop);\n};\n","import { CoeffPosOrAngle, isLeftCoeffA } from \"../types/CoeffPos\";\nimport { Double } from \"../types\";\nimport { romanNum } from \"../utils/romanNum\";\n\nexport class ChemCharge {\n  get isLeft(): boolean {\n    // ⁺N\n    return isLeftCoeffA(this.pos);\n  }\n\n  constructor(\n    public readonly text: string, // Text description, for example: '2+'\n    public readonly value: Double, // number value, for example: 2\n    public readonly pos: CoeffPosOrAngle = \"RT\", // relative position of charge from $pos()\n    public readonly isRound: boolean = false // A sign of drawing a charge inside a circle\n  ) {}\n}\n\nconst leftSigned = /(^|(^[-+]))\\d+$/;\nconst rightSigned = /^\\d+[-+]$/;\nconst minuses = new Set([\"-\", \"--\", \"---\"]);\nconst pluses = new Set([\"+\", \"++\", \"+++\"]);\n\n/**\n * Create charge object from text description\n * Особенностью любого текстового описания заряда в том, что при компиляции происходят попытки,\n * начиная с одного символа и увеличивая количество символов до тех пор, пока это валидное выражение.\n * То есть, не может быть такого, что двухсимвольное описание валидно, а односимвольное - нет.\n */\nexport const createCharge = (\n  chargeDescr: string,\n  pos: CoeffPosOrAngle = \"RT\"\n): ChemCharge | undefined => {\n  if (chargeDescr === \"\") return undefined;\n  const text = chargeDescr // Replace similar characters\n    .replace(\"–\", \"-\") // \\u2013\n    .replace(\"−\", \"-\"); // \\u2212\n  // One or more minuses:\tO^--\n  if (minuses.has(text)) return new ChemCharge(text, -text.length, pos);\n  // One or more pluses: Zn^++\n  if (pluses.has(text)) return new ChemCharge(text, text.length, pos);\n  // A number with a plus or minus front: S^+6, O^-2\n  if (leftSigned.test(text)) return new ChemCharge(text, +text, pos);\n  // A number with plus or minus behind: Ca^2+, PO4^3-\n  if (rightSigned.test(text))\n    return new ChemCharge(text, +`${text.slice(-1)}${text.slice(0, -1)}`, pos);\n  if (text === \"+o\") return new ChemCharge(\"+\", 1.0, pos, true);\n  if (text === \"-o\") return new ChemCharge(\"-\", -1.0, pos, true);\n  const v = romanNum[text];\n  if (v) return new ChemCharge(text.toUpperCase(), v, pos);\n  return undefined;\n};\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemComma extends ChemSubObj {\n  override walk(visitor: Visitor) {\n    visitor.comma?.(this);\n  }\n}\n\nexport const instChemComma: ChemComma = new ChemComma();\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemComment extends ChemSubObj {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.comment?.(this);\n  }\n}\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\n/**\n * Abstract component\n * For example: {R}-OH\n * Created by PeterWin on 29.04.2017.\n */\nexport class ChemCustom extends ChemSubObj {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.custom?.(this);\n  }\n}\n","import { LangParams, Lang } from \"../lang\";\n\nexport class ChemError extends Error {\n  readonly msgId: string;\n\n  readonly params?: LangParams;\n\n  constructor(msgId: string, params?: LangParams) {\n    super(Lang.tr(msgId, params));\n    this.msgId = msgId;\n    this.params = params;\n  }\n\n  getMessage(locale?: string): string {\n    return Lang.tr(this.msgId, this.params, locale);\n  }\n}\n\nexport const getErrorMessage = (err: Error, locale?: string): string => {\n  if (err instanceof ChemError) {\n    if (!locale) return err.getMessage();\n    const oldLang = Lang.curLang;\n    Lang.curLang = locale;\n    const msg = err.getMessage(locale);\n    Lang.curLang = oldLang;\n    return msg;\n  }\n  return err.message;\n};\n","import { SrcMapItem } from \"../compiler/sourceMap/SrcMapItem\";\r\nimport { Double } from \"../types\";\r\nimport { ChemObj } from \"./ChemObj\";\r\nimport { Visitor } from \"./Visitor\";\r\nimport { ChemAgent } from \"./ChemAgent\";\r\nimport { getErrorMessage } from \"./ChemError\";\r\nimport { calcMass } from \"../inspectors/calcMass\";\r\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\r\nimport { getSrcItemsForObject } from \"../compiler/sourceMap\";\r\nimport { textFormula } from \"../textBuilder/textFormula\";\r\n\r\nexport class ChemExpr extends ChemObj {\r\n  error?: Error;\r\n\r\n  // Source description\r\n  src0: string = \"\";\r\n\r\n  // Description after preprocessing\r\n  src: string = \"\";\r\n\r\n  // Entities: reagents and operations\r\n  entities: ChemObj[] = [];\r\n\r\n  srcMap?: SrcMapItem[];\r\n\r\n  // Check for success. If false, then an error.\r\n  isOk(): boolean {\r\n    return !this.error;\r\n  }\r\n\r\n  // Extended error message. Empty string, if not error\r\n  getMessage(locale?: string): string {\r\n    const { error } = this;\r\n    return error ? getErrorMessage(error, locale) : \"\";\r\n  }\r\n\r\n  override walk(visitor: Visitor) {\r\n    for (const entity of this.entities) {\r\n      visitor.entityPre?.(entity);\r\n      if (visitor.isStop) return;\r\n      entity.walk(visitor);\r\n      if (visitor.isStop) return;\r\n      visitor.entityPost?.(entity);\r\n      if (visitor.isStop) return;\r\n    }\r\n  }\r\n\r\n  getAgents(): ChemAgent[] {\r\n    // Правильно было бы использовать walk.\r\n    // Но этот вариант работает быстрее, т.к. walk обходит все подчиненные объекты.\r\n    // А здесь просто цикл по сущностям верхего уровня, которых обычно не более 10.\r\n    const result = this.entities.filter(\r\n      (entity: ChemObj) => entity instanceof ChemAgent\r\n    );\r\n    return result as ChemAgent[];\r\n  }\r\n\r\n  findMapItems(target: ChemObj): SrcMapItem[] {\r\n    return getSrcItemsForObject(target, this.srcMap);\r\n  }\r\n\r\n  srcMapItemText(item: SrcMapItem): string {\r\n    return this.src.slice(item.begin, item.end);\r\n  }\r\n\r\n  /**\r\n   * Если выражение состоит более чем из одного агента (а это не редкость),\r\n   * то считать его общую массу через calcMass не имеет смысла.\r\n   * Данная функция считает массу каждого агента отдельно.\r\n   * @param applyK Если false, то не учитываются коэффициенты перед агентами.\r\n   */\r\n  mass(applyK: boolean = true): Double[] {\r\n    return this.getAgents().map((it) => calcMass(it, applyK));\r\n  }\r\n\r\n  /**\r\n   * This method has been added for compatibility with previous versions.\r\n   * It is recommended to explicitly use function textFormula.\r\n   * @deprecated\r\n   */\r\n  html(poor = false): string {\r\n    return textFormula(this, poor ? \"htmlPoor\" : \"html\");\r\n  }\r\n\r\n  /**\r\n   * This method has been added for compatibility with previous versions.\r\n   * It is recommended to explicitly use function isTextFormula.\r\n   */\r\n  isLinear(): boolean {\r\n    return isTextFormula(this);\r\n  }\r\n\r\n  static createWithError(error: Error, src: string) {\r\n    const expr = new ChemExpr();\r\n    expr.error = error;\r\n    expr.src0 = src;\r\n    expr.src = src;\r\n    return expr;\r\n  }\r\n}\r\n","// Chemical Coefficient.\n// Can be number or string (abstract coefficient: C'n'H'2n+2')\nimport { Double } from \"../types\";\nimport { toa } from \"../math\";\nimport { CoeffPos } from \"../types/CoeffPos\";\n\nexport class ChemK {\n  readonly num: Double;\n\n  readonly text: string;\n\n  pos?: CoeffPos;\n\n  color?: string;\n\n  constructor(n: Double, pos?: CoeffPos);\n\n  constructor(text: string, pos?: CoeffPos);\n\n  constructor(k: number | string, pos?: CoeffPos) {\n    if (typeof k === \"number\") {\n      this.num = k;\n      this.text = \"\";\n    } else {\n      this.text = k;\n      this.num = NaN;\n    }\n    this.pos = pos;\n  }\n\n  static readonly one = new ChemK(1);\n\n  // Na2S.  Is specified for Na and not for S\n  isSpecified() {\n    return !!this.text || (this.num !== 1 && !Number.isNaN(this.num));\n  }\n\n  isNumber() {\n    return !Number.isNaN(this.num);\n  }\n\n  isAbstract() {\n    return !this.isNumber();\n  }\n\n  isInt(): boolean {\n    // eslint-disable-next-line no-bitwise\n    return this.num === ~~this.num;\n  }\n\n  equals(k: ChemK | string | number): boolean {\n    if (typeof k === \"number\" && this.isNumber()) {\n      return this.num === k;\n    }\n    if (typeof k === \"string\" && !this.isNumber()) {\n      return this.text === k;\n    }\n    if (k instanceof ChemK) {\n      return this.text ? this.text === k.text : this.num === k.num;\n    }\n    return false;\n  }\n\n  toString() {\n    return this.isNumber() ? toa(this.num) : this.text;\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemK } from \"./ChemK\";\nimport { ChemNodeOptPair } from \"./ChemNode\";\n/**\n * В версиях до 1.1 включительно умножитель действует только начиная с символа умножения\n * Например, CuSO4*5H2O. Здесь один умножитель.\n * Проблема начинается, когда появляется коэффициент перед агентом.\n * Вот пример уравнения: https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BB%D1%8C%D1%84%D0%B0%D1%82_%D0%B6%D0%B5%D0%BB%D0%B5%D0%B7%D0%B0(III)-%D0%B0%D0%BC%D0%BC%D0%BE%D0%BD%D0%B8%D1%8F\n * Fe2(SO4)3 + (NH4)2SO4 + 24H2O \"0^oC\"-> 2NH4Fe(SO4)2*12H2O\"|v\"\n * Здесь коэффициент 2 относится ко всему последнему агенту.\n * Проблема в том, что невозможно указать коэффициент для первого множителя.\n * Пример - формула ржавчины: https://de.wikipedia.org/wiki/Rost\n *  x FeᴵᴵO · y Fe₂ᴵᴵᴵO₃ · z H₂O\n * Таким образом, есть двусмысленность.\n * Что означает первый коэффициент: общий или только для первого множителя?\n * Принято решение, что первый коэффициент действует на весь агент.\n * А если нужно использовать коэффициент только для первого множителя, нужно использовать скобки\n * ('x'Fe(ii)O*'y'Fe(iii)2O3*'z'H2O)\n * Это значит, что внутри скобок может встречаться коэффициент.\n * Такая возможность появляется только начиная с версии 1.2!\n */\n\n// Начало конструкции, умножающей последующее содержимое на указанный коэффициент\n// Кроме того, является мостиком, т.е. образует новую подцепь\n// example: CuSO4*5H2O\n// isFirst для коэффициента, который стоит первым внутри скобок (2FeO*3H2O)\nexport class ChemMul extends ChemObj {\n  // если соседние узлы внутри скобок, то они здесь не заполняются.\n  // Н.р для \"Ca(OH)2*3Mg(OH)2\" после компиляции nodes=[undefined, \"Mg\"]\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  constructor(\n    public readonly n: ChemK,\n    public readonly isFirst: boolean,\n    public readonly color?: string\n  ) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.mul?.(this);\n  }\n}\n\n// Конец множителя.\n// Не участвует в выводе.\n// Предназначен для вычислительных алгоритмов, использующих стек, чтобы выполнить pop\nexport class ChemMulEnd extends ChemObj {\n  constructor(public readonly begin: ChemMul) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.mulEnd?.(this);\n  }\n}\n","import { Int } from \"../types\";\nimport { Point } from \"../math/Point\";\nimport { ChemCharge } from \"./ChemCharge\";\nimport { ChemChargeOwner } from \"./ChemChargeOwner\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemNodeItem } from \"./ChemNodeItem\";\nimport { ChemBond } from \"./ChemBond\";\nimport { Visitor } from \"./Visitor\";\n\n/**\n * Priority table for different items\n * 1 = comment\n * 2 = abstract item\n * 3 = H element\n * 4 = radicals and all elements (except C and H)\n * 5 = C element\n * 6 = item with bCenter flag\n */\nconst enum ItemPriority {\n  NA,\n  Comment,\n  Abstract,\n  Hydrogen,\n  Default,\n  Carbon,\n  Explicit,\n}\n\nexport class ChemNode extends ChemObj implements ChemChargeOwner {\n  constructor(pt?: Point) {\n    super();\n    this.pt = (pt ?? Point.zero).clone();\n  }\n\n  pt: Point;\n\n  charge?: ChemCharge = undefined;\n\n  items: ChemNodeItem[] = [];\n\n  index: Int = -1; // index of node in CAgent.nodes array\n\n  chain: Int = 0; // chain number\n\n  subChain: Int = 0;\n\n  autoMode = false;\n\n  bonds: Set<ChemBond> = new Set();\n\n  fixed = false;\n\n  color?: string;\n\n  atomColor?: string;\n\n  bCenter = false; // Признак центрального узла для центрирования агентов в выражении\n\n  override walk(visitor: Visitor) {\n    visitor.nodePre?.(this);\n    if (visitor.isStop) return;\n    for (const it of this.items) {\n      it.walk(visitor);\n      if (visitor.isStop) return;\n    }\n    visitor.nodePost?.(this);\n  }\n\n  addBond(bond: ChemBond) {\n    this.bonds.add(bond);\n  }\n\n  getCenterItem(): ChemNodeItem | null {\n    let curPriority = ItemPriority.NA;\n    let maxPriority = ItemPriority.NA;\n    let foundItem: ChemNodeItem | null = null;\n    this.walk({\n      itemPre() {\n        curPriority = ItemPriority.NA;\n      },\n      comment() {\n        curPriority = ItemPriority.Comment;\n      },\n      custom() {\n        curPriority = ItemPriority.Abstract;\n      },\n      radical() {\n        curPriority = ItemPriority.Default;\n      },\n      atom(obj) {\n        switch (obj.id) {\n          case \"H\":\n          case \"D\":\n          case \"T\":\n            curPriority = ItemPriority.Hydrogen;\n            break;\n          case \"C\":\n            curPriority = ItemPriority.Carbon;\n            break;\n          default:\n            curPriority = ItemPriority.Default;\n            break;\n        }\n      },\n      itemPost(obj) {\n        if (obj.bCenter) {\n          curPriority = ItemPriority.Explicit;\n        }\n        if (curPriority > maxPriority) {\n          maxPriority = curPriority;\n          foundItem = obj;\n        }\n      },\n    });\n    return foundItem;\n  }\n}\n\nexport type ChemNodeOpt = ChemNode | undefined;\nexport type ChemNodeOptPair = [ChemNodeOpt, ChemNodeOpt];\n","import { Double, Int } from \"../types\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemSubObj } from \"./ChemSubObj\";\nimport { ChemK } from \"./ChemK\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemCharge } from \"./ChemCharge\";\n\nexport interface LewisDot {\n  angle?: number;\n  pos?: number; // [0;7] 0:Lb, 1:Br, 2:Bl, 3:Rb, 4:Rt, 5:Tl, 6:Tr, 7:Lt\n  color?: string;\n  margin?: number;\n}\n\nexport class ChemNodeItem extends ChemObj {\n  constructor(public readonly obj: ChemSubObj, public n: ChemK = ChemK.one) {\n    super();\n  }\n\n  charge?: ChemCharge;\n\n  // Special mass.\n  // If specified, then ignore mass of sub object\n  mass?: Double;\n\n  atomNum?: Int | \"\"; // признак вывода атомного номера (для ядерных реакций).\n\n  color?: string; // общий цвет\n\n  atomColor?: string; // цвет атомов\n\n  bCenter?: boolean; // признак приоритетности элемента, задаваемый при помощи обратного апострофа: H3C`O|\n\n  dots?: LewisDot[];\n  // this.dashes = [];\n\n  override walk(visitor: Visitor) {\n    visitor.itemPre?.(this);\n    if (!visitor.isStop) this.obj.walk(visitor);\n    if (!visitor.isStop) visitor.itemPost?.(this);\n  }\n}\n","/**\n * Base class for all chemical objects\n * Supports information about the position of the object in the source description (usually after the preprocessor)\n * Created by PeterWin on 29.05.2022.\n */\nimport { Visitor } from \"./Visitor\";\n\nexport abstract class ChemObj {\n  abstract walk<T extends Visitor>(visitor: T): void;\n\n  walkExt<T extends Visitor>(visitor: T): T {\n    this.walk(visitor);\n    return visitor;\n  }\n}\n","import { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemComment } from \"./ChemComment\";\n\n// Операция в химическом выражении\n// div - is divide expression by parts. =, -> are dividers. + is not divider\n\nexport class ChemOp extends ChemObj {\n  constructor(\n    public readonly srcText: string,\n    public readonly dstText: string,\n    public readonly div: boolean\n  ) {\n    super();\n  }\n\n  commentPre?: ChemComment;\n\n  commentPost?: ChemComment;\n\n  color?: string;\n\n  override walk(visitor: Visitor) {\n    visitor.operation?.(this);\n  }\n}\n","import { ChemSubObj } from \"./ChemSubObj\";\r\nimport { Visitor } from \"./Visitor\";\r\nimport { ElementId } from \"../types/ElementId\";\r\nimport { Int } from \"../types\";\r\nimport { ElemList } from \"./ElemList\";\r\n\r\nlet radicals: Record<string, ChemRadical> | null = null;\r\n\r\ntype DescrRec = [ElementId, Int];\r\ntype DescrItem = [string[], DescrRec[]];\r\nconst descriptions: DescrItem[] = [\r\n  [\r\n    [\"Me\"],\r\n    [\r\n      [\"C\", 1],\r\n      [\"H\", 3],\r\n    ],\r\n  ],\r\n  [\r\n    [\"Et\"],\r\n    [\r\n      [\"C\", 2],\r\n      [\"H\", 5],\r\n    ],\r\n  ],\r\n  [\r\n    [\"Ph\"],\r\n    [\r\n      [\"C\", 6],\r\n      [\"H\", 5],\r\n    ],\r\n  ],\r\n  [\r\n    [\"Pr\", \"n-Pr\", \"Pr-n\"],\r\n    [\r\n      [\"C\", 3],\r\n      [\"H\", 7],\r\n    ],\r\n  ],\r\n  [\r\n    [\"iPr\", \"i-Pr\", \"Pr-i\"],\r\n    [\r\n      [\"C\", 3],\r\n      [\"H\", 7],\r\n    ],\r\n  ],\r\n  [\r\n    [\"Bu\", \"nBu\", \"n-Bu\", \"Bu-n\"],\r\n    [\r\n      [\"C\", 4],\r\n      [\"H\", 9],\r\n    ],\r\n  ],\r\n  // tert-butyl\r\n  [\r\n    [\"t-Bu\", \"Bu-t\", \"tBu\"],\r\n    [\r\n      [\"C\", 4],\r\n      [\"H\", 9],\r\n    ],\r\n  ],\r\n  [\r\n    [\"i-Bu\", \"Bu-i\", \"iBu\"],\r\n    [\r\n      [\"C\", 4],\r\n      [\"H\", 9],\r\n    ],\r\n  ],\r\n  // sec-butyl\r\n  [\r\n    [\"s-Bu\", \"Bu-s\", \"sBu\"],\r\n    [\r\n      [\"C\", 4],\r\n      [\"H\", 9],\r\n    ],\r\n  ],\r\n  [\r\n    [\"Ac\"],\r\n    [\r\n      [\"C\", 1],\r\n      [\"H\", 3],\r\n      [\"C\", 1],\r\n      [\"O\", 1],\r\n    ],\r\n  ],\r\n  [\r\n    [\"CoA\"],\r\n    [\r\n      [\"C\", 21],\r\n      [\"H\", 35],\r\n      [\"N\", 7],\r\n      [\"O\", 16],\r\n      [\"P\", 3],\r\n    ],\r\n  ], // https://en.wikipedia.org/wiki/Coenzyme_A\r\n  [\r\n    [\"Tf\"],\r\n    [\r\n      [\"C\", 1],\r\n      [\"F\", 3],\r\n      [\"S\", 1],\r\n      [\"O\", 2],\r\n    ],\r\n  ], // TfOH = CF3SO3H, Tf = CF3SO2 https://en.wikipedia.org/wiki/Trifluoromethylsulfonyl\r\n  // MsOH https://en.wikipedia.org/wiki/Methanesulfonic_acid\r\n];\r\n\r\nexport class ChemRadical extends ChemSubObj {\r\n  constructor(public readonly label: string, public readonly items: ElemList) {\r\n    super();\r\n  }\r\n\r\n  override walk(visitor: Visitor) {\r\n    visitor.radical?.(this);\r\n  }\r\n\r\n  static get dict(): Record<string, ChemRadical> {\r\n    if (radicals) return radicals;\r\n    const newDict: Record<string, ChemRadical> = {};\r\n    descriptions.forEach((descr) => {\r\n      const [left, right] = descr;\r\n      const elemList = new ElemList();\r\n      right.forEach(([id, n]) => elemList.addElemById(id, n));\r\n      left.forEach((it) => {\r\n        newDict[it] = new ChemRadical(it, elemList);\r\n      });\r\n    });\r\n    radicals = newDict;\r\n    return newDict;\r\n  }\r\n}\r\n\r\nexport const isShortRadical = (name: string): boolean =>\r\n  /^[A-Z][a-z]+$/.test(name);\r\n","/**\n * Subordinate object for the node element\n * Created by PeterWin on 29.05.2022.\n */\nimport { ChemObj } from \"./ChemObj\";\n\nexport abstract class ChemSubObj extends ChemObj {}\n","/**\n * Elements list\n * Each element is record {id, elem, n}\n * For abstract  elem is null\n * Created by PeterWin on 29.04.2017.\n */\nimport { ElemRecord } from \"./ElemRecord\";\nimport { Double } from \"../types\";\nimport { ElementId, IsotopeId } from \"../types/ElementId\";\nimport { makeChargeText } from \"./makeChargeText\";\nimport { ChemAtom } from \"./ChemAtom\";\nimport { findElement } from \"./PeriodicTable\";\nimport { ChemRadical } from \"./ChemRadical\";\n\nexport class ElemList {\n  readonly list: ElemRecord[] = [];\n\n  charge: Double = 0.0;\n\n  toString() {\n    let result: string = this.list.reduce(\n      (acc, elemRec) => `${acc}${elemRec}`,\n      \"\"\n    );\n    const chargeText = makeChargeText(this.charge);\n    if (chargeText !== \"\") {\n      result += `^${chargeText}`;\n    }\n    return result;\n  }\n\n  findAtom(atom?: ChemAtom): ElemRecord | undefined {\n    return atom ? this.list.find((it) => it.elem === atom) : undefined;\n  }\n\n  // Example: list.findById(\"He\")\n  findById(id: ElementId | IsotopeId): ElemRecord | undefined {\n    return this.findAtom(findElement(id));\n  }\n\n  findCustom(id: string): ElemRecord | undefined {\n    return this.list.find((it) => !it.elem && it.id === id);\n  }\n\n  findKey(key: string): ElemRecord | undefined {\n    return this.list.find((it) => it.key === key);\n  }\n\n  findRec(rec?: ElemRecord): ElemRecord | undefined {\n    if (!rec) return undefined;\n    return rec.elem ? this.findAtom(rec.elem) : this.findCustom(rec.id);\n  }\n\n  private addElemRec(rec: ElemRecord): this {\n    const foundRec = this.findRec(rec);\n    if (!foundRec) {\n      this.list.push(rec);\n    } else {\n      foundRec.n += rec.n;\n    }\n    return this;\n  }\n\n  addElemById(id: string, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(id, n, false));\n  }\n\n  addAtom(atom: ChemAtom, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(atom, n));\n  }\n\n  addElem(elem: ElemRecord, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(elem, n));\n  }\n\n  addCustom(text: string, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(text, n, true));\n  }\n\n  addList(srcList: ElemList): this {\n    srcList.list.forEach((it) => this.addElem(it));\n    this.charge += srcList.charge;\n    return this;\n  }\n\n  addRadical(radical?: ChemRadical): this {\n    return radical ? this.addList(radical.items) : this;\n  }\n\n  scale(k: Double) {\n    if (k !== 1.0) {\n      this.charge *= k;\n      this.list.forEach((it) => {\n        // eslint-disable-next-line no-param-reassign\n        it.n *= k;\n      });\n    }\n  }\n\n  // sort by Hill system\n  sortByHill(): this {\n    this.list.sort((a: ElemRecord, b: ElemRecord): number => {\n      const aid: string = a.id;\n      const bid: string = b.id;\n      if (!a.elem && !b.elem) return aid.localeCompare(bid);\n      if (!a.elem) return 1;\n      if (!b.elem) return -1;\n      if (aid === bid) return 0;\n      if (aid === \"C\") return -1;\n      if (bid === \"C\") return 1;\n      if (aid === \"H\") return -1;\n      if (bid === \"H\") return 1;\n      return aid.localeCompare(bid);\n    });\n    return this;\n  }\n}\n","import { Double } from \"../types\";\nimport { ChemAtom } from \"./ChemAtom\";\nimport { findElement } from \"./PeriodicTable\";\nimport { k2s } from \"./k2s\";\n\nexport class ElemRecord {\n  readonly id: string;\n\n  readonly elem?: ChemAtom;\n\n  n: Double;\n\n  constructor(id: string);\n\n  constructor(id: string, n: Double, isCustom: boolean);\n\n  constructor(atom: ChemAtom);\n\n  constructor(atom: ChemAtom, n: Double);\n\n  constructor(src: ElemRecord);\n\n  constructor(src: ElemRecord, n: Double);\n\n  constructor(\n    a: string | ChemAtom | ElemRecord,\n    n: Double = 1.0,\n    isCustom: boolean = false\n  ) {\n    if (typeof a === \"string\") {\n      this.id = a;\n      this.elem = isCustom ? undefined : findElement(a);\n      this.n = n;\n    } else if (a instanceof ChemAtom) {\n      this.id = a.id;\n      this.elem = a;\n      this.n = n;\n    } else {\n      this.id = a.id;\n      this.elem = a.elem;\n      this.n = n * a.n;\n    }\n  }\n\n  get key(): string {\n    return this.elem ? this.id : `{${this.id}}`;\n  }\n\n  toString() {\n    return `${this.key}${k2s(this.n)}`;\n  }\n}\n","import { ChemAtom } from \"./ChemAtom\";\nimport { Double, Int } from \"../types\";\nimport { ElementId, IsotopeId } from \"../types/ElementId\";\n\ntype ElementMap = Record<ElementId, ChemAtom>;\nlet elementsCache: readonly ChemAtom[] | null = null;\nlet dictCache: ElementMap | null = null;\nlet isotopesCache: readonly ChemAtom[] | null = null;\nlet isotopeDictCache: Record<IsotopeId, ChemAtom> | null = null;\n\nexport const findElement = (id: string): ChemAtom | undefined =>\n  PeriodicTable.dict[id as ElementId] ||\n  PeriodicTable.isotopesDict[id as IsotopeId];\n\nexport const PeriodicTable = Object.freeze({\n  get elements(): readonly ChemAtom[] {\n    if (elementsCache) return elementsCache;\n    const list = Object.freeze(\n      (Object.keys(massMap) as ElementId[]).map(\n        (id, index) =>\n          new ChemAtom(index + 1, id, massMap[id][0], {\n            epsilonMass: massMap[id][1],\n          })\n      )\n    );\n    elementsCache = list;\n    return list;\n  },\n  get dict(): ElementMap {\n    if (dictCache) return dictCache;\n    const map = {} as ElementMap;\n    this.elements.forEach((elem) => {\n      map[elem.id as ElementId] = elem;\n    });\n    const finalMap = Object.freeze(map);\n    dictCache = finalMap;\n    return finalMap;\n  },\n  get isotopes(): readonly ChemAtom[] {\n    if (isotopesCache) return isotopesCache;\n    const list = Object.freeze(\n      isotopesDef.map(\n        ([n, id, mass, stable]) => new ChemAtom(n, id, mass, { stable })\n      )\n    );\n    isotopesCache = list;\n    return list;\n  },\n  get isotopesDict(): Record<IsotopeId, ChemAtom> {\n    if (isotopeDictCache) return isotopeDictCache;\n    const map = {} as Record<IsotopeId, ChemAtom>;\n    this.isotopes.forEach((elem) => {\n      map[elem.id as IsotopeId] = elem;\n    });\n    const finalMap = Object.freeze(map);\n    isotopeDictCache = finalMap;\n    return finalMap;\n  },\n});\n\n// Main source:  Table 1 / Abridged standard atomic weight\n// from https://www.degruyter.com/document/doi/10.1515/pac-2019-0603/html\n// and for Elements without stable isotopes: Table 2 from https://iupac.qmul.ac.uk/AtWt/\nconst massMap: Record<ElementId, [Double, Double] | [Double]> = {\n  H: [1.008, 0.0002],\n  He: [4.0026, 0.0001],\n  Li: [6.94, 0.06],\n  Be: [9.0122, 0.0001],\n  B: [10.81, 0.02],\n  C: [12.011, 0.002],\n  N: [14.007, 0.001],\n  O: [15.999, 0.001],\n  F: [18.998, 0.001],\n  Ne: [20.18, 0.001],\n  Na: [22.99, 0.001],\n  Mg: [24.305, 0.002],\n  Al: [26.982, 0.001],\n  Si: [28.085, 0.001],\n  P: [30.974, 0.001],\n  S: [32.06, 0.02],\n  Cl: [35.45, 0.01],\n  Ar: [39.95, 0.16],\n  K: [39.098, 0.001],\n  Ca: [40.078, 0.004],\n  Sc: [44.956, 0.001],\n  Ti: [47.867, 0.001],\n  V: [50.942, 0.001],\n  Cr: [51.996, 0.001],\n  Mn: [54.938, 0.001],\n  Fe: [55.845, 0.002],\n  Co: [58.933, 0.001],\n  Ni: [58.693, 0.001],\n  Cu: [63.546, 0.003],\n  Zn: [65.38, 0.02],\n  Ga: [69.723, 0.001],\n  Ge: [72.63, 0.008],\n  As: [74.922, 0.001],\n  Se: [78.971, 0.008],\n  Br: [79.904, 0.003],\n  Kr: [83.798, 0.002],\n  Rb: [85.468, 0.001],\n  Sr: [87.62, 0.01],\n  Y: [88.906, 0.001],\n  Zr: [91.224, 0.002],\n  Nb: [92.906, 0.001],\n  Mo: [95.95, 0.01],\n  Tc: [97],\n  Ru: [101.07, 0.02],\n  Rh: [102.91, 0.01],\n  Pd: [106.42, 0.01],\n  Ag: [107.87, 0.01],\n  Cd: [112.41, 0.01],\n  In: [114.82, 0.01],\n  Sn: [118.71, 0.01],\n  Sb: [121.76, 0.01],\n  Te: [127.6, 0.03],\n  I: [126.9, 0.01],\n  Xe: [131.29, 0.01],\n  Cs: [132.91, 0.01],\n  Ba: [137.33, 0.01],\n  La: [138.91, 0.01],\n  Ce: [140.12, 0.01],\n  Pr: [140.91, 0.01],\n  Nd: [144.24, 0.01],\n  Pm: [145],\n  Sm: [150.36, 0.02],\n  Eu: [151.96, 0.01],\n  Gd: [157.25, 0.03],\n  Tb: [158.93, 0.01],\n  Dy: [162.5, 0.01],\n  Ho: [164.93, 0.01],\n  Er: [167.26, 0.01],\n  Tm: [168.93, 0.01],\n  Yb: [173.05, 0.02],\n  Lu: [174.97, 0.01],\n  Hf: [178.49, 0.01],\n  Ta: [180.95, 0.01],\n  W: [183.84, 0.01],\n  Re: [186.21, 0.01],\n  Os: [190.23, 0.03],\n  Ir: [192.22, 0.01],\n  Pt: [195.08, 0.02],\n  Au: [196.97, 0.01],\n  Hg: [200.59, 0.01],\n  Tl: [204.38, 0.01],\n  Pb: [207.2, 1.1],\n  Bi: [208.98, 0.01],\n  Po: [209],\n  At: [210],\n  Rn: [222],\n  Fr: [223],\n  Ra: [226],\n  Ac: [227],\n  Th: [232.04, 0.01],\n  Pa: [231.04, 0.01],\n  U: [238.03, 0.01],\n  Np: [237],\n  Pu: [244],\n  Am: [243],\n  Cm: [247],\n  Bk: [247],\n  Cf: [251],\n  Es: [252],\n  Fm: [257],\n  Md: [258],\n  No: [259],\n  Lr: [262],\n  Rf: [267],\n  Db: [270],\n  Sg: [269],\n  Bh: [270],\n  Hs: [270],\n  Mt: [278],\n  Ds: [281],\n  Rg: [281],\n  Cn: [285],\n  Nh: [286],\n  Fl: [289],\n  Mc: [289],\n  Lv: [293],\n  Ts: [294],\n  Og: [294],\n};\n\nconst isotopesDef: [Int, IsotopeId, Double, boolean][] = [\n  [1, \"D\", 2.014101777844, true],\n  [1, \"T\", 3.01604928132, false],\n];\n","import { cmp } from \"../utils/cmp\";\nimport { getItemForced } from \"../utils/getItemForced\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { Point } from \"../math/Point\";\nimport { ChemAgent } from \"./ChemAgent\";\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemNode } from \"./ChemNode\";\n\nexport interface Cycle {\n  nodes: ChemNode[];\n  bonds: ChemBond[];\n  center?: Point;\n}\n\nexport const getCycleCenter = (cy: Cycle): Point => {\n  if (cy.center) return cy.center;\n  const L = cy.nodes.length;\n  const center =\n    L === 0\n      ? new Point()\n      : cy.nodes\n          .reduce((sum, node) => sum.iadd(node.pt), new Point())\n          .times(1 / L);\n  // eslint-disable-next-line no-param-reassign\n  cy.center = center;\n  return center;\n};\n\nconst vectorSign = (p: Point, q: Point): -1 | 0 | 1 => {\n  const d = p.x * q.y - p.y * q.x;\n  if (d === 0) return 0;\n  return d < 0 ? -1 : 1;\n};\n\n/**\n * @param cycle\n * @param bond\n * @returns -1 for CCW and 1 for CW or 0 if undefined\n */\nexport const calcBondSign = (cycle: Cycle, bond: ChemBond): -1 | 0 | 1 => {\n  const a = bond.nodes[0]?.pt;\n  const b = bond.nodes[1]?.pt;\n  if (!a || !b) return 0;\n  const c = getCycleCenter(cycle);\n  return vectorSign(b.minus(a), c.minus(a));\n};\n\nexport const bondSideSign = (bond: ChemBond, side: 0 | 1): -1 | 0 | 1 => {\n  const node = bond.nodes[side];\n  if (!node || !bond.dir) return 0;\n  const nearBonds = Array.from(node.bonds).filter(\n    (b) => b !== bond && b.isVisible() && b.dir\n  );\n  if (nearBonds.length !== 1) return 0;\n  return vectorSign(bond.dir, nearBonds[0]!.dir!);\n};\n\nexport class StructAnalyzer {\n  isInit: boolean = false;\n\n  cycles: Cycle[] = [];\n\n  bondsMap: Record<number, Cycle[]> = {};\n\n  constructor(public readonly agent: ChemAgent) {}\n\n  analyze() {\n    if (this.isInit) return;\n    this.isInit = true;\n    interface NodeDef {\n      node: ChemNode;\n      order: number;\n    }\n    const { nodes, bonds } = this.agent;\n    if (bonds.length < 3) return;\n    const NA = nodes.length * 2;\n    const nodesMap: NodeDef[] = nodes.map((node) => ({ node, order: NA }));\n\n    const unwindCycle = (start: NodeDef, usedNodes: Set<number>): Cycle => {\n      // Набор usedNodes предотвращает переходы в ответвления. И ограничивает поиск.\n      const queue: NodeDef[] = [start];\n      const cycle: Cycle = { nodes: [], bonds: [] };\n      let lastBond: ChemBond | undefined;\n      const nodesSet = new Set<ChemNode>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        nodesSet.add(curND.node);\n        // eslint-disable-next-line\n        curND.node.bonds.forEach((bond) => {\r\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const i = nextNode.index!;\n            const nextND = nodesMap[i]!;\n            if (usedNodes.has(i)) {\n              if (curND.order + 1 === nextND.order) {\n                queue.push(nextND);\n                cycle.bonds.push(bond);\n              } else if (curND.order === nextND.order) {\n                lastBond = bond;\n              }\n            }\n          }\n        });\n      }\n      if (lastBond) cycle.bonds.push(lastBond);\n      cycle.nodes = Array.from(nodesSet);\n      cycle.nodes.sort((a, b) => cmp(a.index!, b.index!));\n      cycle.bonds.sort((a, b) => cmp(a.index!, b.index!));\n      return cycle;\n    };\n\n    const createCycle = (n1: NodeDef, n2: NodeDef): Cycle | undefined => {\n      if (n2.order > n1.order) throw new Error(\"Invalid order\");\n      // Необходимо выполнить сканирование в обратном порядке, чтобы найти начало цикла\n      // Это гарантировано будет один узел.\n      const queue: NodeDef[] = [n1];\n      // Для циклов с нечетным числом узлов на стыке будет два узла с одинаковым порядком\n      if (n2.order === n1.order) queue.push(n2);\n      const usedNodes = new Set<number>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        const i = curND.node.index!;\n        if (usedNodes.has(i)) {\n          // Найдено начало цикла\n          // Теперь нужно собрать все узлы и связи цикла. И избавиться от боковых ответвлений.\n          return unwindCycle(curND, usedNodes);\n        }\n        usedNodes.add(i);\n        curND.node.bonds.forEach((bond) => {\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const nextND = nodesMap[nextNode.index!]!;\n            if (nextND.order + 1 === curND.order) {\n              queue.push(nextND);\n            }\n          }\n        });\n      }\n      return undefined;\n    };\n\n    const scan = (start: NodeDef) => {\n      if (start.order !== NA) return;\n      // eslint-disable-next-line no-param-reassign\n      start.order = 0;\n      const queue: NodeDef[] = [start];\n      const cyBonds = new Set<number>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        curND.node.bonds.forEach((bond) => {\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const nextND = nodesMap[nextNode.index]!;\n            const nextOrder = nextND.order;\n            if (nextOrder === NA) {\n              // Этот узел еще не вставал в очередь\n              nextND.order = curND.order + 1;\n              queue.push(nextND);\n            } else if (nextOrder >= curND.order) {\n              // Цикл создается если порядок след. узла не меньше, чем порядок предыдущего\n              if (!cyBonds.has(bond.index!)) {\n                // Необходимо предотвратить повторную обработку цикла.\n                // Актуально для циклов с нечетным числом узлов.\n                cyBonds.add(bond.index!);\n                const c = createCycle(nextND, curND);\n                if (c) this.cycles.push(c);\n              }\n            }\n          }\n        });\n      }\n    };\n    // Необходимо пройти по всем узлам, т.к. не гарантируется, что все узлы агента в одной цепи.\n    // Поэтому сканирование не обязательно обходит все узлы.\n    nodesMap.forEach((nodeDef) => scan(nodeDef));\n\n    this.cycles.forEach((cy) => {\n      cy.bonds.forEach((bond) => {\n        const { index } = bond;\n        if (typeof index === \"number\") {\n          const list = getItemForced(this.bondsMap, index, []);\n          list.push(cy);\n        }\n      });\n    });\n  }\n\n  findCyclesForBond(bond: ChemBond): Cycle[] {\n    this.analyze();\n    return ifDef(bond.index, (i) => this.bondsMap[i]) ?? [];\n  }\n\n  calcBondSign(bond: ChemBond): -1 | 0 | 1 {\n    const c0 = this.findCyclesForBond(bond)[0];\n    if (c0) return calcBondSign(c0, bond);\n    const sFwd = bondSideSign(bond, 1);\n    const sBkw = bondSideSign(bond, 0);\n    if ((sFwd === -1 && sBkw !== -1) || (sFwd === 0 && sBkw === 1)) return -1;\n    if ((sFwd === 1 && sBkw !== 1) || (sFwd === 0 && sBkw === -1)) return 1;\n    return 0;\n  }\n}\n","import { ChemObj } from \"./ChemObj\";\nimport { ChemComment } from \"./ChemComment\";\nimport { ChemCustom } from \"./ChemCustom\";\nimport { Visitor } from \"./Visitor\";\n\nexport const isEmptyNode = (node: ChemObj): boolean =>\n  !node.walkExt({\n    isStop: false,\n    atom() {\n      this.isStop = true;\n    },\n    radical() {\n      this.isStop = true;\n    },\n    custom(obj: ChemCustom) {\n      this.isStop = !!obj.text;\n    },\n    comment(obj: ChemComment) {\n      this.isStop = !!obj.text;\n    },\n  } as Visitor).isStop;\n","import { ChemNode } from \"./ChemNode\";\nimport { isEmptyNode } from \"./isEmptyNode\";\n\nexport const isNodeHidden = (node: ChemNode): boolean =>\n  node.autoMode || isEmptyNode(node);\n","import { ChemBracketBegin, getBracketsContent } from \"./ChemBracket\";\nimport { ChemObj } from \"./ChemObj\";\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\n\n/**\n * Если внутри скобок все элементы текстовые,\n * например Ca(OH)2 или даже K3[Fe(CN)6]\n * то для вывода скобок гораздо лучше использовать текущий шрифт.\n * @param begin\n * @param commands\n */\nexport const isTextBrackets = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): boolean =>\n  !getBracketsContent(begin, commands).find((cmd) => !isTextFormula(cmd));\n\nexport const isTextBracketsCached = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): boolean => {\n  if (begin.isText !== undefined) {\n    return begin.isText;\n  }\n  const result = isTextBrackets(begin, commands);\n  // eslint-disable-next-line no-param-reassign\n  begin.isText = result;\n  return result;\n};\n","import { Double } from \"../types\";\nimport { toa } from \"../math\";\n\nexport const k2s = (k: Double): string => (k === 1.0 ? \"\" : toa(k));\n","import { Double } from \"../types\";\nimport { is0, toa } from \"../math\";\n\nexport const makeChargeText = (value: Double): string => {\n  if (is0(value)) {\n    return \"\";\n  }\n  const absCharge = Math.abs(value);\n  let text = absCharge === 1.0 ? \"\" : toa(absCharge);\n  text += value < 0 ? \"-\" : \"+\";\n  return text;\n};\n","/**\n * Свойства для отрисовки графической формулы\n * Могут быть использованы многократно\n * Created by PeterWin on 13.05.2017.\n */\n\nimport { LocalFont, TextStyle } from \"./AbstractSurface\";\nimport { getFontHeight } from \"./utils/fontFaceProps\";\nimport { ChemStyleId } from \"./ChemStyleId\";\n\nexport interface TextProps {\n  font: LocalFont;\n  style: TextStyle;\n}\n\nexport class ChemImgProps {\n  stdStyle: TextProps;\n\n  styles: Partial<Record<ChemStyleId, TextProps | undefined>> = {};\n\n  line: number; // Длина 2D-химической связи (от центра до центра)\n\n  horizLine: number; // Длина 1D-химической связи (от края до края)\n\n  lineWidth: number; // Толщина обычной линии. Если 0, значит минимальная толщина (обычно 1px).\n\n  thickWidth = 0; // Толщина толстой линии\n\n  chiralWidth = 0; // Макс. толщина хиральной связи w/d\n\n  lineSpace2 = 0; // Отступ между двойными линиями (между краями ##..##)\n\n  lineSpace2x = 0; // Для пересекающейся двойной связи\n\n  lineSpace3 = 0; // Отсуп между тройными линиями\n\n  subKY = 0.5; // Разница между низом подстрочного символа и низом объекта В долях xHeight подстрочного символа!\n\n  bracketSubKY = 0.7; // Аналогично subKY, но для скобок\n\n  supKY = 0.5; // Разница между верхом надстрочного символа и верхом объекта В долях xHeight символа!\n\n  bracketSupKY = 0.7; // Аналогично supKY, но для скобок\n\n  hatch = 0; // абсолютное расстояние между штрихами в изображении связи типа /d (z<0) -- see getHatch()\n\n  dash = 0; // Длина штриха линии типа S:\n\n  arrowL = 0; // длина стрелки\n\n  arrowD = 0; // ширина половинки стрелки\n\n  opSpace = 0; // Расстояние по оси X между агентом и операцией: H2 + O2\n\n  agentKSpace = 0; // гориз отступ коэффициента агента\n\n  mulChar = \"\\u00b7\";\n\n  mulRadius = 0.1; // Радиус операции * для аддуктов относительно высоты шрифта для стиля \"multiplier\". Если 0, то используется mulChar\n\n  kw = 40; // Коэффициент для вычисления lineWidth = ceil(line/kw)\n\n  flDblAlign = true; // Смещение двойной связи к центру, если возможно.\n\n  nodeMargin = -1; // Отступ химической связи для узла с текстом\n\n  bracketWidth = 0; // Ширина скобки\n\n  bracketSpace = 0; // Шаг между соседними скобками )( или ][ или )[\n\n  useTextBrackets: boolean = true;\n\n  electronDotD = 0; // Диаметр точки для структур Льюиса\n\n  constructor(\n    stdStyle: TextProps,\n    line: number = 0,\n    hline: number = 0,\n    width: number = 0\n  ) {\n    this.stdStyle = stdStyle;\n    if (!this.stdStyle.style.fill) this.stdStyle.style.fill = \"black\";\n    this.line = line;\n    this.horizLine = hline;\n    this.lineWidth = width;\n  }\n\n  // Функция вызывается после заполнения части свойств для автоматического заполнения остальных свойств\n  init() {\n    // Длина связи вычисляется из высоты стандартного шрифта\n    const me = this;\n    me.line = me.line || getFontHeight(me.stdStyle.font.getFontFace()) * 1.6;\n    const { line } = me;\n\n    // Ширина линии определяется по длине связи с использованием коэффициента\n    me.lineWidth = me.lineWidth || Math.ceil(line / me.kw);\n    const { lineWidth } = me;\n\n    // Длина мягкой связи (по оси Х) вычисляется из ширины знака + (потому что минус может быть слишком короткий)\n    me.horizLine = me.horizLine || me.stdStyle.font.getTextWidth(\"+\");\n\n    me.thickWidth = me.thickWidth || lineWidth * 4;\n    me.chiralWidth = me.chiralWidth || lineWidth * 5;\n    me.hatch = me.hatch || lineWidth * 2;\n    me.dash = me.dash || lineWidth * 3;\n    me.lineSpace2 = me.lineSpace2 || lineWidth * 2;\n    me.lineSpace2x = me.lineSpace2x || lineWidth * 3;\n    me.lineSpace3 = me.lineSpace3 || lineWidth * 2;\n    me.arrowL = me.arrowL || line / 5;\n    me.arrowD = me.arrowD || line / 9;\n    me.opSpace = me.opSpace || line / 4;\n    me.agentKSpace = me.agentKSpace || lineWidth * 2;\n\n    me.bracketWidth = me.bracketWidth || lineWidth * 4;\n    me.bracketSpace = me.bracketSpace || lineWidth * 2;\n    me.electronDotD = me.electronDotD || lineWidth * 3;\n\n    if (me.nodeMargin < 0) me.nodeMargin = me.lineWidth || 1;\n  }\n\n  getStyle(styleName: ChemStyleId): TextProps {\n    return this.styles[styleName] || this.stdStyle;\n  }\n\n  getStyleColored(styleName: ChemStyleId, color?: string): TextProps {\n    const style = this.getStyle(styleName);\n    if (!color || style.style.fill === color) {\n      return style;\n    }\n    return {\n      ...style,\n      style: { ...style.style, fill: color },\n    };\n  }\n\n  // Стили, требующие уменьшения.\n  static getIndexStyles(): ChemStyleId[] {\n    return [\n      \"atomNumber\",\n      \"bracketCharge\",\n      \"bracketCount\",\n      \"itemCount\",\n      \"itemMass\",\n      \"nodeCharge\",\n      \"oxidationState\",\n    ];\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { CommonFontFace } from \"../CommonFontFace\";\nimport { WebFontProps } from \"./WebFontProps\";\n\nexport class HtmlCanvasLocalFont implements LocalFont {\n  private context: CanvasRenderingContext2D;\n\n  private props: WebFontProps;\n\n  constructor(context: CanvasRenderingContext2D, props: WebFontProps) {\n    this.context = context;\n    this.props = props;\n  }\n\n  getFontFace(): CommonFontFace {\n    return this.props.fontFace;\n  }\n\n  getTextWidth(textLine: string): number {\n    this.context.font = this.props.canvasFont;\n    const m = this.context.measureText(textLine);\n    return m.width;\n  }\n\n  drawLine(\n    surface: AbstractSurface,\n    org: Point,\n    textLine: string,\n    style: TextStyle\n  ) {\n    this.context.font = this.props.canvasFont;\n    this.context.fillStyle = style.fill;\n    this.context.fillText(textLine, org.x, org.y);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport {\n  AbstractSurface,\n  LocalFont,\n  LocalFontProps,\n  PathStyle,\n} from \"../AbstractSurface\";\nimport { PathSeg, PathVisitor } from \"../path\";\nimport { tracePath } from \"../utils/tracePath\";\nimport { WebFontCache } from \"./WebFontCache\";\nimport { HtmlCanvasLocalFont } from \"./HtmlCanvasLocalFont\";\nimport { Matrix2x3 } from \"../../math/Matrix2x3\";\n\nexport class HtmlCanvasSurface implements AbstractSurface {\n  private domElement: HTMLCanvasElement;\n\n  private size: Point;\n\n  private htmlContext: CanvasRenderingContext2D;\n\n  private fontPropsCache: WebFontCache;\n\n  private fontCache: Record<string, LocalFont> = {};\n\n  getCanvas() {\n    return this.domElement;\n  }\n\n  getCtx() {\n    return this.htmlContext;\n  }\n\n  constructor(domElement: HTMLCanvasElement, fontPropsCache?: WebFontCache) {\n    this.domElement = domElement;\n    const ctx = domElement.getContext(\"2d\");\n    if (!ctx) throw Error(\"2d context is not supported\");\n    this.htmlContext = ctx;\n    this.size = new Point();\n    this.fontPropsCache = fontPropsCache ?? new WebFontCache();\n  }\n\n  getFont(props: LocalFontProps): LocalFont {\n    const webProps = this.fontPropsCache.getWebProps(props);\n    let font = this.fontCache[webProps.hash];\n    if (font) return font;\n    font = new HtmlCanvasLocalFont(this.getCtx(), webProps);\n    this.fontCache[webProps.hash] = font;\n    return font;\n  }\n\n  applyStyle(style: PathStyle, org?: Point | Matrix2x3) {\n    const { htmlContext } = this;\n    if (org) {\n      if (org instanceof Point) {\n        htmlContext.translate(org.x, org.y);\n      } else if (org instanceof Matrix2x3) {\n        const { a, b, c, d, e, f } = org;\n        htmlContext.transform(a, b, c, d, e, f);\n      }\n    }\n    htmlContext.beginPath();\n    htmlContext.fillStyle = style.fill ?? \"transparent\";\n    htmlContext.strokeStyle = style.stroke ?? \"transparent\";\n    htmlContext.lineWidth = style.strokeWidth ?? 1;\n  }\n\n  drawPath(\n    org: Point | Matrix2x3,\n    segments: PathSeg[],\n    style: PathStyle\n  ): void {\n    const { htmlContext } = this;\n    htmlContext.save();\n    this.applyStyle(style, org);\n\n    const visitor: PathVisitor = {\n      onM(p: Point) {\n        htmlContext.moveTo(p.x, p.y);\n      },\n      onL(p: Point) {\n        htmlContext.lineTo(p.x, p.y);\n      },\n      onQ(cp: Point, p: Point) {\n        htmlContext.quadraticCurveTo(cp.x, cp.y, p.x, p.y);\n      },\n      onC(cp1: Point, cp2: Point, p: Point) {\n        htmlContext.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p.x, p.y);\n      },\n      onA(r, xRot, largeArc, sweep, pt) {\n        // Точного соответствия нет. Нужно комбинировать arcTo и трансформации\n        htmlContext.lineTo(pt.x, pt.y);\n      },\n    };\n    tracePath(segments, visitor);\n    if (style.fill) htmlContext.fill();\n    if (style.stroke) htmlContext.stroke();\n    htmlContext.restore();\n  }\n\n  drawEllipse(\n    offset: Point,\n    center: Point,\n    radius: Point,\n    style: PathStyle\n  ): void {\n    const { htmlContext } = this;\n    htmlContext.save();\n    this.applyStyle(style, offset);\n    htmlContext.ellipse(\n      center.x,\n      center.y,\n      radius.x,\n      radius.y,\n      0,\n      0,\n      2 * Math.PI\n    );\n    if (style.fill) htmlContext.fill();\n    if (style.stroke) htmlContext.stroke();\n    htmlContext.restore();\n  }\n\n  setSize(size: Point) {\n    this.size = size;\n    this.domElement.width = size.x;\n    this.domElement.height = size.y;\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { CommonFontFace } from \"../CommonFontFace\";\nimport { WebFontProps } from \"./WebFontProps\";\nimport { SvgWebSurface } from \"./SvgWebSurface\";\nimport { drawTag } from \"../../utils/xml/drawTag\";\nimport { escapeXml } from \"../../utils/xml/escapeXml\";\nimport { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { toa } from \"../../math\";\nimport { scaleFontFace } from \"../utils/scaleFontFace\";\nimport { makeCanvasFontProp } from \"./browserUtils/makeWebFontProps\";\n\nexport class SvgWebLocalFont implements LocalFont {\n  private canvas: HTMLCanvasElement;\n\n  constructor(private webFontProps: WebFontProps) {\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  createScaled(scale: number): LocalFont {\n    const newProps = { ...this.webFontProps };\n    newProps.cssHeight *= scale;\n    newProps.fontFace = scaleFontFace(newProps.fontFace, scale);\n    newProps.canvasFont = makeCanvasFontProp(newProps);\n    return new SvgWebLocalFont(newProps);\n  }\n\n  getFontFace(): CommonFontFace {\n    return this.webFontProps.fontFace;\n  }\n\n  getTextWidth(textLine: string): number {\n    const ctx = this.canvas.getContext(\"2d\");\n    if (!ctx) throw Error(\"Canvas don't supported\");\n    ctx.font = this.webFontProps.canvasFont;\n    return ctx.measureText(textLine).width;\n  }\n\n  drawLine(\n    surface: AbstractSurface,\n    org: Point,\n    textLine: string,\n    style: TextStyle\n  ): void {\n    if (surface instanceof SvgWebSurface) {\n      const { fontFace, cssHeight, bold, italic } = this.webFontProps;\n      const attrs: XmlAttrs = {\n        x: toa(org.x),\n        y: toa(org.y),\n        fill: style.fill,\n        \"font-family\": fontFace.fontFamily,\n        \"font-size\": `${cssHeight}px`,\n      };\n      if (bold) attrs[\"font-weight\"] = \"bold\";\n      if (italic) attrs[\"font-style\"] = \"italic\";\n      const code = `${drawTag(\"text\", attrs)}${escapeXml(textLine)}</text>`;\n      surface.addFigure(code);\n    } else {\n      throw new Error(\"Expected SvgWebSurface\");\n    }\n  }\n}\n","import { LocalFontProps, LocalFont } from \"../AbstractSurface\";\nimport { SvgSurface } from \"../svg/SvgSurface\";\nimport { WebFontCache } from \"./WebFontCache\";\nimport { SvgWebLocalFont } from \"./SvgWebLocalFont\";\n\nexport class SvgWebSurface extends SvgSurface {\n  private fontPropsCache: WebFontCache;\n\n  private fontCache: Record<string, LocalFont> = {};\n\n  constructor(fontPropsCache?: WebFontCache) {\n    super();\n    this.fontPropsCache = fontPropsCache ?? new WebFontCache();\n  }\n\n  getFont(props: LocalFontProps): LocalFont {\n    const webProps = this.fontPropsCache.getWebProps(props);\n    const font = this.fontCache[webProps.hash];\n    if (font) return font;\n    const svgLocFont = new SvgWebLocalFont(webProps);\n    this.fontCache[webProps.hash] = svgLocFont;\n    return svgLocFont;\n  }\n}\n","import { LocalFontProps } from \"../AbstractSurface\";\nimport { WebFontProps } from \"./WebFontProps\";\nimport { createLocalFontHash } from \"../utils/createLocalFontHash\";\nimport { makeWebFontProps } from \"./browserUtils/makeWebFontProps\";\n\nexport class WebFontCache {\n  private cache: Record<string, WebFontProps> = {};\n\n  getWebProps(props: LocalFontProps): WebFontProps {\n    const hash = createLocalFontHash(props);\n    let webProps = this.cache[hash];\n    if (webProps) {\n      return webProps;\n    }\n    webProps = makeWebFontProps(props);\n    this.cache[hash] = webProps;\n    return webProps;\n  }\n}\n","import { FontWeight } from \"../../FontTypes\";\nimport { LocalFontProps } from \"../../AbstractSurface\";\nimport { BBoxIndex, FontFaceBBox } from \"../../CommonFontFace\";\nimport { webFontWeight } from \"./webFontWeight\";\nimport { isBold } from \"../../utils/fontWeightValue\";\nimport { traceBox } from \"./traceBox\";\nimport { WebFontProps } from \"../WebFontProps\";\nimport { createLocalFontHash } from \"../../utils/createLocalFontHash\";\n\nexport const makeCanvasFontProp = (props: {\n  fontFamily: string;\n  cssHeight: number;\n  italic: boolean;\n  bold: boolean;\n}): string => {\n  const { fontFamily, cssHeight, bold, italic } = props;\n  const fontStyleChunks = [`${cssHeight}px`, fontFamily];\n  if (bold) fontStyleChunks.unshift(\"bold\");\n  if (italic) fontStyleChunks.unshift(\"italic\");\n  return fontStyleChunks.join(\" \");\n};\n\n/**\n * For browser only\n * @param props\n * @returns\n */\nexport const makeWebFontProps = (props: LocalFontProps): WebFontProps => {\n  const fontFamily = props.family;\n  const fontWeight: FontWeight = webFontWeight(props.weight);\n  const italic: boolean = props.style === \"italic\" || props.style === \"oblique\";\n  const cssHeight = Math.round(props.height);\n  const vOffset = Math.round(cssHeight / 2);\n  const testHeight = cssHeight + 2 * vOffset;\n  const testWidth = Math.round(cssHeight / 2);\n  const baseline = vOffset + cssHeight;\n\n  const bold = isBold(fontWeight);\n  const canvasFont = makeCanvasFontProp({\n    fontFamily,\n    cssHeight,\n    bold,\n    italic,\n  });\n\n  // This code can throw exception, if run in Node or old browser.\n  const canvas = document.createElement(\"canvas\");\n  canvas.height = testHeight;\n  canvas.width = testWidth;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) throw Error(\"Canvas is not supported\");\n  ctx.fillStyle = \"#FFF\";\n  ctx.textBaseline = \"alphabetic\";\n  ctx.font = canvasFont;\n  const m = ctx.measureText(\"[lj\");\n  const mZ = ctx.measureText(\"Z\");\n  const mz = ctx.measureText(\"z\");\n\n  const trace = (letter: string, toBottom: boolean): number => {\n    ctx.clearRect(0, 0, testWidth, testHeight);\n    ctx.fillText(letter, 0, baseline);\n    const info = ctx.getImageData(0, 0, testWidth, testHeight);\n    if (!info) throw Error(\"Cant access to image data\");\n    const best = traceBox(info.data, testWidth, testHeight, toBottom);\n    return best || (toBottom ? 0 : testHeight - 1);\n  };\n  const xHeight = mZ.actualBoundingBoxAscent ?? baseline - trace(\"Z\", true);\n  const capHeight = mz.actualBoundingBoxAscent ?? baseline - trace(\"z\", true);\n  const ascent = m.actualBoundingBoxAscent ?? baseline - trace(\"l\", true);\n  const descent = m.actualBoundingBoxDescent\n    ? -m.actualBoundingBoxDescent\n    : baseline - trace(\"j\", false);\n  const bbox: FontFaceBBox = [0, 0, 0, 0];\n  bbox[BBoxIndex.bottom] = m.fontBoundingBoxDescent\n    ? -m.fontBoundingBoxDescent\n    : descent;\n  bbox[BBoxIndex.top] = m.fontBoundingBoxAscent ?? Math.max(xHeight, ascent);\n\n  canvas.remove();\n\n  return {\n    hash: createLocalFontHash(props),\n    fontFace: {\n      fontFamily,\n      fontWeight,\n      fontStyle: italic ? \"italic\" : \"normal\",\n      xHeight,\n      capHeight,\n      descent,\n      ascent,\n      bbox,\n    },\n    canvasFont,\n    fontFamily,\n    cssHeight,\n    italic,\n    bold,\n  };\n};\n","type Int = number;\nexport const traceBox = (\n  pixels: Uint8ClampedArray,\n  width: Int,\n  height: Int,\n  toBottom: boolean\n) => {\n  const [start, finish, step] = toBottom\n    ? [0, height, 1]\n    : [height - 1, -1, -1];\n  let best: Int | null = null;\n  for (let x = 0; x < width; x++) {\n    for (let y = start; y !== finish; y += step) {\n      const offset = (y * width + x) * 4 + 3;\n      if (pixels[offset]! > 128) {\n        if (best !== null) {\n          if (toBottom) {\n            if (y > best) return best;\n          } else if (y < best) return best;\n        }\n        best = y;\n        break;\n      }\n    }\n  }\n  return best;\n};\n","import { FontWeight } from \"../../FontTypes\";\nimport { fontWeightValue } from \"../../utils/fontWeightValue\";\n\nexport const webFontWeight = (weight?: string): FontWeight => {\n  if (!weight || weight === \"all\") {\n    return \"normal\";\n  }\n  const first: string = weight.split(\",\")[0]!.trim();\n  if (first === \"normal\" || first === \"bold\") {\n    return first;\n  }\n  return String(fontWeightValue(first as FontWeight)) as FontWeight;\n};\n","import { ChemImgProps, TextProps } from \"../ChemImgProps\";\nimport { rulesHtml } from \"../../textRules/rulesHtml\";\nimport { createRulesList } from \"../utils/createRulesList\";\nimport { AbstractSurface, LocalFontProps } from \"../AbstractSurface\";\nimport { FontStretch, FontStyle, FontWeight } from \"../FontTypes\";\nimport { ChemStyleId } from \"../ChemStyleId\";\n\nlet rulesList: [ChemStyleId, string][] | undefined;\n\nconst doc = typeof window === \"undefined\" ? undefined : window.document;\n\ntype FnComputedStyle = (element: Element) => CSSStyleDeclaration;\nconst findComputedStyle: FnComputedStyle =\n  doc?.defaultView?.getComputedStyle ||\n  // @ts-ignore\n  ((element: Element) => element.currentStyle);\n\nexport const createBrowserChemImgProps = (\n  owner: Element,\n  surface: AbstractSurface\n): ChemImgProps => {\n  // Система доступа к откомпилированным свойствам DOM-объектов. Используется отрисовщиком\n  const span = document.createElement(\"span\");\n  const createStyle = (htmlCode: string): TextProps | undefined => {\n    span.innerHTML = htmlCode;\n    const elem = htmlCode[0] === \"<\" ? span.firstChild : span;\n    if (!(elem instanceof Element)) return undefined;\n    const cssStyle = findComputedStyle(elem);\n    if (!cssStyle) return undefined;\n    const fontProps: LocalFontProps = {\n      family: cssStyle.fontFamily,\n      height: +cssStyle.fontSize.slice(0, -2),\n      weight: cssStyle.fontWeight as FontWeight,\n      style: cssStyle.fontStyle as FontStyle,\n      stretch: cssStyle.fontStretch as FontStretch,\n    };\n    return {\n      font: surface.getFont(fontProps),\n      style: { fill: cssStyle.color },\n    };\n  };\n  try {\n    owner.appendChild(span);\n    const stdStyle = createStyle(\"A\");\n    if (!stdStyle) throw Error(\"Can't access to CSS properties\");\n    const props = new ChemImgProps(stdStyle);\n    rulesList = rulesList || createRulesList(rulesHtml);\n    rulesList.forEach(([name, code]) => {\n      const curStyle = createStyle(code);\n      if (curStyle) props.styles[name] = curStyle;\n    });\n    props.init();\n    return props;\n  } finally {\n    span.remove();\n  }\n};\n","import { Rect, updateRect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg, PathSegPt } from \"../path\";\nimport { Figure } from \"./Figure\";\n\nexport class FigBSpline extends Figure {\n  // Создать фигуру B-сплайна.\n  // Список точек должен иметь три фиктивные точки, которые не выдны при выводе.\n  // Одна в начала, две в конце. Для их вычисления можно использовать FigBSpline.extendsPoints\n  // фиктивные точки: points[0], points[n-1], points[n-2]\n  constructor(\n    public readonly points: Point[],\n    public readonly style: PathStyle,\n    public readonly segmentLength: number,\n    public readonly bDashed: boolean\n  ) {\n    super();\n  }\n\n  update(): void {\n    this.bounds =\n      this.points\n        .slice(1, -2)\n        .reduce(\n          (rect: Rect | undefined, p: Point) => updateRect(p, rect),\n          undefined\n        ) ?? new Rect();\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    const segs: PathSeg[] = [];\n    const { points } = this;\n    const n = points.length;\n    const L = n - 3;\n    if (L < 1) return;\n    const bCycled = points[1]!.equals(points[L]!); // Сплайн циклический, если совпадают крайние видимые точки\n\n    // Вычислить длину каждой видимой грани и их сумму\n    let sumLen = 0;\n    const edgesLen = [0]; // длины видимых кусков\n    for (let i = 1; i < L; i++) {\n      const len = points[i]!.dist(points[i + 1]!);\n      sumLen += len;\n      edgesLen[i] = len;\n    }\n    let nSegs = Math.floor(sumLen / this.segmentLength + 0.5); // Количество сегментов\n    if (this.bDashed) {\n      // Для прерывистой линии нужно скорректировать количество сегментов\n      // число сегментов должно быть нечётным для разомкнутой кривой и чётной для зацикленной\n      // eslint-disable-next-line no-bitwise\n      if (nSegs & 1) {\n        // нечётное число сегментов не годится для цикла\n        if (bCycled) nSegs++;\n      } else if (!bCycled) {\n        // Чётное число не годится для разомкнутой кривой\n        nSegs++;\n      }\n    }\n    // скорректировать длину сегмента\n    const segmentLength = sumLen / nSegs;\n    // Теперь движемся одновременно по сегментам и по граням\n    let i = 0;\n    let len = 0;\n    let curEdge = 0;\n    let newEdge = 1;\n    let a3 = Point.zero;\n    let a2 = Point.zero;\n    let a1 = Point.zero;\n    let a0 = Point.zero;\n    let edgeK = 0;\n    for (; ; i++) {\n      if (newEdge !== curEdge) {\n        if (newEdge >= L) break;\n        // Переход на новое ребро. Пересчёт коэффициентов\n        curEdge = newEdge;\n        edgeK = 1 / edgesLen[curEdge]!;\n\n        a3 = points[curEdge]!.times(3);\n        a3.isub(points[curEdge - 1]!);\n        a3.iadd(points[curEdge + 1]!.times(-3));\n        a3.iadd(points[curEdge + 2]!);\n        a3.scale(1 / 6);\n\n        a2 = points[curEdge]!.times(-2);\n        a2.iadd(points[curEdge - 1]!)\n          .iadd(points[curEdge + 1]!)\n          .scale(0.5);\n\n        a1 = points[curEdge + 1]!.minus(points[curEdge - 1]!).scale(0.5);\n\n        a0 = points[curEdge]!.times(4);\n        a0.iadd(points[curEdge - 1]!)\n          .iadd(points[curEdge + 1]!)\n          .scale(1 / 6);\n      }\n      const t = len * edgeK;\n      const pt = a3.times(t).iadd(a2).scale(t).iadd(a1).scale(t).iadd(a0);\n      // eslint-disable-next-line no-bitwise\n      segs.push({ cmd: (this.bDashed && i & 1) || i === 0 ? \"M\" : \"L\", pt });\n\n      len += segmentLength;\n      // вохможно, переход на новое ребро\n      while (len >= edgesLen[newEdge]!) {\n        len -= edgesLen[newEdge]!;\n        newEdge++;\n      }\n    }\n    if (bCycled) {\n      segs.push(\n        !this.bDashed\n          ? { cmd: \"Z\" }\n          : { cmd: \"L\", pt: (segs[0] as PathSegPt).pt }\n      );\n    } else {\n      segs.push({ cmd: \"L\", pt: points[newEdge]! }); // Последний сегмент\n    }\n    surface.drawPath(offset.plus(this.org), segs, this.style);\n  }\n\n  /**\n   * Добавить фиктивные (не рисуемые) точки.\n   * режиме цикла:\n   *  - проверяется совпадение первой и последней точки. Если не совпадают, то добавляется.\n   *  - для фиктивных точек тоже используются существующие точки\n   * Для незамкнутого сплайна фиктивные точки строятся на продолжении крайних сегментов\n   * @param srcPoints\n   * @param bCyclic\n   */\n  static extendsPoints(\n    srcPoints: Point[],\n    bCyclic: boolean\n  ): Point[] | undefined {\n    const n = srcPoints.length;\n    if (n < 3) return undefined;\n    const first = srcPoints[0]!;\n    const second = srcPoints[1]!;\n    const last = srcPoints[n - 1]!;\n    const preLast = srcPoints[n - 2]!;\n    if (bCyclic) {\n      const dstPoints = [...srcPoints];\n      let newLast = last;\n      if (first.equals(last)) {\n        // Последовательность уже замкнута. Конечная точка отступает назад\n        newLast = preLast;\n      } else {\n        // // Добавляем в конец точку (используемую при выводе), совпадающую с первой\n        dstPoints.push(first);\n      }\n      // Добавить три фиктивные точки: две назад, одна вперёд\n      dstPoints.push(second);\n      dstPoints.push(srcPoints[2]!);\n      dstPoints.unshift(newLast);\n      return dstPoints;\n    }\n    const firstStep = second.minus(first);\n    const lastStep = last.minus(preLast);\n    const e = last.plus(lastStep);\n    return [first.minus(firstStep), ...srcPoints, e, e.plus(lastStep)];\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\n\nexport class FigEllipse extends Figure {\n  constructor(\n    center: Point,\n    public readonly radius: Point,\n    public readonly style: PathStyle\n  ) {\n    super();\n    this.org = center;\n    this.bounds = new Rect(radius.neg(), radius);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    surface.drawEllipse(offset, this.org, this.radius, this.style);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\n\nexport class FigFrame extends Figure {\n  figures: Figure[] = [];\n\n  label?: string;\n\n  addFigure(fig: Figure, update?: boolean) {\n    this.figures.push(fig);\n    if (update) this.updateFigure(fig);\n  }\n\n  insertFigure(pos: number, fig: Figure, update?: boolean) {\n    this.figures.splice(pos, 0, fig);\n    if (update) this.updateFigure(fig);\n  }\n\n  updateFigure(fig: Figure) {\n    this.bounds.unite(fig.getRelativeBounds());\n  }\n\n  update(): void {\n    this.bounds =\n      this.figures.reduce((acc: Rect | undefined, fig: Figure) => {\n        const figBounds = fig.getRelativeBounds();\n        if (!acc) {\n          return figBounds;\n        }\n        acc.unite(figBounds);\n        return acc;\n      }, undefined) ?? new Rect();\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    const org = offset.plus(this.org);\n    this.figures.forEach((fig) => fig.draw(org, surface));\n  }\n}\n","import { is0 } from \"../../math\";\nimport { Rect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\nimport { Figure } from \"./Figure\";\n\n/**\n *      b\n *    ######  bWidth\n *\n *     ####\n *\n *      ##  aWidth\n *      a\n * Отдельная фигура позволит менять алгоритм вывода, в зависимости от поверхности.\n * Т.к. в старых реализациях не удалось обеспечить качественное изображение при малых размерах.\n */\n\nexport class FigHashTrapezoid extends Figure {\n  constructor(\n    public readonly a: Point,\n    public readonly aWidth: number,\n    public readonly b: Point,\n    public readonly bWidth: number,\n    public readonly color: string,\n    public readonly lineWidth: number,\n    public readonly hatch: number\n  ) {\n    super();\n  }\n\n  update(): void {\n    const { a, aWidth, b, bWidth } = this;\n    const { dL, dR } = calcTrapezoidDir(a, b);\n    const { aL, aR, bL, bR } = calcTrapezoidPoints(\n      a,\n      aWidth,\n      b,\n      bWidth,\n      dL,\n      dR\n    );\n    this.bounds = new Rect(aL, aR);\n    this.bounds.updatePoint(bL);\n    this.bounds.updatePoint(bR);\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    // Пока еще нет специальных функций поверхности для вывода полосатого треугольника\n    const { a, b, aWidth, bWidth, color, lineWidth, hatch } = this;\n    const { segs, style } = makeHashTrapezoidPath(\n      a,\n      aWidth,\n      b,\n      bWidth,\n      lineWidth,\n      hatch,\n      color\n    );\n    if (segs.length > 0) {\n      surface.drawPath(this.org.plus(offset), segs, style);\n    }\n  }\n}\n\ninterface TrapezoidDir {\n  dir: Point; // vector from a to b\n  dirLen: number; // length\n  dir1: Point; // unit vector from a to b\n  dL: Point; // unit vector from a to left\n  dR: Point; // unit vector from a to right\n}\n\nconst calcTrapezoidDir = (a: Point, b: Point): TrapezoidDir => {\n  const dir = b.minus(a);\n  const dirLen = dir.length();\n  const dir1 = is0(dirLen) ? Point.zero : dir.times(1 / dirLen);\n  const dL = dir1.transpon(true);\n  const dR = dir1.transpon();\n  return { dir, dirLen, dir1, dL, dR };\n};\n\nconst calcTrapezoidPoints = (\n  a: Point,\n  aWidth: number,\n  b: Point,\n  bWidth: number,\n  dL: Point,\n  dR: Point\n) => {\n  const aw2 = aWidth / 2;\n  const bw2 = bWidth / 2;\n  return {\n    aL: a.plus(dL.times(aw2)),\n    aR: a.plus(dR.times(aw2)),\n    bL: b.plus(dL.times(bw2)),\n    bR: b.plus(dR.times(bw2)),\n  };\n};\n\nexport const makeHashTrapezoidPath = (\n  src: Point,\n  srcWidth: number,\n  dst: Point,\n  dstWidth: number,\n  lineWidth: number,\n  hatch: number,\n  color: string\n) => {\n  // Алгоритм, дающий качественное изображение на больших размерах. Использует заливку.\n  // Нужно разделить ось на нечетное количество равных отрезков.\n  // Ширина полоски равна расстоянию между полосками и не меньше lineWidth\n  // Полоски создаются закрашенными трапециями.\n  const segs: PathSeg[] = [];\n  const style: PathStyle = { fill: color };\n\n  const maxW = dstWidth / 2;\n  const minW = srcWidth / 2;\n  const dW = maxW - minW;\n  const { dir, dir1, dirLen, dL, dR } = calcTrapezoidDir(src, dst);\n  if (dirLen >= lineWidth) {\n    const hatchLen = dirLen - lineWidth;\n    const desiredStep = lineWidth + hatch;\n    const stripCount = Math.floor(hatchLen / desiredStep);\n    const dStep = dir1.times(lineWidth);\n    for (let i = 0; i <= stripCount; i++) {\n      const t1 = i / stripCount;\n      const p0 = src.plus(dir.times(t1));\n      const p1 = p0.plus(dStep);\n      const w1 = minW + (i * dW) / stripCount;\n      const w2 = minW + ((i + 1) * dW) / stripCount;\n      const p0L = p0.plus(dL.times(w1));\n      const p0R = p0.plus(dR.times(w1));\n      const p1L = p1.plus(dL.times(w2));\n      const p1R = p1.plus(dR.times(w2));\n      segs.push({ cmd: \"M\", pt: p0L });\n      segs.push({ cmd: \"L\", pt: p1L });\n      segs.push({ cmd: \"L\", pt: p1R });\n      segs.push({ cmd: \"L\", pt: p0R });\n    }\n  }\n  return { segs, style };\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { Point } from \"../../math/Point\";\nimport { Rect, updateRect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\nimport { tracePath } from \"../utils/tracePath\";\nimport { Figure } from \"./Figure\";\n\nexport class FigPath extends Figure {\n  constructor(public segs: PathSeg[], public style: PathStyle) {\n    super();\n  }\n\n  update() {\n    let rc: Rect | undefined;\n    tracePath(this.segs, {\n      onM(p) {\n        rc = updateRect(p, rc);\n      },\n      onL(p) {\n        rc = updateRect(p, rc);\n      },\n      onC(cp1, cp2, p) {\n        rc = updateRect(p, rc);\n        rc.updatePoint(cp1);\n        rc.updatePoint(cp2);\n      },\n      onQ(cp, p) {\n        rc = updateRect(p, rc);\n        rc.updatePoint(cp);\n      },\n      onA(r, xRot, largeArc, sweep, pt) {\n        rc = updateRect(pt, rc);\n      },\n    });\n    this.bounds = rc ?? new Rect();\n    ifDef(this.style.strokeWidth, (it) => {\n      this.bounds.grow(it / 2);\n    });\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    surface.drawPath(offset.plus(this.org), this.segs, this.style);\n  }\n}\n\nexport const createLine = (a: Point, b: Point, style: PathStyle): FigPath =>\n  new FigPath(\n    [\n      { cmd: \"M\", pt: a },\n      { cmd: \"L\", pt: b },\n    ],\n    style\n  );\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { drawRect } from \"./drawRect\";\nimport { Figure } from \"./Figure\";\n\nexport class FigRect extends Figure {\n  readonly radius?: Point;\n\n  constructor(rect: Rect, public readonly style: PathStyle, radius?: Point) {\n    super();\n    this.bounds = rect.clone();\n    this.radius = radius;\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    drawRect(\n      surface,\n      offset.plus(this.org),\n      this.bounds,\n      this.style,\n      this.radius\n    );\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\nimport { getBaseline, getFontHeight } from \"../utils/fontFaceProps\";\n\nexport class FigText extends Figure {\n  constructor(\n    public readonly text: string,\n    public readonly font: LocalFont,\n    public readonly style: TextStyle\n  ) {\n    super();\n    const ff = font.getFontFace();\n    const height = getFontHeight(ff);\n    const baseLine = getBaseline(ff);\n    this.bounds.A.y = -baseLine;\n    this.bounds.B.y = height - baseLine;\n    this.bounds.B.x = font.getTextWidth(text);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    this.font.drawLine(surface, offset.plus(this.org), this.text, this.style);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface } from \"../AbstractSurface\";\n\nexport abstract class Figure {\n  bounds: Rect;\n\n  org: Point;\n\n  constructor() {\n    this.bounds = new Rect();\n    this.org = new Point();\n  }\n\n  abstract update(): void;\n\n  abstract draw(offset: Point, surface: AbstractSurface): void;\n\n  getRelativeBounds(): Rect {\n    const rc = this.bounds.clone();\n    rc.move(this.org);\n    return rc;\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\n\nexport const drawRect = (\n  surface: AbstractSurface,\n  offset: Point,\n  rect: Rect,\n  style: PathStyle,\n  radius?: Point\n) => {\n  if (surface.drawRect) {\n    surface.drawRect(offset, rect, style, radius);\n  } else {\n    const segs: PathSeg[] = [\n      { cmd: \"M\", pt: rect.A },\n      { cmd: \"H\", x: rect.B.x },\n      { cmd: \"V\", y: rect.B.y },\n      { cmd: \"H\", x: rect.A.x },\n      { cmd: \"Z\" },\n    ];\n    surface.drawPath(offset, segs, style);\n  }\n};\n","import { AbstractSurface } from \"../AbstractSurface\";\nimport { FigFrame } from \"./FigFrame\";\n\nexport const renderTopFrame = (frame: FigFrame, surface: AbstractSurface) => {\n  surface.setSize(frame.bounds.size);\n  frame.draw(frame.bounds.A.neg(), surface);\n};\n","import { PathSeg, PathSegPt } from \"../../path\";\nimport { Rect } from \"../../../math/Rect\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { SrcData } from \"./scalePath\";\nimport { Point } from \"../../../math/Point\";\nimport { tracePath } from \"../../utils/tracePath\";\n\nexport const openBrace: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return drawTriple(desiredRect, leftTop, leftMid, leftBottom, 3, 11);\n  },\n};\n\nexport const closeBrace: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return drawTriple(desiredRect, rightTop, rightMid, rightBottom, 11, 3);\n  },\n};\n\n// Данный алгоритм дает более качественное изображение, чем scalePath для символов {}\n// Но его можно еще улучшить, если сделать резиновые точки соединения,\n// а сами фигуры оставлять пропорциональными по высоте и ширине.\nconst drawTriple = (\n  desiredRect: Rect,\n  top: SrcData,\n  mid: SrcData,\n  bot: SrcData,\n  topConn: number,\n  botConn: number\n): PathSeg[] => {\n  const segs: PathSeg[] = [];\n  // Проверка стыковки\n  const topCa: Point = (top.segs[0] as PathSegPt).pt; // 210, 2545 | 769, 2545\n  const topCb: Point = (top.segs[top.segs.length - 2] as PathSegPt).pt; // 0, 2545 | 559, 2545\n  if (topCa.y !== topCb.y) return segs;\n  const midCa: Point = (mid.segs[topConn] as PathSegPt).pt; // 637, 0 | 0, 4687\n  const midCb: Point = (mid.segs[topConn + 1] as PathSegPt).pt; // 427, 0 | 210, 4687\n  if (midCa.y !== midCb.y) return segs;\n  const midCc: Point = (mid.segs[botConn] as PathSegPt).pt; // (427, 4687) | 210, 0\n  // const midCd: Point = (mid.segs[botConn + 1] as PathSegPt).pt; // (637, 4687) | (0, 0)\n  const botCc: Point = (bot.segs[0] as PathSegPt).pt; // 0, 0 | 769, 2545\n  // const botCd: Point = (bot.segs[bot.segs.length - 2] as PathSegPt).pt; // 210, 0 | 559, 2545\n\n  const rect = new Rect();\n  const build = (src: PathSeg[], start: number, stop: number, delta: Point) => {\n    const cvt = (p: Point): Point => {\n      const res = p.plus(delta);\n      if (res.isZero()) {\n        rect.A.setPt(res);\n        rect.B.setPt(res);\n      } else {\n        rect.A.mini(res);\n        rect.B.maxi(res);\n      }\n      return res;\n    };\n    const step = 1; // ccw ? -1 : 1;\n    let i = start;\n    while (i !== stop) {\n      if (i < 0) i = src.length - 1;\n      else if (i === src.length) i = 0;\n      const cur = src[i]!;\n      i += step;\n      switch (cur.cmd) {\n        case \"M\":\n          segs.push({ cmd: segs.length === 0 ? \"M\" : \"L\", pt: cvt(cur.pt) });\n          break;\n        case \"L\":\n          segs.push({ cmd: \"L\", pt: cvt(cur.pt) });\n          break;\n        case \"Q\":\n          segs.push({ cmd: \"Q\", pt: cvt(cur.pt), cp: cvt(cur.cp) });\n          break;\n        case \"C\":\n          segs.push({\n            cmd: \"C\",\n            pt: cvt(cur.pt),\n            cp1: cvt(cur.cp1),\n            cp2: cvt(cur.cp2),\n          });\n          break;\n        default:\n          break;\n      }\n    }\n  };\n  build(top.segs, 0, top.segs.length - 1, new Point(midCa.x - topCa.x, 0));\n  build(mid.segs, topConn + 1, botConn, new Point(0, top.height));\n  build(\n    bot.segs,\n    0,\n    bot.segs.length - 1,\n    new Point(midCc.x - botCc.x, top.height + mid.height)\n  );\n  build(mid.segs, botConn + 1, topConn, new Point(0, top.height));\n  // scale\n  const kx = desiredRect.width / rect.width;\n  const ky = desiredRect.height / rect.height;\n  const scale = (pt: Point) => {\n    pt.set((pt.x - rect.left) * kx, pt.y * ky);\n  };\n  tracePath(segs, {\n    onM(p) {\n      scale(p);\n    },\n    onL(p) {\n      scale(p);\n    },\n    onC(p, cp1, cp2) {\n      scale(p);\n      scale(cp1);\n      scale(cp2);\n    },\n    onQ(cp, p) {\n      scale(cp);\n      scale(p);\n    },\n    onA(): void {\n      throw new Error(\"Function not implemented.\");\n    },\n  });\n\n  segs.push({ cmd: \"Z\" });\n\n  return segs;\n};\n\n// #7-0 -connect with middle\nconst leftBottom: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(0, 0) },\n    { cmd: \"L\", pt: new Point(0, 801) },\n    { cmd: \"Q\", pt: new Point(177.5, 2052.5), cp: new Point(0, 1632) },\n    { cmd: \"Q\", pt: new Point(769, 2545), cp: new Point(355, 2473) },\n    { cmd: \"L\", pt: new Point(769, 2450) },\n    { cmd: \"Q\", pt: new Point(343, 1986), cp: new Point(476, 2381) },\n    { cmd: \"Q\", pt: new Point(210, 767), cp: new Point(210, 1591) },\n    { cmd: \"L\", pt: new Point(210, 0) },\n    { cmd: \"Z\" },\n  ],\n};\n\n// #3,4 - connect with top\n// #11,12 - connect with bottom\nconst leftMid: SrcData = {\n  width: 637,\n  height: 4687,\n  segs: [\n    { cmd: \"M\", pt: new Point(209, 2331) },\n    { cmd: \"Q\", pt: new Point(485.5, 2020), cp: new Point(350, 2271) },\n    { cmd: \"Q\", pt: new Point(637, 1185), cp: new Point(621, 1769) },\n    { cmd: \"L\", pt: new Point(637, 0) }, // 3\n    { cmd: \"L\", pt: new Point(427, 0) }, // 4\n    { cmd: \"L\", pt: new Point(427, 1359) },\n    { cmd: \"Q\", pt: new Point(315, 2041), cp: new Point(427, 1811) },\n    { cmd: \"Q\", pt: new Point(0, 2279), cp: new Point(203, 2271) },\n    { cmd: \"L\", pt: new Point(0, 2399) },\n    { cmd: \"Q\", pt: new Point(313, 2638), cp: new Point(199, 2407) },\n    { cmd: \"Q\", pt: new Point(427, 3328), cp: new Point(427, 2869) },\n    { cmd: \"L\", pt: new Point(427, 4687) }, // 11\n    { cmd: \"L\", pt: new Point(637, 4687) }, // 12\n    { cmd: \"L\", pt: new Point(637, 3502) },\n    { cmd: \"Q\", pt: new Point(494.5, 2680), cp: new Point(637, 2945) },\n    { cmd: \"Q\", pt: new Point(209, 2356), cp: new Point(352, 2415) },\n    { cmd: \"Z\" },\n  ],\n};\n\n// #7-0 -connect with middle\nconst leftTop: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(210, 2545) },\n    { cmd: \"L\", pt: new Point(210, 1778) },\n    { cmd: \"Q\", pt: new Point(343, 559), cp: new Point(210, 954) },\n    { cmd: \"Q\", pt: new Point(769, 95), cp: new Point(476, 164) },\n    { cmd: \"L\", pt: new Point(769, 0) },\n    { cmd: \"Q\", pt: new Point(177.5, 492.5), cp: new Point(355, 72) },\n    { cmd: \"Q\", pt: new Point(0, 1744), cp: new Point(0, 913) },\n    { cmd: \"L\", pt: new Point(0, 2545) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightBottom: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(559, 0) },\n    { cmd: \"L\", pt: new Point(559, 767) },\n    { cmd: \"Q\", pt: new Point(426, 1986), cp: new Point(559, 1591) },\n    { cmd: \"Q\", pt: new Point(0, 2450), cp: new Point(293, 2381) },\n    { cmd: \"L\", pt: new Point(0, 2545) },\n    { cmd: \"Q\", pt: new Point(591.5, 2052.5), cp: new Point(414, 2473) },\n    { cmd: \"Q\", pt: new Point(769, 801), cp: new Point(769, 1632) },\n    { cmd: \"L\", pt: new Point(769, 0) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightMid: SrcData = {\n  width: 637,\n  height: 4687,\n  segs: [\n    { cmd: \"M\", pt: new Point(428, 2356) },\n    { cmd: \"Q\", pt: new Point(142.5, 2680), cp: new Point(285, 2415) },\n    { cmd: \"Q\", pt: new Point(0, 3502), cp: new Point(0, 2945) },\n    { cmd: \"L\", pt: new Point(0, 4687) }, // 3\n    { cmd: \"L\", pt: new Point(210, 4687) }, // 4\n    { cmd: \"L\", pt: new Point(210, 3328) },\n    { cmd: \"Q\", pt: new Point(324, 2638), cp: new Point(210, 2869) },\n    { cmd: \"Q\", pt: new Point(637, 2399), cp: new Point(438, 2407) },\n    { cmd: \"L\", pt: new Point(637, 2279) },\n    { cmd: \"Q\", pt: new Point(322, 2041), cp: new Point(434, 2271) },\n    { cmd: \"Q\", pt: new Point(210, 1359), cp: new Point(210, 1811) },\n    { cmd: \"L\", pt: new Point(210, 0) }, // 11\n    { cmd: \"L\", pt: new Point(0, 0) }, // 12\n    { cmd: \"L\", pt: new Point(0, 1185) },\n    { cmd: \"Q\", pt: new Point(151.5, 2020), cp: new Point(16, 1769) },\n    { cmd: \"Q\", pt: new Point(428, 2331), cp: new Point(287, 2271) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightTop: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(769, 2545) },\n    { cmd: \"L\", pt: new Point(769, 1744) },\n    { cmd: \"Q\", pt: new Point(591.5, 492.5), cp: new Point(769, 913) },\n    { cmd: \"Q\", pt: new Point(0, 0), cp: new Point(414, 72) },\n    { cmd: \"L\", pt: new Point(0, 95) },\n    { cmd: \"Q\", pt: new Point(426, 559), cp: new Point(293, 164) },\n    { cmd: \"Q\", pt: new Point(559, 1778), cp: new Point(559, 954) },\n    { cmd: \"L\", pt: new Point(559, 2545) },\n    { cmd: \"Z\" },\n  ],\n};\n","import { PathSeg } from \"../../path\";\nimport { Rect } from \"../../../math/Rect\";\nimport { Point } from \"../../../math/Point\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { scalePath, SrcData } from \"./scalePath\";\n\nconst data: SrcData = {\n  width: 559,\n  height: 1870,\n  segs: [\n    { cmd: \"M\", pt: new Point(0, 1870) },\n    { cmd: \"Q\", pt: new Point(277.5, 1819), cp: new Point(170, 1870) },\n    { cmd: \"Q\", pt: new Point(445, 1663.5), cp: new Point(385, 1768) },\n    { cmd: \"Q\", pt: new Point(532, 1392), cp: new Point(505, 1559) },\n    { cmd: \"Q\", pt: new Point(559, 939), cp: new Point(559, 1225) },\n    { cmd: \"Q\", pt: new Point(532.5, 486.5), cp: new Point(559, 655) },\n    { cmd: \"Q\", pt: new Point(446, 212), cp: new Point(506, 318) },\n    { cmd: \"Q\", pt: new Point(278, 53), cp: new Point(386, 106) },\n    { cmd: \"Q\", pt: new Point(0, 0), cp: new Point(170, 0) },\n    { cmd: \"L\", pt: new Point(0, 82) },\n    { cmd: \"Q\", pt: new Point(124, 94), cp: new Point(70, 82) },\n    { cmd: \"Q\", pt: new Point(228, 148), cp: new Point(185, 108) },\n    { cmd: \"Q\", pt: new Point(306, 271), cp: new Point(276, 192) },\n    { cmd: \"Q\", pt: new Point(358, 515), cp: new Point(341, 363) },\n    { cmd: \"Q\", pt: new Point(376, 931), cp: new Point(376, 676) },\n    { cmd: \"Q\", pt: new Point(361, 1313.5), cp: new Point(376, 1156) },\n    { cmd: \"Q\", pt: new Point(311, 1571), cp: new Point(346, 1471) },\n    { cmd: \"Q\", pt: new Point(241, 1702), cp: new Point(283, 1655) },\n    { cmd: \"Q\", pt: new Point(153, 1764), cp: new Point(204, 1743) },\n    { cmd: \"Q\", pt: new Point(0, 1788), cp: new Point(94, 1788) },\n    { cmd: \"Z\" },\n  ],\n};\n\nexport const closeBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return scalePath(desiredRect, data);\n  },\n};\n","import { ChemImgProps } from \"../../ChemImgProps\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathStyle } from \"../../AbstractSurface\";\nimport { FigPath } from \"../FigPath\";\nimport { Figure } from \"../Figure\";\nimport { RubberFigure } from \"./RubberFigure\";\n\n/**\n * реализация интерфейса RubberFigure может поменяться. Её следует воспринимать как чёрный ящик.\n * На вход подается желаемый размер.\n * Фактический размер следует брать из фигуры (поле bounds)\n */\nexport const drawRubberFigure = (\n  rubberFig: RubberFigure,\n  desiredRect: Rect,\n  style: PathStyle,\n  imgProps: ChemImgProps\n): Figure => {\n  const fig = new FigPath(rubberFig.draw(desiredRect, imgProps), style);\n  fig.update();\n  return fig;\n};\n","import { closeBracket } from \"./closeBracket\";\nimport { openBracket } from \"./openBracket\";\nimport { openSquareBracket, closeSquareBracket } from \"./squareBrackets\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { closeBrace, openBrace } from \"./braces\";\n\nconst dict: Record<string, RubberFigure> = {\n  \"[\": openSquareBracket,\n  \"]\": closeSquareBracket,\n  \"(\": openBracket,\n  \")\": closeBracket,\n  \"{\": openBrace,\n  \"}\": closeBrace,\n};\n\nexport const getRubberBracket = (\n  isOpen: boolean,\n  text: string\n): RubberFigure => {\n  const rubberFig = dict[text];\n  if (rubberFig) return rubberFig;\n  return isOpen ? openSquareBracket : closeSquareBracket;\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathSeg } from \"../../path\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { scalePath, SrcData } from \"./scalePath\";\n\nconst data: SrcData = {\n  width: 559,\n  height: 1870,\n  segs: [\n    { cmd: \"M\", pt: new Point(559, 0) },\n    { cmd: \"Q\", pt: new Point(281.5, 51), cp: new Point(389, 0) },\n    { cmd: \"Q\", pt: new Point(114, 206.5), cp: new Point(174, 102) },\n    { cmd: \"Q\", pt: new Point(27, 478), cp: new Point(54, 311) },\n    { cmd: \"Q\", pt: new Point(0, 931), cp: new Point(0, 645) },\n    { cmd: \"Q\", pt: new Point(26.5, 1383.5), cp: new Point(0, 1215) },\n    { cmd: \"Q\", pt: new Point(113, 1658), cp: new Point(53, 1552) },\n    { cmd: \"Q\", pt: new Point(281, 1817), cp: new Point(173, 1764) },\n    { cmd: \"Q\", pt: new Point(559, 1870), cp: new Point(389, 1870) },\n    { cmd: \"L\", pt: new Point(559, 1788) },\n    { cmd: \"Q\", pt: new Point(435, 1776), cp: new Point(489, 1788) },\n    { cmd: \"Q\", pt: new Point(331, 1722), cp: new Point(374, 1762) },\n    { cmd: \"Q\", pt: new Point(253, 1599), cp: new Point(283, 1678) },\n    { cmd: \"Q\", pt: new Point(201, 1355), cp: new Point(218, 1507) },\n    { cmd: \"Q\", pt: new Point(183, 939), cp: new Point(183, 1194) },\n    { cmd: \"Q\", pt: new Point(198, 556.5), cp: new Point(183, 714) },\n    { cmd: \"Q\", pt: new Point(248, 299), cp: new Point(213, 399) },\n    { cmd: \"Q\", pt: new Point(318, 168), cp: new Point(276, 215) },\n    { cmd: \"Q\", pt: new Point(406, 106), cp: new Point(355, 127) },\n    { cmd: \"Q\", pt: new Point(559, 82), cp: new Point(465, 82) },\n    { cmd: \"Z\" },\n  ],\n};\n\nexport const openBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return scalePath(desiredRect, data);\n  },\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { tracePath } from \"../../utils/tracePath\";\nimport { PathSeg } from \"../../path\";\n\nexport interface SrcData {\n  width: number;\n  height: number;\n  segs: PathSeg[];\n}\n\nexport const scalePath = (desiredRect: Rect, data: SrcData): PathSeg[] => {\n  const res: PathSeg[] = [];\n  // p -- data\n  // res -- desiredRect\n  const cvt = (p: Point) =>\n    new Point(\n      (p.x * desiredRect.width) / data.width,\n      (p.y * desiredRect.height) / data.height\n    );\n  tracePath(data.segs, {\n    onM(p: Point): void {\n      res.push({ cmd: \"M\", pt: cvt(p) });\n    },\n    onL(p: Point): void {\n      res.push({ cmd: \"L\", pt: cvt(p) });\n    },\n    onC(cp1: Point, cp2: Point, p: Point): void {\n      res.push({ cmd: \"C\", pt: cvt(p), cp1: cvt(cp1), cp2: cvt(cp2) });\n    },\n    onQ(cp: Point, p: Point): void {\n      res.push({ cmd: \"Q\", pt: cvt(p), cp: cvt(cp) });\n    },\n    onA(): void {\n      throw new Error(\"Function not implemented.\");\n    },\n  });\n  return res;\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathSeg } from \"../../path\";\nimport { RubberFigure } from \"./RubberFigure\";\n\nconst width = 446;\nconst thickH = 82;\nconst thickV = 176;\n\nexport const openSquareBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    const scale = desiredRect.width / width;\n    const sWidth = width * scale;\n    const sHeight = desiredRect.height;\n    const sThickH = thickH * scale;\n    const sThickV = thickV * scale;\n    return [\n      { cmd: \"M\", pt: new Point(sWidth, 0) },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"V\", y: sHeight },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"V\", y: sHeight - sThickH },\n      { cmd: \"H\", x: sThickV },\n      { cmd: \"V\", y: sThickH },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"Z\" },\n    ];\n  },\n};\n\nexport const closeSquareBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    const scale = desiredRect.width / width;\n    const sWidth = width * scale;\n    const sHeight = desiredRect.height;\n    const sThickH = thickH * scale;\n    const sThickV = thickV * scale;\n    return [\n      { cmd: \"M\", pt: new Point() },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"V\", y: sHeight },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"V\", y: sHeight - sThickH },\n      { cmd: \"H\", x: sWidth - sThickV },\n      { cmd: \"V\", y: sThickH },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"Z\" },\n    ];\n  },\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport {\n  AbstractSurface,\n  LocalFont,\n  LocalFontProps,\n  PathStyle,\n} from \"../AbstractSurface\";\nimport { buildSvgText } from \"./svgUtils/buildSvgText\";\nimport { SvgExportOptions } from \"./SvgExportOptions\";\nimport { drawTag } from \"../../utils/xml/drawTag\";\nimport { toa } from \"../../math\";\nimport { PathSeg } from \"../path\";\nimport { pathToString } from \"../utils/pathToString\";\nimport { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { Matrix2x3 } from \"../../math/Matrix2x3\";\n\nconst pathAttrs = (style: PathStyle, org?: Point | Matrix2x3) => {\n  const { stroke, strokeWidth, join, cap } = style;\n  const attrs: XmlAttrs = {};\n  attrs.fill = style.fill ?? \"none\";\n  if (stroke) {\n    attrs.stroke = stroke;\n  }\n  if (strokeWidth) attrs[\"stroke-width\"] = toa(strokeWidth);\n  if (join) attrs[\"stroke-linecap\"] = join;\n  if (cap) attrs[\"stroke-linecap\"] = cap;\n  if (org) {\n    if (org instanceof Point && !org.isZero()) {\n      attrs.transform = `translate(${toa(org.x)},${toa(org.y)})`;\n    } else if (org instanceof Matrix2x3) {\n      attrs.transform = `matrix(${org.repr()})`;\n    }\n  }\n  return attrs;\n};\n\n/**\n * SvgSurface can be used for Node and Browser.\n * But it is recommended to use different font systems for each of the platforms.\n */\nexport abstract class SvgSurface implements AbstractSurface {\n  abstract getFont(props: LocalFontProps): LocalFont;\n\n  // Parent overrides\n\n  setSize(size: Point) {\n    this.size = size.clone();\n    this.clear();\n  }\n\n  drawPath(org: Point | Matrix2x3, path: PathSeg[], style: PathStyle): void {\n    const attrs: XmlAttrs = { d: pathToString(path), ...pathAttrs(style, org) };\n    this.addFigure(drawTag(\"path\", attrs, true));\n  }\n\n  drawRect(offset: Point, rect: Rect, style: PathStyle, radius?: Point) {\n    const attrs: XmlAttrs = {\n      x: toa(rect.left),\n      y: toa(rect.top),\n      width: toa(rect.width),\n      height: toa(rect.height),\n      ...pathAttrs(style, offset),\n    };\n    if (radius) {\n      attrs.rx = toa(radius.x);\n      attrs.ry = toa(radius.y);\n    }\n    this.addFigure(drawTag(\"rect\", attrs, true));\n  }\n\n  drawEllipse(\n    offset: Point,\n    center: Point,\n    radius: Point,\n    style: PathStyle\n  ): void {\n    const attrs: XmlAttrs = {\n      ...pathAttrs(style, offset),\n      cx: toa(center.x),\n      cy: toa(center.y),\n      rx: toa(radius.x),\n      ry: toa(radius.y),\n    };\n    this.addFigure(`${drawTag(\"ellipse\", attrs, true)}`);\n  }\n\n  // Svg specific\n\n  addFigure(xmlCode: string) {\n    this.body.push(xmlCode);\n  }\n\n  addDef(id: string, value: string) {\n    this.defs[id] = value;\n  }\n\n  exportText(options?: SvgExportOptions): string {\n    return buildSvgText(this.size, this.defs, this.body, options ?? {});\n  }\n\n  clear() {\n    this.defs = {};\n    this.body.length = 0;\n  }\n\n  private size: Point = new Point();\n\n  defs: Record<string, string> = {};\n\n  body: string[] = [];\n}\n","import { SvgExportOptions } from \"./SvgExportOptions\";\n\n/**\n * This options can be useful for non-standalone SVG creating\n */\nexport const standaloneExportOptions: SvgExportOptions = Object.freeze({\n  xml: {\n    version: \"1.0\",\n    encoding: \"UTF-8\",\n    standalone: \"no\",\n  },\n  doctype: `svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"`,\n  svg: {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    version: \"1.1\",\n    baseProfile: \"full\",\n    \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",\n    \"xmlns:ev\": \"http://www.w3.org/2001/xml-events\",\n  },\n});\n","import { Point } from \"../../../math/Point\";\nimport { XmlAttrs } from \"../../../utils/xml/xmlTypes\";\nimport { SvgExportOptions } from \"../SvgExportOptions\";\nimport { drawTag } from \"../../../utils/xml/drawTag\";\nimport { getVersionStr } from \"../../../getVersion\";\n\nexport const buildSvgText = (\n  size: Point,\n  defs: Record<string, string>,\n  body: string[],\n  options: SvgExportOptions\n): string => {\n  let result = \"\";\n  const { xml, doctype, svg } = options;\n  if (xml) {\n    result += `${drawTag(\"?xml\", xml, true).replace(\"/>\", \"?>\")}\\n`;\n  }\n  if (doctype) {\n    result += `<!DOCTYPE ${doctype}>\\n`;\n  }\n  const rootAttrs: XmlAttrs = {\n    viewBox: `0 0 ${size.x} ${size.y}`,\n    ...svg,\n  };\n  if (options.width) rootAttrs.width = options.width;\n  if (options.height) rootAttrs.height = options.height;\n  if (!(\"xmlns\" in rootAttrs)) {\n    rootAttrs.xmlns = \"http://www.w3.org/2000/svg\";\n  }\n  result += `${drawTag(\"svg\", rootAttrs)}\\n`;\n  if (!options.excludeVerInfo) {\n    result += `  <!-- Generated by CharChem v.${getVersionStr()} -->\\n`;\n  }\n  const defsList = Object.keys(defs);\n  if (defsList.length > 0) {\n    result += `  <defs>\\n`;\n    defsList.forEach((key: string) => {\n      result += `    ${defs[key]}\\n`;\n    });\n    result += `  </defs>\\n`;\n  }\n  body.forEach((s) => {\n    result += `  ${s}\\n`;\n  });\n  result += `</svg>`;\n  return result;\n};\n","import { LocalFontProps } from \"../AbstractSurface\";\nimport { fontWeightValue } from \"./fontWeightValue\";\n\nexport const createLocalFontHash = (props: LocalFontProps): string => {\n  let hash = `family:${props.family};height:${props.height};`;\n  if (props.weight) {\n    const v = fontWeightValue(props.weight);\n    if (v !== 400) hash += `weight:${v};`;\n  }\n  if (props.style && props.style !== \"normal\") hash += `style:${props.style};`;\n  if (props.stretch && props.stretch !== \"normal\")\n    hash += `stretch:${props.stretch};`;\n  return hash;\n};\n","import { RulesHtml } from \"../../textRules/rulesHtml\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { ChemCharge } from \"../../core/ChemCharge\";\nimport { ChemStyleId } from \"../ChemStyleId\";\nimport { ChemImgProps } from \"../ChemImgProps\";\n\nexport const createRulesList = (rules: RulesHtml) => {\n  const k = new ChemK(9);\n  const list: [ChemStyleId, string][] = [\n    [\"agentK\", rules.agentK(k)],\n    [\"comment\", rules.comment(\"A\")],\n    [\"custom\", rules.custom(\"A\")],\n    [\"itemCount\", rules.itemCount(k)],\n    [\"itemMass\", rules.itemMass(9)],\n    [\"nodeCharge\", rules.nodeCharge(new ChemCharge(\"9\", 9))],\n    [\"bracketCharge\", rules.bracketCharge(new ChemCharge(\"9\", 9))],\n    [\"bracketCount\", rules.bracketCount(k)],\n  ];\n  // Не вошедшие в список стили, которые являются индексами, считаются такими же как коэффициент элемента\n  const used = new Set<ChemStyleId>(list.map(([id]) => id));\n  ChemImgProps.getIndexStyles().forEach((styleId) => {\n    if (!used.has(styleId)) list.push([styleId, rules.itemCount(k)]);\n  });\n  return list;\n};\n","import { CommonFontFace } from \"../CommonFontFace\";\n\nexport const getBaseline = ({ ascent }: CommonFontFace): number => ascent;\n\nexport const getFontHeight = ({ ascent, descent }: CommonFontFace): number =>\n  ascent - descent;\n","import { FontWeight } from \"../FontTypes\";\n// see https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#propdef-font-weight\n// except bolder and lighter\n\nexport const fontWeightValue = (weight: FontWeight): number => {\n  const value = +weight;\n  if (!Number.isNaN(value)) return value;\n  if (weight === \"bold\") return 700;\n  return 400;\n};\n\nexport const isBold = (weight?: FontWeight): boolean =>\n  !!weight && fontWeightValue(weight) >= 700;\n","import { PathSeg } from \"../path\";\nimport { Point } from \"../../math/Point\";\nimport { toa } from \"../../math\";\n\nexport const pathToString = (segments: PathSeg[]): string =>\n  segments\n    .map((seg) => {\n      const { cmd } = seg;\n      let dstSeg: string = seg.rel ? cmd.toLowerCase() : cmd;\n      const addPoint = (p: Point) => {\n        if (dstSeg.length !== 1) dstSeg += \" \";\n        dstSeg += `${toa(p.x)} ${toa(p.y)}`;\n      };\n      switch (cmd) {\n        case \"M\":\n        case \"L\":\n        case \"T\":\n          addPoint(seg.pt);\n          break;\n        case \"H\":\n          dstSeg += toa(seg.x);\n          break;\n        case \"V\":\n          dstSeg += toa(seg.y);\n          break;\n        case \"C\":\n          addPoint(seg.cp1);\n          addPoint(seg.cp2);\n          addPoint(seg.pt);\n          break;\n        case \"S\":\n          addPoint(seg.cp2);\n          addPoint(seg.pt);\n          break;\n        case \"Q\":\n          addPoint(seg.cp);\n          addPoint(seg.pt);\n          break;\n        case \"A\":\n          addPoint(seg.r);\n          dstSeg += ` ${toa(seg.xRot)} ${seg.largeArc} ${seg.sweep}`;\n          addPoint(seg.pt);\n          break;\n        default:\n          break;\n      }\n      return dstSeg;\n    })\n    .join(\"\");\n","import { CommonFontFace, FontFaceBBox } from \"../CommonFontFace\";\n\nexport const scaleFontFace = (\n  src: CommonFontFace,\n  scale: number\n): CommonFontFace => {\n  const dst: CommonFontFace = { ...src };\n\n  dst.ascent *= scale;\n  dst.descent *= scale;\n  dst.capHeight *= scale;\n  dst.xHeight *= scale;\n  const { bbox } = src;\n  if (bbox) dst.bbox = bbox.map((v) => v * scale) as FontFaceBBox;\n\n  return dst;\n};\n","import { Point } from \"../../math/Point\";\nimport { PathSeg, PathVisitor } from \"../path\";\n\nexport const tracePath = (segments: PathSeg[], visitor: PathVisitor) => {\n  let p0 = new Point();\n  let prev = p0.clone();\n  let cpPrev = p0.clone();\n  const getPoint = (rel: boolean | undefined, p: Point): Point =>\n    rel ? prev.plus(p) : p;\n  const update = (p: Point, cp?: Point) => {\n    prev = p;\n    cpPrev = cp ?? p;\n  };\n  const calcCP = () => prev.times(2).minus(cpPrev);\n\n  segments.forEach((seg, i) => {\n    const { cmd } = seg;\n    if (cmd === \"Z\") {\n      (visitor.onZ ?? visitor.onL)(p0);\n      update(p0);\n    } else if (cmd === \"M\") {\n      const curPoint = getPoint(seg.rel, seg.pt);\n      visitor.onM(curPoint);\n      if (i === 0) p0 = curPoint;\n      update(curPoint);\n    } else if (cmd === \"L\") {\n      const curPoint = getPoint(seg.rel, seg.pt);\n      visitor.onL(curPoint);\n      update(curPoint);\n    } else if (cmd === \"H\") {\n      const curPoint = new Point(seg.rel ? prev.x + seg.x : seg.x, prev.y);\n      (visitor.onH ?? visitor.onL)(curPoint);\n      update(curPoint);\n    } else if (cmd === \"V\") {\n      const curPoint = new Point(prev.x, seg.rel ? prev.y + seg.y : seg.y);\n      (visitor.onV ?? visitor.onL)(curPoint);\n      update(curPoint);\n    } else if (cmd === \"C\") {\n      const cp1 = getPoint(seg.rel, seg.cp1);\n      const cp2 = getPoint(seg.rel, seg.cp2);\n      const dstPoint = getPoint(seg.rel, seg.pt);\n      visitor.onC(cp1, cp2, dstPoint);\n      update(dstPoint, cp2);\n    } else if (cmd === \"S\") {\n      const cp1 = calcCP();\n      const cp2 = getPoint(seg.rel, seg.cp2);\n      const dstPoint = getPoint(seg.rel, seg.pt);\n      visitor.onC(cp1, cp2, dstPoint);\n      update(dstPoint, cp2);\n    } else if (cmd === \"Q\") {\n      const cp = getPoint(seg.rel, seg.cp);\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onQ(cp, pt);\n      update(pt, cp);\n    } else if (cmd === \"T\") {\n      const cp = calcCP();\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onQ(cp, pt);\n      update(pt, cp);\n    } else if (cmd === \"A\") {\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onA(seg.r, seg.xRot, seg.largeArc, seg.sweep, pt);\n      update(pt);\n    }\n  });\n};\n","import { Int } from \"../types\";\nimport { compile } from \"../compiler/compile\";\nimport { SrcMapItem } from \"../compiler/sourceMap/SrcMapItem\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { Lang, LangParams } from \"../lang\";\nimport { isSuitableForEquation } from \"./isSuitableForEquation\";\nimport { calcAbsMCD, Rational } from \"../math/Rational\";\nimport { ElemList } from \"../core/ElemList\";\nimport { makeElemList } from \"../inspectors/makeElemList\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { equationDict } from \"./equationDict\";\nimport { ChemError } from \"../core/ChemError\";\nimport { checkElementsMatching } from \"./checkElementsMatching\";\nimport { makeCoeffEnumerator } from \"./coeffEnumerators\";\nimport { makeSourceWithNewCoeffs } from \"./makeSourceWithNewCoeffs\";\n\nexport type ChemEquationState = \"NotSolved\" | \"Error\" | \"Solved\";\n\nlet dictReady = false;\n\ninterface SolveRef {\n  srcCol: Int;\n  k: Rational;\n}\n\ninterface SolveItem {\n  dstCol: Int;\n  refs: SolveRef[];\n}\nconst newSolveItem = (dstCol: Int) => ({ dstCol, refs: [] });\n\nexport class ChemEquation {\n  private state: ChemEquationState = \"NotSolved\";\n\n  private msgId?: string;\n\n  private params?: LangParams;\n\n  private agents: ChemAgent[] = [];\n\n  private expr?: ChemExpr;\n\n  private nCols: number = 0;\n\n  private M: Rational[][] = []; // Матрица линейных уравнений\n\n  K: Rational[] = [];\n\n  private solves: SolveItem[] = []; // Набор записей типа A = 2B + C\n\n  private srcMap: SrcMapItem[] = [];\n\n  constructor() {\n    if (!dictReady) {\n      Lang.addDict(equationDict);\n      dictReady = true;\n    }\n    this.clear();\n  }\n\n  getSolves(): SolveItem[] {\n    return this.solves;\n  }\n\n  getExpr(): ChemExpr | undefined {\n    return this.expr;\n  }\n\n  protected setState(\n    state: ChemEquationState,\n    msgId?: string,\n    params?: LangParams\n  ): void {\n    this.state = state;\n    this.msgId = msgId ?? (state === \"NotSolved\" ? \"Not solved\" : undefined);\n    this.params = params;\n  }\n\n  getMessage(langId?: string): string {\n    return (\n      ifDef(this.msgId, (msgId) => Lang.tr(msgId, this.params, langId)) ?? \"\"\n    );\n  }\n\n  isSolved(): boolean {\n    return this.state === \"Solved\";\n  }\n\n  makeError(): Error {\n    return new ChemError(this.msgId || this.state, this.params);\n  }\n\n  clear() {\n    this.setState(\"NotSolved\");\n    this.agents = [];\n    this.expr = undefined;\n    this.M = [];\n    this.solves = [];\n    this.srcMap = [];\n  }\n\n  initBySrc(formula: string): void {\n    const expr = compile(formula, { srcMap: true });\n    this.initByExpr(expr, expr.srcMap ?? []);\n  }\n\n  initByExpr(expr: ChemExpr, srcMap: SrcMapItem[]): void {\n    this.clear();\n    if (!expr) {\n      return this.setState(\"Error\", \"Invalid expression\");\n    }\n    const { error } = expr;\n    if (error) {\n      if (error instanceof ChemError) {\n        return this.setState(\"Error\", error.msgId, error.params);\n      }\n      return this.setState(\"Error\", error.message);\n    }\n    this.expr = expr;\n    this.srcMap = srcMap;\n\n    const res = isSuitableForEquation(expr);\n    if (res) {\n      return this.setState(\"Error\", res.msgId);\n    }\n\n    this.agents = expr.getAgents();\n\n    const parts: ElemList[] = [];\n    this.agents.forEach((agent) => {\n      const { part } = agent;\n      const list = parts[part] || new ElemList();\n      list.addList(makeElemList(agent, true));\n      parts[part] = list;\n    });\n    const leftPart = parts[0];\n    const rightPart = parts[1];\n    if (!leftPart || !rightPart || parts.length !== 2) {\n      return this.setState(\"Error\", \"No separating operation\");\n    }\n    const elemRes = checkElementsMatching([leftPart, rightPart]);\n    if (elemRes) {\n      return this.setState(\"Error\", elemRes[0], elemRes[1]);\n    }\n\n    // Число колонок равно количеству агентов\n    this.nCols = this.agents.length;\n    this.K = this.agents.map(() => new Rational());\n    // Количество строк матрицы равно числу элементов в уравнении\n    this.M = leftPart.list.map(() => []);\n    // Индексация элементов\n    const elemIndex = leftPart.list.reduce(\n      (acc, rec, i) => ({ ...acc, [rec.id]: i }),\n      {} as Record<string, number>\n    );\n\n    this.agents.forEach((agent) => {\n      // массив коэффициентов для столбца\n      const col = this.M.map((row) => {\n        const k = new Rational();\n        row.push(k);\n        return k;\n      });\n      // Получить список элементоа для агента\n      const list = makeElemList(agent, true);\n      list.list.forEach((rec) => {\n        const c: number = rec.n * (agent.part === 1 ? -1 : 1);\n        ifDef(elemIndex[rec.id], (index) => {\n          ifDef(col[index], (k) => k.set(c));\n        });\n      });\n    });\n    return this.setState(\"NotSolved\");\n  }\n\n  getMatrix(): Rational[][] {\n    return this.M;\n  }\n\n  getMatrixStr(): string[] {\n    return this.M.map((row) => row.join(\" \"));\n  }\n\n  //---------------------------------------------------------\n  // Решение уравнения (вызов шагов до получения результата)\n  solve() {\n    while (this.state === \"NotSolved\") {\n      this.calcStep();\n    }\n  }\n\n  // Выполнение одного шага\n  calcStep(): void {\n    // Шаг может выполняться только в состоянии объекта-балансера, когда решение не найдено (и нет ошибок)\n    if (this.state !== \"NotSolved\") return;\n    // Если остался только один неизвестный коэффициент, уравнение можно считать решенным\n    if (this.solves.length === this.nCols - 1) {\n      this.simpleSolve();\n      return;\n    }\n    const { nRow, nCols } = this.findRowForAction();\n    if (nRow >= 0) {\n      if (nCols) {\n        this.onSimpleSolve(nRow, nCols[0], nCols[1]);\n      } else {\n        // Если найдена пустая строка, то удалить её\n        this.deleteMatrixRow(nRow);\n      }\n      return;\n    }\n    // Другой вариант - попытаться объединить две строки\n    if (this.try2RowsUnit()) return;\n\n    // Если других вариантов нет - пробуем решить перебором\n    if (!this.searchKoeffs()) {\n      this.setState(\"Error\", \"Balance is not found\");\n    }\n  }\n\n  deleteMatrixRow(rowIndex: Int) {\n    this.M.splice(rowIndex, 1);\n  }\n\n  // Найдено простое решение, когда один коэффициент выражается через другой\n  onSimpleSolve(rowIndex: Int, k0Index: Int, k1Index: Int) {\n    // Выразить один коэффициент через другой. Нр  2A - 3C = 0 =>  2A = 3C => A = 3/2C\n    const srcRow = this.M[rowIndex]!;\n    // Множитель, через который K[k0] выражается через K[k1]\n    const k: Rational = srcRow[k1Index]!.negx().divi(srcRow[k0Index]!);\n    // Отмечаем, что решение найдено для коэффициента агента #k0\n    const solveItem: SolveItem = newSolveItem(k0Index);\n    // И он равен коэффициенту агента #k1 с соотв. множителем\n    solveItem.refs.push({ srcCol: k1Index, k });\n    this.solves.unshift(solveItem);\n    this.deleteMatrixRow(rowIndex);\n\n    // Теперь нужно заменить в матрице все k0 на k1\n    //   A + B = C + D    =>    A B -C -D\n    //  3/2C + B = C + D  =>    0 B (3/2-1)C -D\n    // То есть, M1 = M1 + M0*m\n    // Затем M0 = 0\n    this.M.forEach((row) => {\n      row[k1Index]!.addi(row[k0Index]!.mulx(k));\n      row[k0Index]!.set(0);\n    });\n  }\n\n  findRowForAction(): { nRow: Int; nCols?: [Int, Int] } {\n    let nCols: [Int, Int] | undefined;\n    const nRow = this.M.findIndex((row) => {\n      const filledNdx: Int[] = row.reduce(\n        (acc, k, j) => (k.isZero() ? acc : [...acc, j]),\n        [] as Int[]\n      );\n      if (filledNdx.length === 0) return true; // Пустая строка\n      if (filledNdx.length === 2) {\n        const col0: Int = filledNdx[0]!;\n        const col1: Int = filledNdx[1]!;\n        if (row[col0]?.sign() !== row[col1]?.sign()) {\n          // строка, где ровно два коэффициента с разными знаками\n          nCols = [col0, col1];\n          return true;\n        }\n      }\n      return false;\n    });\n    return { nRow, nCols };\n  }\n\n  // Решить уравнение, приняв последний коэффициент за 1\n  // void IChemBalance::simpleSolve() {\n  simpleSolve() {\n    // обнуляем результирующие коэффициенты\n    this.K.forEach((k) => k.set(0));\n\n    // Берём оставшиеся неизвестные коэффициенты (обфычно один)\n    const unknownIndexes = this.getUnknownIndices();\n\n    // Заполняем их единицами\n    unknownIndexes.forEach((i) => this.K[i]?.set(1));\n\n    this.calcSolves();\n\n    // Привести все коэффициенты к общему знаменателю\n    this.optimizeKoeffs();\n\n    // Проверки\n    if (!this.checkKoeffs() || !this.checkBalance()) {\n      this.setState(\"Error\", \"Balance is not found\");\n    } else {\n      this.finalSolve();\n    }\n  }\n\n  finalSolve() {\n    // Переключить состояние на Решенное\n    this.setState(\"Solved\", \"\");\n\n    // Заполнить коэффициенты агентов\n    const { expr, K, agents, srcMap } = this;\n    if (expr) {\n      const numCoeffs = K.map(({ x }) => x);\n      const newSrc = makeSourceWithNewCoeffs(\n        numCoeffs,\n        agents,\n        expr.src,\n        srcMap\n      );\n      this.expr = compile(newSrc, { srcMap: true });\n    }\n  }\n\n  /**\n   * Вернуть индексы неизвестных коэффициентов\n   */\n  getUnknownIndices(): Int[] {\n    // вспомогательный массив, куда записываются найденны индексы. Значение 0 - соотв. ненайденному\n    const found: Int[] = new Array(this.nCols);\n    found.fill(0);\n    const notFound: Int[] = [];\n    this.solves.forEach((si) => {\n      found[si.dstCol] = 1;\n    });\n    // Теперь собираем список ненайденных\n    for (let j = 0; j !== this.nCols; j++) {\n      if (!found[j]) notFound.push(j);\n    }\n    return notFound;\n  }\n\n  calcSolves() {\n    // Теперь вычисляем найденные решения\n    this.solves.forEach(({ dstCol, refs }) => {\n      // выражение типа A = 2B + 3C\n      this.K[dstCol]?.set(0);\n      refs.forEach((ref) => {\n        this.K[dstCol]?.addi(ref.k.mulx(this.K[ref.srcCol]!));\n      });\n    });\n  }\n\n  optimizeKoeffs() {\n    // Ищем общий знаменатель\n    const comm: Int = this.K.reduce((acc, { y: k }) => {\n      const nod = calcAbsMCD(acc, k);\n      return Math.max(acc, (acc * k) / nod);\n    }, 1);\n    // Теперь переходим к целым коэффициентам. на y больше не обращаем внимания.\n    const ki: Int[] = this.K.map((r) => {\n      const m = comm / r.y;\n      return r.x * m;\n    });\n    let maxX: Int = ki.reduce((acc, it) => Math.max(acc, it), 0);\n\n    // иногда возможна ситуация, когда все коэффициенты имеют общий делитель...\n    // (возможно, алгоритм был бы эффективнее, если начинать об большего d и уменьшать до 2)\n    let d = 2;\n    /* eslint no-loop-func: \"off\" */\n    while (d <= maxX) {\n      // Пробуем разделить все коэффициенты на минимальный делитель d\n      const inv = ki.findIndex((v) => v % d !== 0);\n      if (inv >= 0) {\n        // если хоть один из коэффициентов не разделился без остатка на d, переходим к сдедующему значению d\n        d++;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      // если все коэффициэнты делятся, делим их и maxX\n      maxX /= d;\n      ki.forEach((value, j) => {\n        ki[j] = value / d;\n      });\n      // следующая итерация происходит с тем же d\n    }\n    // Заполнить полученными целыми значениями массив m_K\n    this.K = ki.map((value) => new Rational(value));\n  }\n\n  // Проверка коэффициентов\n  checkKoeffs(): boolean {\n    return !this.K.find((k) => k.x <= 0);\n  }\n\n  // Проверка баланса\n  checkBalance(): boolean {\n    const balance: Record<string, Int> = {};\n    this.agents.forEach((agent, j) => {\n      makeElemList(agent, true).list.forEach(({ id, n }) => {\n        let count = n;\n        if (agent.part > 0) count = -count;\n        count *= this.K[j]?.x ?? 0;\n        if (!balance[id]) {\n          balance[id] = count;\n        } else {\n          balance[id] += count;\n        }\n      });\n    });\n    // Теперь если есть хоть один ненулевой элемент, значит ошибка\n    return Object.values(balance).findIndex((v) => v !== 0) < 0;\n  }\n\n  try2RowsUnit(): boolean {\n    const { nCols, M } = this;\n    const end = M.length;\n    if (end < 2) {\n      return false;\n    }\n    let it0: Int;\n    let it1: Int;\n    let colNdx: Int = 0;\n    for (it0 = 0; ; ++it0) {\n      it1 = it0 + 1; // Вторая строка следующая за первой\n      if (it1 === end) {\n        // Если конец матрицы, значит не нашлось подходящих для объединения строк\n        return false;\n      }\n      const row0: Rational[] = this.M[it0]!;\n      // Цикл: вторая строка смещается до конца матрицы\n      for (; it1 !== end; ++it1) {\n        const row1 = this.M[it1]!;\n        for (colNdx = 0; colNdx !== nCols; colNdx++) {\n          if (!row0[colNdx]?.isZero() && !row1[colNdx]?.isZero()) break;\n        }\n        if (colNdx !== nCols) break;\n      }\n      if (it1 !== end) break; // найдены две строки it0 и it1, которые объединяются по колонке colNdx\n    }\n    const row0 = M[it0]!;\n    const row1 = M[it1]!;\n    const mul0 = new Rational(-1).divi(row0[colNdx]!);\n    const mul1 = new Rational(-1).divi(row1[colNdx]!);\n    // Сформировать решение из первой строки\n    // colNdx - индекс столбца, для которого формируется решение\n    const sitem: SolveItem = newSolveItem(colNdx);\n    row0.forEach((k, i) => {\n      if (i !== colNdx && !k.isZero()) {\n        // Добавляем слагаемое, если оно ненулевое\n        sitem.refs.push({\n          srcCol: i,\n          k: k.mulx(mul0),\n        });\n      }\n    });\n    if (sitem.refs.length === 0)\n      // Это значит, что в первой строке все остальные колонки, кроме j-й, пусты\n      return false;\n    this.solves.unshift(sitem);\n\n    // Вторая строка комбинируется с первой по принципу row1[i] = row0[i]*mul0 + row1[i]*mul1\n    // 2A -3B -4C   mul0=-1/2  A = 3/2B + 4/2C\n    // 3A -2B -4D   mul1=-1/3  A = 2/3B + 4/3D => 11/6B + 2C + 4/3D\n    for (let i = 0; i !== nCols; i++) {\n      row1[i] = row0[i]!.mulx(mul0).subi(row1[i]!.mulx(mul1));\n    }\n    // Удаляем первую строку из матрицы\n    this.deleteMatrixRow(it0);\n    it1--;\n\n    // Если в матрице остаётся более одной строки, значит нужно подставить только что высчитанный коэффициент\n    this.M.forEach((row, it) => {\n      if (it !== it1) {\n        const k = row[colNdx]!.copy();\n        row[colNdx]!.set(0);\n        sitem.refs.forEach((ref) => row[ref.srcCol]!.addi(k.mulx(ref.k)));\n      }\n    });\n\n    return true;\n  }\n\n  searchKoeffs(): boolean {\n    const unknownIndices = this.getUnknownIndices();\n    // N - количество переменных\n    const N = unknownIndices.length;\n    // MaxL - максимальное значение переменной\n    const MaxL = 30;\n    const gen = makeCoeffEnumerator(N, MaxL);\n    if (gen) {\n      for (const vars of gen) {\n        if (this.testKoeffs(unknownIndices, vars)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  testKoeffs(unknownIndexes: Int[], variants: Int[]): boolean {\n    unknownIndexes.forEach((uIndex, pos) => {\n      this.K[uIndex]?.set(variants[pos]!);\n    });\n    this.calcSolves();\n    if (!this.checkKoeffs()) return false;\n    this.optimizeKoeffs();\n    if (!this.checkBalance()) return false;\n    this.finalSolve();\n    return true;\n  }\n}\n","import { LangParams } from \"../lang\";\nimport { ElemList } from \"../core/ElemList\";\n\n/* eslint no-bitwise: \"off\" */\n\nexport const checkElementsMatching = (\n  parts: [ElemList, ElemList]\n): [string, LangParams | undefined] | undefined => {\n  for (let j = 0; j !== 2; j++) {\n    const first = parts[j];\n    const second = parts[j ^ 1];\n    if (!first || !second) {\n      return [\"Invalid expression\", undefined];\n    }\n    for (const elem of first.list) {\n      if (!second.findRec(elem)) {\n        // Не найден элемент\n        const partId = `${j === 0 ? \"right\" : \"left\"}|part`;\n        return [\"[E] is missing in [S] part\", { E: elem.id, S: partId }];\n      }\n    }\n  }\n  return undefined;\n};\n","import { Int } from \"../types\";\n\n/* eslint no-bitwise: \"off\" */\n\nexport const makeCoeffEnumerator = (\n  dimesion: Int,\n  level: Int\n): Generator<Int[]> => {\n  if (dimesion === 2) return coeffEnumerator2d(level);\n  if (dimesion === 3) return coeffEnumerator3d(level);\n  return coeffEnumeratorNd(dimesion, level);\n};\n\nexport function* coeffEnumerator2d(level: Int) {\n  for (let x0 = 1; x0 <= level; x0++) {\n    for (let y = 1, x = x0; x > 0; y++, x--) {\n      yield [y, x];\n    }\n  }\n  for (let y0 = 2; y0 <= level; y0++) {\n    for (let x = level, y = y0; y <= level; y++, x--) {\n      yield [y, x];\n    }\n  }\n}\n\nexport function* coeffEnumerator3d(level: Int): Generator<Int[]> {\n  yield [1, 1, 1];\n  // Перемещение по x\n  for (let x0 = 2; x0 <= level; x0++) {\n    let x = x0;\n    let y = 1;\n    let z = 1;\n    // фронтальная плоскость XY\n    for (; x > 1; x--, y++) yield [z, y, x];\n    // левая плоскость YZ, x=1\n    for (; y > 1; z++, y--) yield [z, y, x];\n    // верхняя плоскость XZ\n    for (; z > 1; z--, x++) yield [z, y, x];\n  }\n  // по Y\n  const c = Math.floor((level - 2) / 2) + 2;\n  for (let y0 = 2; y0 < level; y0++) {\n    if (y0 === c) {\n      for (const v of coeffEnumerator3d(level - 2)) {\n        yield v.map((i) => i + 1);\n      }\n    }\n    let x = level;\n    let y = y0;\n    let z = 1;\n    for (; y < level; y++, x--) yield [z, y, x];\n    for (; x > 1; z++, x--) yield [z, y, x];\n    for (; z < level; z++, y--) yield [z, y, x];\n    for (; y > 1; x++, y--) yield [z, y, x];\n    for (; x < level; x++, z--) yield [z, y, x];\n    for (; z > 1; z--, y++) yield [z, y, x];\n  }\n  // по Z\n  for (let z0 = 1; z0 < level; z0++) {\n    let x = level;\n    let y = level;\n    let z = z0;\n    for (; z < level; x--, z++) yield [z, y, x];\n    for (; x < level; x++, y--) yield [z, y, x];\n    for (; y < level; z--, y++) yield [z, y, x];\n  }\n\n  if (level > 1) {\n    yield [level, level, level];\n  }\n}\n\n/**\n * Перебор выполняется только для высокоуровневых выриантов,\n * а вложенные части раскрываются при помощи перебора более низкого порядка\n * @param dimension\n * @param maxLevel\n */\nexport function* coeffEnumeratorNd(\n  dimension: Int,\n  maxLevel: Int\n): Generator<Int[]> {\n  const vars = new Array<Int>(dimension);\n  vars.fill(1);\n  yield [...vars];\n  const maxMask = 1 << dimension;\n  for (let level = 2; level <= maxLevel; level++) {\n    // перебор верхнеуровневых вариантов\n    for (let mask = 1; mask !== maxMask; mask++) {\n      const subLevelNdx: Int[] = [];\n      vars.fill(1);\n      for (let col = 0; col < dimension; col++) {\n        const test = 1 << col;\n        if ((mask & test) === 0) {\n          subLevelNdx.push(col);\n        } else {\n          vars[col] = level;\n        }\n      }\n      const sn = subLevelNdx.length;\n      if (level > 2 && sn > 0) {\n        // Перебор вложенной части\n        const gen = makeCoeffEnumerator(sn, level - 1);\n        for (const subVals of gen) {\n          subVals.forEach((v, j) => {\n            vars[subLevelNdx[j]!] = v;\n          });\n          yield [...vars];\n        }\n      } else {\n        yield [...vars];\n      }\n    }\n  }\n}\n","export const equationDict = {\n  ru: {\n    \"[E] is missing in [S] part\":\n      \"Отсутствует элемент [E] в [S#] части уравнения\",\n    \"left|part\": \"левой\",\n    \"right|part\": \"правой\",\n    \"Equation not specified\": \"Уравнение не задано\",\n    \"No separating operation\":\n      \"Требуется одна операция, разделяющая левую и правую часть уравнения\",\n    \"No solution\": \"Не удалось найти решение\",\n    \"Cant balance expression with abstract coefficients\":\n      \"Невозможно балансировать уравнение с абстрактными коэффициентами\",\n    \"Cant balance expression with non-integer coefficients\":\n      \"Невозможно балансировать уравнение с дробными коэффициентами\",\n    \"Cant balance expression with mineral series\":\n      \"Невозможно балансировать неопределенные формулы минералов\",\n    \"Invalid expression\": \"Неподходящее выражение\",\n  },\n  en: {\n    \"[E] is missing in [S] part\":\n      \"Element [E] is missing on the [S#] side of the equation.\",\n    \"left|part\": \"left\",\n    \"right|part\": \"right\",\n    \"Equation not specified\": \"The equation is not specified\",\n    \"No separating operation\":\n      \"Requires a single operation, separating the left and right side of the equation\",\n    \"No solution\": \"Could not find a solution\",\n    \"Cant balance expression with abstract coefficients\":\n      \"Can't balance expression with abstract coefficients\",\n    \"Cant balance expression with non-integer coefficients\":\n      \"Can't balance expression with non-integer coefficients\",\n    \"Cant balance expression with mineral series\":\n      \"Can't balance expression with mineral series\",\n    \"Invalid expression\": \"Неподходящее выражение\",\n  },\n};\n","import { ChemMul } from \"../core/ChemMul\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemNodeItem } from \"../core/ChemNodeItem\";\n\ntype NegativeResult = {\n  reason: \"abstract\" | \"float\";\n  msgId: string;\n};\n\nconst msgAbs = \"Cant balance expression with abstract coefficients\";\n\n/**\n *  Нельзя искать баланс для уравнений, имеющий абстрактные или не целочисленные коэффициенты\n * При этом, нас интересуют коэффициенты при элементах, но не важны коэффициенты агентов\n * @param expr\n */\nexport const isSuitableForEquation = (\n  expr: ChemExpr\n): NegativeResult | undefined =>\n  expr.walkExt({\n    isStop: false as boolean,\n    result: undefined as NegativeResult | undefined,\n    itemPre({ n }: ChemNodeItem) {\n      if (!n.isNumber()) {\n        this.result = {\n          reason: \"abstract\",\n          msgId: msgAbs,\n        };\n      } else if (!n.isInt()) {\n        this.result = {\n          reason: \"float\",\n          msgId: \"Cant balance expression with non-integer coefficients\",\n        };\n      }\n      this.isStop = !!this.result;\n    },\n    mul({ n }: ChemMul) {\n      if (!n.isNumber()) {\n        this.result = {\n          reason: \"abstract\",\n          msgId: msgAbs,\n        };\n      }\n    },\n    comma() {\n      this.result = {\n        reason: \"abstract\",\n        msgId: \"Cant balance expression with mineral series\",\n      };\n    },\n  }).result;\n","import { Int } from \"../types\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { SrcMapItem, getSrcItemsForObject } from \"../compiler/sourceMap\";\n\nexport const makeSourceWithNewCoeffs = (\n  coeffs: Int[],\n  agents: ChemAgent[],\n  oldSrc: string,\n  srcMap: SrcMapItem[]\n): string => {\n  const chunks: string[] = [];\n  let prevPos = 0;\n  agents.forEach((agent, agentIndex) => {\n    const agentItems = getSrcItemsForObject(agent, srcMap);\n    const itemsCount = agentItems.length;\n    // Нужно учитывать возможные неудачные результаты\n    if (itemsCount) {\n      const leftPos = agentItems[0]!.begin;\n      // const rightPos = agentItems[itemsCount-1]!.end;\n      // Текст левее агента\n      chunks.push(oldSrc.slice(prevPos, leftPos));\n      prevPos = leftPos;\n      // Текст нового коэффициента\n      const k = coeffs[agentIndex];\n      if (k !== undefined && k !== 1) {\n        chunks.push(String(k));\n      }\n      // текст агента без коэффициента\n      if (itemsCount > 1 && agentItems[0]!.part === \"agentK\") {\n        prevPos = agentItems[1]!.begin;\n      }\n    }\n  });\n  chunks.push(oldSrc.slice(prevPos));\n  return chunks.join(\"\").trim();\n};\n","import version from \"./version\";\n\nexport const getVersion = () => version as [number, number, number];\n\nexport const getVersionStr = (): string => getVersion().join(\".\");\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\n\n/**\n * Вычисление заряда объекта.\n * Используется для объектов от узла и выше.\n * При наличии абстрактных коэффициентов возвращается NaN\n */\nexport const calcCharge = (chemObj: ChemObj): Double => {\n  const stack: Double[] | [Double] = [0.0];\n  const push = () => {\n    stack.unshift(0.0);\n  };\n\n  const pop = (calc: () => Double) => {\n    const value: Double = stack[0]! * calc();\n    stack.shift();\n    stack[0] += value;\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n    agentPost(obj) {\n      pop(() => obj.n.num);\n    },\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      const { charge } = obj;\n      if (charge) {\n        stack[0] = charge.value;\n      }\n      pop(() => obj.n.num);\n    },\n\n    // TODO: Пока нет поддержки множителей\n\n    nodePost(obj) {\n      // Ниже уровня узла заряд не проверяем\n      const { charge } = obj;\n      if (charge) {\n        stack[0] += charge.value;\n      }\n    },\n  });\n  return stack[0]!;\n};\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ifDef } from \"../utils/ifDef\";\n/**\n * Вычисление массы указанного химического объекта.\n * @param chemObj Любой химический объект (выражение, агент, узел и т.п.)\n * @param applyAgentK Если указать false, то игнорируются коэффициенты агентов.\n *\n * Примечание 1. Рекомендуется использовать функцию isAbstract прежде чем вызывать calcMass.\n * Т.к. если в состав объекта входят абстрактные элементы, то результат непредсказуем.\n * Никакого исключения при этом не генерируется.\n * Например, для выражения {R}-OH мы получим сумму масс O и H\n *\n * Примечание 2. Эта функция не слишком полезна для выражений с несколькими агентами.\n * Поэтому для выражений ChemExpr рекомендуется использовать метод mass.\n */\nexport const calcMass = (\n  chemObj: ChemObj,\n  applyAgentK: boolean = true\n): Double => {\n  const stack: Double[] | [Double] = [0.0];\n  const push = () => {\n    stack.unshift(0.0);\n  };\n  const pop = (calc: () => Double) => {\n    const value: Double = stack[0]! * calc();\n    stack.shift();\n    stack[0]! += value;\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n\n    agentPost(obj) {\n      pop(() => (applyAgentK ? obj.n.num : 1.0));\n    },\n\n    mul() {\n      push();\n    },\n    mulEnd(obj) {\n      pop(() => obj.begin.n.num);\n    },\n\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      pop(() => obj.n.num);\n    },\n\n    nodePre() {\n      push();\n    },\n    nodePost() {\n      pop(() => 1.0);\n    },\n\n    itemPre() {\n      push();\n    },\n    itemPost(obj) {\n      // явно указанная масса $M() более приоритетна, чем вычисленная\n      ifDef(obj.mass, (mass) => {\n        stack[0] = mass;\n      });\n      pop(() => obj.n.num);\n    },\n\n    atom(obj) {\n      stack[0] += obj.mass;\n    },\n\n    radical(obj) {\n      obj.items.list.forEach((listItem) => {\n        stack[0] += listItem.n * (listItem.elem?.mass ?? 0.0);\n      });\n    },\n  });\n  return stack[0]!;\n};\n","import { ChemObj } from \"../core/ChemObj\";\nimport { ChemK } from \"../core/ChemK\";\nimport { Visitor } from \"../core/Visitor\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemNodeItem } from \"../core/ChemNodeItem\";\nimport { ChemBracketEnd } from \"../core/ChemBracket\";\nimport { ChemMul } from \"../core/ChemMul\";\nimport { ChemCustom } from \"../core/ChemCustom\";\n\n/**\n * Является ли указанное выражение абстрактным.\n * Это происходит при следующих условиях:\n * - Наличие абстрактного элемента: {R}-OH\n * - Наличие нечисловых коэффициентов: C'n'H'2n+2'\n * - Запятая: (Ca,Mg)SO4\n */\nexport const isAbstract = (chemObj: ChemObj): boolean => {\n  const visitor = new IsAbstractVisitor(true);\n  chemObj.walk(visitor);\n  return visitor.isStop;\n};\n\nexport const isAbstractCoeffs = (chemObj: ChemObj): boolean => {\n  const visitor = new IsAbstractVisitor(false);\n  chemObj.walk(visitor);\n  return visitor.isStop;\n};\n\nconst isAbsK = (k?: ChemK): boolean => (k ? !k.isNumber() : false);\n\nclass IsAbstractVisitor implements Visitor {\n  isStop: boolean = false;\n\n  constructor(private useItems: boolean) {}\n\n  agentPre(obj: ChemAgent) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  itemPre(obj: ChemNodeItem) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  bracketEnd(obj: ChemBracketEnd) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  mul(obj: ChemMul) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  custom(obj: ChemCustom) {\n    // Наличие пустых узлов не делает формулу абстрактной, т.к. они нужны для фиктивных элементов\n    if (this.useItems && obj.text) {\n      this.isStop = true;\n    }\n  }\n\n  comma() {\n    if (this.useItems) {\n      this.isStop = true;\n    }\n  }\n}\n","import { ChemObj } from \"../core/ChemObj\";\n\nexport const isTextFormula = (chemObj: ChemObj): boolean => {\n  const visitor = chemObj.walkExt({\n    isStop: false as boolean,\n    bond(obj) {\n      this.isStop = !obj.isText;\n    },\n    itemPre(obj) {\n      this.isStop = !!obj.dots;\n    },\n    bracketBegin(obj) {\n      // If the $padding function is used, it means graphic mode\n      this.isStop = !!obj.padding;\n    },\n  });\n  return !visitor.isStop;\n};\n","import { Int } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\n\nexport const locateAtomNumber = (item: ChemObj): Int | undefined => {\n  let num: number | undefined;\n  item.walk({\n    atom(obj) {\n      num = obj.n;\n    },\n  });\n  return num;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\nimport { compile } from \"../compiler/compile\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { makeElemList } from \"./makeElemList\";\nimport { isAbstractCoeffs } from \"./isAbstract\";\n\nexport const makeBruttoKey = (src: ChemObj | string): string => {\n  let obj: ChemObj;\n  if (typeof src === \"string\") {\n    const expr = compile(src);\n    if (!expr.isOk()) return \"\";\n    obj = expr;\n  } else {\n    if (src instanceof ChemExpr && !src.isOk()) {\n      return \"\";\n    }\n    obj = src;\n  }\n  // Если в формуле есть абстрактные элементы, это приемлемо.\n  // Но если есть абстрактные коэффициенты, тогда вычислить нельзя.\n  if (isAbstractCoeffs(obj)) return \"\";\n\n  const elemList = makeElemList(obj);\n  elemList.sortByHill();\n  return String(elemList);\n};\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ElemList } from \"../core/ElemList\";\n/**\n * Generate a list of elements from an expression.\n * Does not make sense for expressions that have more than one agent.\n */\nexport const makeElemList = (\n  chemObj: ChemObj,\n  ignoreAgentK: boolean = false\n): ElemList => {\n  const stack: ElemList[] = [new ElemList()];\n  const push = () => {\n    stack.unshift(new ElemList());\n  };\n  const pop = (k: Double) => {\n    const list = stack.shift()!;\n    list.scale(k);\n    stack[0]!.addList(list);\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n    agentPost(obj) {\n      pop(ignoreAgentK ? 1 : obj.n.num);\n    },\n\n    nodePost(obj) {\n      stack[0]!.charge += obj.charge?.value ?? 0.0;\n    },\n\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      const { charge } = obj;\n      if (charge) {\n        stack[0]!.charge = charge.value;\n      }\n      pop(obj.n.num);\n    },\n\n    mul() {\n      push();\n    },\n    mulEnd(obj) {\n      pop(obj.begin.n.num);\n    },\n\n    itemPre() {\n      push();\n    },\n    itemPost(obj) {\n      pop(obj.n.num);\n    },\n    atom(obj) {\n      stack[0]!.addAtom(obj);\n    },\n    custom(obj) {\n      stack[0]!.addCustom(obj.text);\n    },\n    radical(obj) {\n      stack[0]!.addRadical(obj);\n    },\n  });\n  return stack[0]!;\n};\n","import { ChemBond } from \"../core/ChemBond\";\r\nimport { ChemObj } from \"../core/ChemObj\";\r\nimport { RulesBase } from \"../textRules/RulesBase\";\r\nimport { ChemCharge } from \"../core/ChemCharge\";\r\nimport { ifDef } from \"../utils/ifDef\";\r\nimport { compile } from \"../compiler/compile\";\r\nimport { rulesText } from \"../textRules/rulesText\";\r\nimport { locateAtomNumber } from \"./locateAtomNumber\";\r\n\r\ninterface Chunk {\r\n  text: string;\r\n  color?: string;\r\n}\r\n\r\nclass StackItem {\r\n  l2r: boolean = true;\r\n\r\n  chunks: Chunk[] = [];\r\n\r\n  add(chunk: Chunk) {\r\n    if (this.l2r) {\r\n      this.chunks.push(chunk);\r\n    } else {\r\n      this.chunks.unshift(chunk);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Сформировать текстовое представление химической формулы.\r\n * Не все формулы могут быть представлены в виде текста.\r\n * Поэтому перед вызовом этой функции нужно использовать isTextFormula\r\n * @deprecated next version: textFormula\r\n */\r\nexport const makeTextFormula = (\r\n  chemObj: ChemObj,\r\n  rules: RulesBase = rulesText\r\n): string => {\r\n  const stack: StackItem[] = [new StackItem()];\r\n  let itemColor: string | undefined;\r\n  let atomColor: string | undefined;\r\n\r\n  const push = () => {\r\n    stack.unshift(new StackItem());\r\n  };\r\n\r\n  const pop = () => {\r\n    if (stack.length === 1) {\r\n      return;\r\n    }\r\n    const item = stack.shift()!;\r\n    const top = stack[0]!;\r\n    if (top.l2r) {\r\n      top.chunks = [...top.chunks, ...item.chunks];\r\n    } else {\r\n      top.chunks = [...item.chunks, ...top.chunks];\r\n    }\r\n  };\r\n\r\n  const ctxOut = (text: string, color?: string) =>\r\n    stack[0]!.add({ text, color });\r\n\r\n  const space = () => ctxOut(\" \");\r\n\r\n  const isLtr = (bond?: ChemBond): boolean => !bond?.isNeg;\r\n\r\n  const drawCharge = (\r\n    charge: ChemCharge | undefined,\r\n    isPrefix: boolean,\r\n    color?: string\r\n  ) =>\r\n    ifDef(charge, (it) => {\r\n      if (isPrefix === it.isLeft) {\r\n        ctxOut(rules.nodeCharge(it), color);\r\n      }\r\n    });\r\n\r\n  let autoNode = false;\r\n\r\n  chemObj.walk({\r\n    agentPre(obj) {\r\n      space();\r\n      push();\r\n      if (obj.n.isSpecified()) {\r\n        ctxOut(rules.agentK(obj.n));\r\n      }\r\n    },\r\n    agentPost() {\r\n      pop();\r\n    },\r\n    atom(obj) {\r\n      if (!autoNode) {\r\n        ctxOut(rules.atom(obj.id), atomColor ?? itemColor);\r\n      }\r\n    },\r\n\r\n    bond(obj) {\r\n      stack[0]!.l2r = isLtr(obj);\r\n      ctxOut(obj.tx, obj.color);\r\n    },\r\n\r\n    comma() {\r\n      ctxOut(rules.comma(), itemColor);\r\n    },\r\n\r\n    comment(obj) {\r\n      ctxOut(rules.comment(obj.text), itemColor);\r\n    },\r\n\r\n    custom(obj) {\r\n      ctxOut(rules.custom(obj.text), itemColor);\r\n    },\r\n\r\n    itemPre(obj) {\r\n      if (autoNode) return;\r\n      itemColor = obj.color;\r\n      atomColor = obj.atomColor;\r\n      const rawAtomNum = obj.atomNum;\r\n      if (rawAtomNum !== undefined) {\r\n        // Вывести двухэтажную конструкцию: масса/атомный номер слева от элемента\r\n        const atomNum = rawAtomNum === \"\" ? locateAtomNumber(obj) : rawAtomNum;\r\n        if (atomNum === undefined) {\r\n          ctxOut(rules.itemMass(obj.mass || 0), itemColor);\r\n        } else {\r\n          ctxOut(rules.itemMassAndNum(obj.mass || 0, atomNum), itemColor);\r\n        }\r\n      } else {\r\n        ifDef(obj.mass, (mass) => ctxOut(rules.itemMass(mass), itemColor));\r\n      }\r\n    },\r\n\r\n    itemPost(obj) {\r\n      if (autoNode) return;\r\n      if (obj.charge) ctxOut(rules.itemCharge(obj.charge), itemColor);\r\n      if (obj.n.isSpecified()) ctxOut(rules.itemCount(obj.n), itemColor);\r\n    },\r\n\r\n    nodePre(obj) {\r\n      push();\r\n      drawCharge(obj.charge, true, obj.color);\r\n      if (obj.autoMode) {\r\n        autoNode = true;\r\n      }\r\n    },\r\n\r\n    nodePost(obj) {\r\n      drawCharge(obj.charge, false, obj.color);\r\n      autoNode = false;\r\n      pop();\r\n    },\r\n\r\n    operation(obj) {\r\n      space();\r\n      ctxOut(rules.operation(obj), obj.color);\r\n    },\r\n\r\n    radical(obj) {\r\n      ctxOut(rules.radical(obj.label), itemColor);\r\n    },\r\n\r\n    bracketBegin(obj) {\r\n      const ltr = isLtr(obj.bond);\r\n      if (ltr) {\r\n        push();\r\n        drawCharge(obj.end?.charge, true, obj.color);\r\n        ctxOut(obj.text, obj.color);\r\n      } else {\r\n        const { color, end } = obj;\r\n        if (end) {\r\n          if (stack[0]) stack[0].l2r = false;\r\n          drawCharge(end.charge, false, color);\r\n          if (end.n.isSpecified()) ctxOut(rules.itemCount(end.n), color);\r\n          ctxOut(end.text, color);\r\n        }\r\n        push();\r\n      }\r\n    },\r\n\r\n    bracketEnd(obj) {\r\n      const { begin } = obj;\r\n      const { color } = begin;\r\n      const ltr = isLtr(begin.bond);\r\n      if (ltr) {\r\n        ctxOut(obj.text, color);\r\n        if (obj.n.isSpecified()) ctxOut(rules.itemCount(obj.n), color);\r\n        drawCharge(obj.charge, false, color);\r\n        pop();\r\n      } else {\r\n        pop();\r\n        if (stack[0]) stack[0].l2r = false;\r\n        ctxOut(begin.text, color);\r\n        drawCharge(obj.charge, true, color);\r\n      }\r\n    },\r\n\r\n    mul(obj) {\r\n      if (!obj.isFirst) ctxOut(rules.mul(), obj.color);\r\n      if (obj.n.isSpecified()) ctxOut(rules.mulK(obj.n), obj.color);\r\n    },\r\n  });\r\n\r\n  // Обычно такое не нужно.\r\n  // Но если нужно получить текст для одной команды (скобки), тогда содержимое может остаться в стеке.\r\n  while (stack.length > 1) pop();\r\n\r\n  const nonOptimized = buildTextFromChunks(stack[0]!.chunks, rules).trim();\r\n  return rules.postProcess(nonOptimized);\r\n};\r\n\r\nconst buildTextFromChunks = (chunks: Chunk[], rules: RulesBase): string => {\r\n  const tags = chunks.map((chunkItem, index) => {\r\n    let result = chunkItem.text;\r\n    const { color } = chunkItem;\r\n    if (color) {\r\n      const needOpen = index === 0 || color !== chunks[index - 1]!.color;\r\n      const needClose =\r\n        index === chunks.length - 1 || color !== chunks[index + 1]!.color;\r\n      if (needOpen) result = rules.colorBegin(color) + result;\r\n      if (needClose) result += rules.colorEnd();\r\n    }\r\n    return result;\r\n  });\r\n  return tags.reduce((acc: string, tag) => acc + tag, \"\");\r\n};\r\n\r\nexport const makeTextFormulaSrc = (\r\n  sourceText: string,\r\n  rules: RulesBase\r\n): string => {\r\n  const expr = compile(sourceText);\r\n  if (!expr.isOk()) return \"\";\r\n  return makeTextFormula(expr, rules);\r\n};\r\n","import { ifDef } from \"../utils/ifDef\";\nimport { baseDictEn } from \"./baseDictEn\";\nimport { baseDictRu } from \"./baseDictRu\";\nimport { LocalDict, LangParams } from \"./LangTypes\";\nimport { replaceLangParams } from \"./replaceLangParams\";\n\nexport class Lang {\n  /**\n   * Current language\n   * Format uses from https://tools.ietf.org/html/rfc7231#section-3.1.3.1\n   * Examples: en, ru - internal languages; zh, zh-TW - external (by addDict)\n   */\n  static curLang: string = \"en\";\n\n  static navLang: string | undefined = undefined;\n\n  /**\n   * Translate phrase\n   * example: Lang.tr(\"Hello, [first] [last]\", listOf(\"first\" to \"John\", \"last\" to \"Connor\"))\n   */\n  static tr(key: string, params?: LangParams, langId?: string): string {\n    // actual language\n    const lang = (!langId ? Lang.curLang : langId).toLowerCase();\n    const { dict } = Lang;\n    // find local dictionary\n    let curDict: LocalDict | undefined = dict[lang];\n    if (!curDict) {\n      const k = lang.indexOf(\"-\");\n      if (k >= 0) curDict = dict[lang.substring(0, k)];\n    }\n    const finalDict: LocalDict = curDict ?? Lang.enDict;\n    // find phrase\n    const text = finalDict[key] ?? key;\n    return replaceLangParams({ text, params, langId, tr: Lang.tr });\n  }\n\n  static findPhrase(key: string): string | undefined {\n    return Lang.dict[Lang.curLang]?.[key];\n  }\n\n  private static ruDict: LocalDict = baseDictRu;\n\n  private static enDict: LocalDict = baseDictEn;\n\n  static dict: Record<string, LocalDict> = {\n    en: Lang.enDict,\n    ru: Lang.ruDict,\n  };\n\n  static addDict(globalDictUpdates: Record<string, LocalDict>) {\n    const { dict } = Lang;\n    Object.entries(globalDictUpdates).forEach(([locale, locDict]) => {\n      if (!dict[locale]) {\n        dict[locale] = locDict;\n      } else {\n        dict[locale] = { ...dict[locale], ...locDict };\n      }\n    });\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  Lang.navLang = (\n    navigator.language ||\n    // @ts-ignore\n    navigator.browserLanguage ||\n    // @ts-ignore\n    navigator.userLanguage ||\n    \"en\"\n  ).toLowerCase();\n\n  ifDef(Lang.navLang, (navLang) => {\n    if (navLang in Lang.dict) {\n      Lang.curLang = navLang;\n    } else if (navLang.indexOf(\"-\") >= 0) {\n      const loc = navLang.split(\"-\")[0]!;\n      if (loc in Lang.dict) {\n        Lang.curLang = loc;\n      }\n    }\n  });\n}\n","export const baseDictEn: Record<string, string> = {\n  $Native: \"English\",\n  $English: \"English\",\n  \"Invalid version\":\n    \"Formula requires CharChem version [need] instead of [cur]\",\n  H: \"Hydrogen\",\n  He: \"Helium\",\n  Li: \"Lithium\",\n  Be: \"Beryllium\",\n  B: \"Boron\",\n  C: \"Carbon\",\n  N: \"Nitrogen\",\n  O: \"Oxygen\",\n  F: \"Fluorine\",\n  Ne: \"Neon\",\n  Na: \"Sodium\",\n  Mg: \"Magnesium\",\n  Al: \"Aluminium\",\n  Si: \"Silicon\",\n  P: \"Phosphorus\",\n  S: \"Sulfur\",\n  Cl: \"Chlorine\",\n  Ar: \"Argon\",\n  K: \"Potassium\",\n  Ca: \"Calcium\",\n  Sc: \"Scandium\",\n  Ti: \"Titanium\",\n  V: \"Vanadium\",\n  Cr: \"Chromium\",\n  Mn: \"Manganese\",\n  Fe: \"Iron\",\n  Co: \"Cobalt\",\n  Ni: \"Nickel\",\n  Cu: \"Copper\",\n  Zn: \"Zinc\",\n  Ga: \"Gallium\",\n  Ge: \"Germanium\",\n  As: \"Arsenic\",\n  Se: \"Selenium\",\n  Br: \"Bromine\",\n  Kr: \"Krypton\",\n  Rb: \"Rubidium\",\n  Sr: \"Strontium\",\n  Y: \"Yttrium\",\n  Zr: \"Zirconium\",\n  Nb: \"Niobium\",\n  Mo: \"Molybdenum\",\n  Tc: \"Technetium\",\n  Ru: \"Ruthenium\",\n  Rh: \"Rhodium\",\n  Pd: \"Palladium\",\n  Ag: \"Silver\",\n  Cd: \"Cadmium\",\n  In: \"Indium\",\n  Sn: \"Tin\",\n  Sb: \"Antimony\",\n  Te: \"Tellurium\",\n  I: \"Iodine\",\n  Xe: \"Xenon\",\n  Cs: \"Caesium\",\n  Ba: \"Barium\",\n  La: \"Lanthanum\",\n  Ce: \"Cerium\",\n  Pr: \"Praseodymium\",\n  Nd: \"Neodymium\",\n  Pm: \"Promethium\",\n  Sm: \"Samarium\",\n  Eu: \"Europium\",\n  Gd: \"Gadolinium\",\n  Tb: \"Terbium\",\n  Dy: \"Dysprosium\",\n  Ho: \"Holmium\",\n  Er: \"Erbium\",\n  Tm: \"Thulium\",\n  Yb: \"Ytterbium\",\n  Lu: \"Lutetium\",\n  Hf: \"Hafnium\",\n  Ta: \"Tantalum\",\n  W: \"Tungsten\",\n  Re: \"Rhenium\",\n  Os: \"Osmium\",\n  Ir: \"Iridium\",\n  Pt: \"Platinum\",\n  Au: \"Gold\",\n  Hg: \"Mercury\",\n  Tl: \"Thallium\",\n  Pb: \"Lead\",\n  Bi: \"Bismuth\",\n  Po: \"Polonium\",\n  At: \"Astatine\",\n  Rn: \"Radon\",\n  Fr: \"Francium\",\n  Ra: \"Radium\",\n  Ac: \"Actinium\",\n  Th: \"Thorium\",\n  Pa: \"Protactinium\",\n  U: \"Uranium\",\n  Np: \"Neptunium\",\n  Pu: \"Plutonium\",\n  Am: \"Americium\",\n  Cm: \"Curium\",\n  Bk: \"Berkelium\",\n  Cf: \"Californium\",\n  Es: \"Einsteinium\",\n  Fm: \"Fermium\",\n  Md: \"Mendelevium\",\n  No: \"Nobelium\",\n  Lr: \"Lawrencium\",\n  Rf: \"Rutherfordium\",\n  Db: \"Dubnium\",\n  Sg: \"Seaborgium\",\n  Bh: \"Bohrium\",\n  Hs: \"Hassium\",\n  Mt: \"Meitnerium\",\n  Ds: \"Darmstadtium\",\n  Rg: \"Roentgenium\",\n  Cn: \"Copernicium\",\n  Nh: \"Nihonium\",\n  Fl: \"Flerovium\",\n  Mc: \"Moscovium\",\n  Lv: \"Livermorium\",\n  Ts: \"Tennessine\",\n  Og: \"Oganesson\",\n};\n","export const baseDictRu: Record<string, string> = {\n  $Native: \"Русский\",\n  $English: \"Russian\",\n  // Ошибки\n  \"Internal error: [msg]\": \"Внутренняя ошибка: [msg]\",\n  \"Formula can not be displayed as text\":\n    \"Формулу нельзя отобразить в текстовом виде\",\n  \"Expected '(' after [S]\": \" Требуется '(' после [S]\",\n  \"Unexpected '[C]'\": \"Неверный символ '[C]' в позиции [pos]\",\n  \"Expected '[ok]' instead of '[bad]'\":\n    \"Требуется '[ok]' вместо '[bad]' в позиции [pos]\",\n  \"Invalid character '[C]'\": \"Недопустимый символ '[C]' в позиции [pos]\",\n  \"Russian element character\":\n    \"Недопустимый русский символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\n  \"Non-latin element character\":\n    \"Недопустимый символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\n  \"Unknown element character '[C]'\":\n    \"Недопустимый символ '[C]' описания реагента в позиции [pos]\",\n  \"Expected '[C]'\": \"Требуется '[C]' в позиции [pos]\",\n  \"Unknown element '[Elem]'\": \"Ошибочный элемент '[Elem]' в позиции [pos]\",\n  \"Comment is not closed\": \"Не закрыт комментарий, начатый в позиции [pos]\",\n  \"Abstract coefficient is not closed\":\n    \"Не закрыт абстрактный коэффициент, начатый в позиции [pos]\",\n  \"Abstract element is not closed\":\n    \"Не закрыт абстрактный элемент, начатый в позиции [pos]\",\n  \"Expected node declaration before charge\":\n    \"Неизвестно, к чему нужно применить заряд в позиции [pos]\",\n  \"Invalid charge declaration\": \"Ошибка в описании заряда в позиции [pos]\",\n  \"It is necessary to close the bracket\":\n    \"Необходимо закрыть скобку, открытую в позиции [pos]\",\n  \"Expected variable name\": \"Требуется указать имя переменной в позиции [pos]\",\n  \"Undefined variable [name]\":\n    \"Не определена числовая переменная '[name]' в позиции [pos]\",\n  \"Invalid node reference '[ref]'\":\n    \"Неправильная ссылка на узел '[ref]' в позиции [pos]\",\n  \"Invalid label\": \"Неправильная метка в позиции [pos]\",\n  \"Invalid branch close\":\n    \"Нельзя закрыть ветку в позиции [pos], которая не открыта\",\n  \"Cant close branch before bracket\":\n    \"Нельзя закрыть ветку в позиции [pos], пока не закрыта скобка в позиции [pos0]\",\n  \"Cant close bracket before branch\":\n    \"Нельзя закрыть скобку в позиции [pos], пока не закрыта ветка в позиции [pos0]\",\n  \"Invalid bracket close\": \"Нет пары для скобки, закрытой в позиции [pos]\",\n  \"It is necessary to close the branch\":\n    \"Необходимо закрыть ветку, открытую в позиции [pos]\",\n  \"Expected [must] instead of [have]\":\n    \"Требуется [must] вместо [have] в позиции [pos]\",\n  \"Invalid middle point\": \"Не используется промежуточная точка\",\n  \"Cant create ring\": \"Невозможно создать кольцо\",\n  \"Cant close ring\": \"Невозможно замкнуть кольцо\",\n  \"Invalid version\":\n    \"Для формулы требуется CharChem версии [need] вместо [cur]\",\n  \"Invalid number [n]\": \"Неверное числовое значение [n] в позиции [pos]\",\n\n  \"Periodic Table\": \"Периодическая система химических элементов\",\n  \"Table legend\": \"Группы химических элементов\",\n  Group: \"Группа\",\n  Period: \"Период\",\n  Row: \"Ряд\",\n  \"[x]-block\": \"[x]-блок\",\n  Lanthanides: \"Лантаноиды\",\n  Actinides: \"Актиноиды\",\n  \"Alkali metals\": \"Щелочные металлы\",\n  \"Alkaline earth metals\": \"Щёлочноземельные металлы\",\n  \"Transition metals\": \"Переходные металлы\",\n  \"Post transition metals\": \"Постпереходные металлы\",\n  Metalloids: \"Полуметаллы\",\n  \"Other nonmetals\": \"Неметаллы\",\n  Halogens: \"Галогены\",\n  \"Noble gases\": \"Инертные газы\",\n  \"Unknown props\": \"Св-ва неизвестны\",\n\n  \"(s)\": \"(тв)\",\n  \"(l)\": \"(ж)\",\n  \"(g)\": \"(г)\",\n  \"(aq)\": \"(р-р)\",\n  H: \"Водород\",\n  He: \"Гелий\",\n  Li: \"Литий\",\n  Be: \"Бериллий\",\n  B: \"Бор\",\n  C: \"Углерод\",\n  N: \"Азот\",\n  O: \"Кислород\",\n  F: \"Фтор\",\n  Ne: \"Неон\",\n  Na: \"Натрий\",\n  Mg: \"Магний\",\n  Al: \"Алюминий\",\n  Si: \"Кремний\",\n  P: \"Фосфор\",\n  S: \"Сера\",\n  Cl: \"Хлор\",\n  Ar: \"Аргон\",\n  K: \"Калий\",\n  Ca: \"Кальций\",\n  Sc: \"Скандий\",\n  Ti: \"Титан\",\n  V: \"Ванадий\",\n  Cr: \"Хром\",\n  Mn: \"Марганец\",\n  Fe: \"Железо\",\n  Co: \"Кобальт\",\n  Ni: \"Никель\",\n  Cu: \"Медь\",\n  Zn: \"Цинк\",\n  Ga: \"Галлий\",\n  Ge: \"Германий\",\n  As: \"Мышьяк\",\n  Se: \"Селен\",\n  Br: \"Бром\",\n  Kr: \"Криптон\",\n  Rb: \"Рубидий\",\n  Sr: \"Стронций\",\n  Y: \"Иттрий\",\n  Zr: \"Цирконий\",\n  Nb: \"Ниобий\",\n  Mo: \"Молибден\",\n  Tc: \"Технеций\",\n  Ru: \"Рутений\",\n  Rh: \"Родий\",\n  Pd: \"Палладий\",\n  Ag: \"Серебро\",\n  Cd: \"Кадмий\",\n  In: \"Индий\",\n  Sn: \"Олово\",\n  Sb: \"Сурьма\",\n  Te: \"Теллур\",\n  I: \"Йод\",\n  Xe: \"Ксенон\",\n  Cs: \"Цезий\",\n  Ba: \"Барий\",\n  La: \"Лантан\",\n  Ce: \"Церий\",\n  Pr: \"Празеодим\",\n  Nd: \"Неодим\",\n  Pm: \"Прометий\",\n  Sm: \"Самарий\",\n  Eu: \"Европий\",\n  Gd: \"Гадолиний\",\n  Tb: \"Тербий\",\n  Dy: \"Диспрозий\",\n  Ho: \"Гольмий\",\n  Er: \"Эрбий\",\n  Tm: \"Тулий\",\n  Yb: \"Иттербий\",\n  Lu: \"Лютеций\",\n  Hf: \"Гафний\",\n  Ta: \"Тантал\",\n  W: \"Вольфрам\",\n  Re: \"Рений\",\n  Os: \"Осмий\",\n  Ir: \"Иридий\",\n  Pt: \"Платина\",\n  Au: \"Золото\",\n  Hg: \"Ртуть\",\n  Tl: \"Таллий\",\n  Pb: \"Свинец\",\n  Bi: \"Висмут\",\n  Po: \"Полоний\",\n  At: \"Астат\",\n  Rn: \"Радон\",\n  Fr: \"Франций\",\n  Ra: \"Радий\",\n  Ac: \"Актиний\",\n  Th: \"Торий\",\n  Pa: \"Протактиний\",\n  U: \"Уран\",\n  Np: \"Нептуний\",\n  Pu: \"Плутоний\",\n  Am: \"Америций\",\n  Cm: \"Кюрий\",\n  Bk: \"Берклий\",\n  Cf: \"Калифорний\",\n  Es: \"Эйнштейний\",\n  Fm: \"Фермий\",\n  Md: \"Менделеевий\",\n  No: \"Нобелий\",\n  Lr: \"Лоуренсий\",\n  Rf: \"Резерфордий\",\n  Db: \"Дубний\",\n  Sg: \"Сиборгий\",\n  Bh: \"Борий\",\n  Hs: \"Хассий\",\n  Mt: \"Мейтнерий\",\n  Ds: \"Дармштадтий\",\n  Rg: \"Рентгений\",\n  Cn: \"Коперниций\",\n  Nh: \"Нихоний\",\n  Fl: \"Флеровий\",\n  Mc: \"Московий\",\n  Lv: \"Ливерморий\",\n  Ts: \"Теннессин\",\n  Og: \"Оганесон\",\n};\n","export * from \"./Lang\";\nexport * from \"./LangTypes\";\n","import { ifDef } from \"../utils/ifDef\";\nimport { LangParams } from \"./LangTypes\";\n\ninterface ParamsReplaceLangParams {\n  text: string;\n  params?: LangParams;\n  langId?: string;\n  tr(key: string, params?: LangParams, langId?: string): string;\n}\n\nexport const replaceLangParams = (\n  fnParams: ParamsReplaceLangParams\n): string => {\n  const { text, params, langId, tr } = fnParams;\n  let result = \"\";\n  let pos = 0;\n  const getValue = (key: string) =>\n    ifDef(params?.[key], (value) => String(value)) ?? key;\n  while (pos >= 0) {\n    const begin = text.indexOf(\"[\", pos);\n    if (begin < 0) break;\n    const end = text.indexOf(\"]\", begin);\n    if (end < 0) break;\n    result += text.slice(pos, begin);\n    const key = text.slice(begin + 1, end);\n    // TODO: Пока что укороченный вариант. В дальнейшем возможен вариант со списком параметров после #\n    if (key.endsWith(\"#\")) {\n      const pureKey = key.slice(0, -1);\n      result += tr(getValue(pureKey), {}, langId);\n    } else {\n      result += getValue(key);\n    }\n    pos = end + 1;\n  }\n  return result + text.slice(pos);\n  // return paramsList.reduce(\n  //   (acc, [name, val]) => acc.replace(`[${name}]`, String(val)),\n  //   text\n  // );\n};\n","import { toa } from \"./index\";\nimport { Double } from \"../types\";\nimport { Point } from \"./Point\";\nimport { deg2rad } from \"./radians\";\n\n//              a       b       c       d       e       f\ntype Double6 = [Double, Double, Double, Double, Double, Double];\n\n// eslint-disable-next-line no-shadow\nconst enum Index6 {\n  a,\n  b,\n  c,\n  d,\n  e,\n  f,\n}\n\n/**\n *  ┌ a c e ┐\n *  │ b d f │\n *  └ 0 0 1 ┘\n *\n */\nexport class Matrix2x3 {\n  m: Double6;\n\n  constructor(m?: Double6) {\n    this.m = m ?? [0, 0, 0, 0, 0, 0];\n  }\n\n  clone(): Matrix2x3 {\n    return new Matrix2x3([...this.m]);\n  }\n\n  // Human readable string representation\n  toString() {\n    return this.m.map((value) => toa(value)).join(\" \");\n  }\n\n  // String representation without loss of precision.\n  // Useful for generating css and svg transformation attributes.\n  // Similar to the Python language.\n  repr(divider: string = \" \") {\n    return this.m.join(divider);\n  }\n\n  static createIdentity(): Matrix2x3 {\n    return new Matrix2x3([1, 0, 0, 1, 0, 0]);\n  }\n\n  static createZero(): Matrix2x3 {\n    return new Matrix2x3([0, 0, 0, 0, 0, 0]);\n  }\n\n  translate(pt: Point): void;\n\n  translate(dx: Double, dy: Double): void;\n\n  translate(a: Point | Double, b?: Double) {\n    if (a instanceof Point) {\n      this.m[Index6.e] += a.x;\n      this.m[Index6.f] += a.y;\n    } else if (typeof a === \"number\" && typeof b === \"number\") {\n      this.m[Index6.e] += a;\n      this.m[Index6.f] += b;\n    }\n  }\n\n  moveX(x: Double) {\n    this.m[Index6.e] += x;\n  }\n\n  moveY(y: Double) {\n    this.m[Index6.f] += y;\n  }\n\n  scale(k: Double, ky?: Double) {\n    this.m[Index6.a] *= k;\n    this.m[Index6.d] *= ky ?? k;\n    this.m[Index6.e] *= k;\n    this.m[Index6.f] *= ky ?? k;\n  }\n\n  scaleX(kx: Double) {\n    this.m[Index6.a] *= kx;\n  }\n\n  scaleY(ky: Double) {\n    this.m[Index6.d] *= ky;\n  }\n\n  rotate(radians: Double) {\n    const cosA = Math.cos(radians);\n    const sinA = Math.sin(radians);\n    this.m[Index6.a] = cosA;\n    this.m[Index6.b] = sinA;\n    this.m[Index6.c] = -sinA;\n    this.m[Index6.d] = cosA;\n  }\n\n  rotateDeg(degrees: Double) {\n    this.rotate(deg2rad(degrees));\n  }\n\n  apply(pt: Point): Point {\n    return new Point(\n      this.a * pt.x + this.c * pt.y + this.e,\n      this.b * pt.x + this.d * pt.y + this.f\n    );\n  }\n\n  get a(): Double {\n    return this.m[Index6.a];\n  }\n\n  set a(value: Double) {\n    this.m[Index6.a] = value;\n  }\n\n  get b(): Double {\n    return this.m[Index6.b];\n  }\n\n  set b(value: Double) {\n    this.m[Index6.b] = value;\n  }\n\n  get c(): Double {\n    return this.m[Index6.c];\n  }\n\n  set c(value: Double) {\n    this.m[Index6.c] = value;\n  }\n\n  get d(): Double {\n    return this.m[Index6.d];\n  }\n\n  set d(value: Double) {\n    this.m[Index6.d] = value;\n  }\n\n  get e(): Double {\n    return this.m[Index6.e];\n  }\n\n  set e(value: Double) {\n    this.m[Index6.e] = value;\n  }\n\n  get f(): Double {\n    return this.m[Index6.f];\n  }\n\n  set f(value: Double) {\n    this.m[Index6.f] = value;\n  }\n}\n","import { toa, is0 } from \"./index\";\nimport { Double } from \"../types\";\nimport { deg2rad, rad2deg } from \"./radians\";\n\nexport const pointFromRad = (angle: Double): Point =>\n  new Point(Math.cos(angle), Math.sin(angle));\n\nexport const pointFromDeg = (angle: Double): Point =>\n  pointFromRad(deg2rad(angle));\n\nexport class Point {\n  x: Double;\n\n  y: Double;\n\n  constructor(x: Double = 0.0, y: Double = 0.0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  set(x: Double, y: Double): void {\n    this.x = x;\n    this.y = y;\n  }\n\n  setPt(src: Point): void {\n    this.x = src.x;\n    this.y = src.y;\n  }\n\n  toString(): string {\n    return `(${toa(this.x)}, ${toa(this.y)})`;\n  }\n\n  clone(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  // Operator p == p\n  equals(other: Point): boolean {\n    return is0(this.x - other.x) && is0(this.y - other.y);\n  }\n\n  isZero(): boolean {\n    return is0(this.x) && is0(this.y);\n  }\n\n  // Operator p + p\n  plus(pt: Point): Point {\n    return new Point(this.x + pt.x, this.y + pt.y);\n  }\n\n  add(deltaX: Double, deltaY: Double): this {\n    this.x += deltaX;\n    this.y += deltaY;\n    return this;\n  }\n\n  iadd(pt: Point): this {\n    this.x += pt.x;\n    this.y += pt.y;\n    return this;\n  }\n\n  isub(pt: Point): this {\n    this.x -= pt.x;\n    this.y -= pt.y;\n    return this;\n  }\n\n  // Operator p - p\n  minus(pt: Point): Point {\n    return new Point(this.x - pt.x, this.y - pt.y);\n  }\n\n  neg(): Point {\n    return new Point(-this.x, -this.y);\n  }\n\n  // Operator p * k\n  times(k: Double): Point {\n    return new Point(k * this.x, k * this.y);\n  }\n\n  scale(k: Double): this {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n\n  mini(pt: Point): void {\n    this.x = Math.min(this.x, pt.x);\n    this.y = Math.min(this.y, pt.y);\n  }\n\n  maxi(pt: Point): void {\n    this.x = Math.max(this.x, pt.x);\n    this.y = Math.max(this.y, pt.y);\n  }\n\n  polarAngle(): Double {\n    if (is0(this.x) && is0(this.y)) {\n      return 0.0;\n    }\n    if (is0(this.x)) {\n      return this.y > 0.0 ? Math.PI / 2.0 : -Math.PI / 2.0;\n    }\n    return Math.atan2(this.y, this.x);\n  }\n\n  polarAngleDeg(): Double {\n    return rad2deg(this.polarAngle());\n  }\n\n  // Square of length\n  lengthSqr(): Double {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  length(): Double {\n    return Math.sqrt(this.lengthSqr());\n  }\n\n  distSqr(p: Point): Double {\n    return p.minus(this).lengthSqr();\n  }\n\n  dist(p: Point): Double {\n    return Math.sqrt(this.distSqr(p));\n  }\n\n  normal(): Point {\n    const len = this.length();\n    return is0(len) ? new Point() : this.times(1 / len);\n  }\n\n  transpon(ccw?: boolean): Point {\n    return ccw ? new Point(this.y, -this.x) : new Point(-this.y, this.x);\n  }\n\n  static get zero() {\n    return staticZero;\n  }\n}\n\nconst staticZero = Object.freeze(new Point());\n","import { Int } from \"../types\";\n\n/**\n * rational fraction\n */\nexport class Rational {\n  constructor(public x: Int = 0, public y: Int = 1) {}\n\n  set(value: Int): this {\n    this.x = value;\n    this.y = 1;\n    return this;\n  }\n\n  toString(): string {\n    const { x, y } = this;\n    return y === 1 ? String(x) : `${x}/${y}`;\n  }\n\n  copy(): Rational {\n    return new Rational(this.x, this.y);\n  }\n\n  isZero(): boolean {\n    return this.x === 0;\n  }\n\n  absLess(other: Rational): boolean {\n    // Числитель каждой дроби домножаем на знаменатель другой, чтобы привести обе дроби к общему знаменателю.\n    return Math.abs(this.x) * other.y < Math.abs(other.x) * this.y;\n  }\n\n  sign(): -1 | 0 | 1 {\n    if (this.x < 0) return -1;\n    if (this.x > 0) return 1;\n    return 0;\n  }\n\n  negx(): Rational {\n    return new Rational(-this.x, this.y);\n  }\n\n  absx(): Rational {\n    return new Rational(Math.abs(this.x), this.y);\n  }\n\n  norm(): this {\n    if (this.y < 0) {\n      this.x = -this.x;\n      this.y = -this.y;\n    }\n    if (this.x === 0) {\n      this.y = 1;\n    } else if (this.x < 1 || this.x > 1) {\n      const m = calcAbsMCD(this.x, this.y);\n      this.x /= m;\n      this.y /= m;\n    }\n    return this;\n  }\n\n  addi(v: Int | Rational): this {\n    if (typeof v === \"number\") {\n      // целое число\n      this.x += v * this.y; // v домножается на знаменатель\n    } else {\n      // дробь\n      if (this.y === v.y) {\n        // Если дроби имеют одинаковый знаменатель, то можно просто сложить числители\n        this.x += v.x;\n      } else {\n        // Для приведения к общему знаменателю домножаем числители на чужие знаменатели. А знаменатели друг на друга\n        this.x = this.x * v.y + v.x * this.y;\n        this.y *= v.y;\n      }\n      this.norm();\n    }\n    return this;\n  }\n\n  addx(v: Int | Rational): Rational {\n    return typeof v === \"number\"\n      ? new Rational(this.x + v * this.y, this.y)\n      : this.copy().addi(v);\n  }\n\n  subi(a: Rational): this {\n    // вариант вычитания числа из дроби не нужен.\n    return this.addi(a.negx());\n  }\n\n  subx(a: Rational) {\n    // вариант вычитания числа из дроби не нужен.\n    return a.negx().addi(this);\n  }\n\n  // Умножение на целое число / Умножение на дробь\n  muli(v: Int | Rational): this {\n    if (typeof v === \"number\") {\n      this.x *= v; // при домножении дроби на число меняется только числитель\n    } else {\n      this.x *= v.x;\n      this.y *= v.y;\n    }\n    return this.norm();\n  }\n\n  mulx(v: Int | Rational): Rational {\n    if (typeof v === \"number\") {\n      // при домножении дроби на число меняется только числитель\n      return new Rational(this.x * v, this.y).norm();\n    }\n    const r = new Rational(this.x * v.x, this.y * v.y);\n    return r.norm();\n  }\n\n  // Деление на дробь\n  divi(a: Rational): this {\n    // Деление = умножение на перевёрнутую дробь\n    const { x, y } = a;\n    this.x *= y;\n    this.y *= x;\n    return this.norm();\n  }\n\n  divx(a: Rational): Rational {\n    // Деление = умножение на перевёрнутую дробь\n    const r = new Rational(this.x * a.y, this.y * a.x);\n    return r.norm();\n  }\n}\n\n/**\n * Вычисление наибольшего общего делителя для двух чисел. Знак не имеет значения.\n * @param a\n * @param b\n * @return {number}\n */\nexport const calcAbsMCD = (a: Int, b: Int): Int => {\n  // Минимальное значение (без учёта знака)\n  let m = Math.min(Math.abs(a), Math.abs(b));\n  while (m > 1) {\n    if (a % m === 0 && b % m === 0) break;\n    m--;\n  }\n  return m;\n};\n","/**\n * Rectangle object\n * Created by PeterWin\n * ver 1.1 on 26.04.2017\n * ver 2.0 on 30.05.2022\n */\nimport { Point } from \"./Point\";\nimport { Double } from \"../types\";\nimport { is0, toa } from \"./index\";\n\n/* eslint-disable no-bitwise */\n\nexport class Rect {\n  readonly A: Point;\n\n  readonly B: Point;\n\n  constructor();\n\n  constructor(a: Point, b: Point);\n\n  constructor(ax: Double, ay: Double, bx: Double, by: Double);\n\n  constructor(\n    a?: Point | Double,\n    b?: Point | Double,\n    bx?: Double,\n    by?: Double\n  ) {\n    if (typeof a === \"number\" && typeof b === \"number\") {\n      this.A = new Point(a, b);\n      this.B = new Point(bx, by);\n    } else if (a instanceof Point && b instanceof Point) {\n      this.A = a.clone();\n      this.B = b.clone();\n    } else {\n      this.A = new Point();\n      this.B = new Point();\n    }\n  }\n\n  get left(): Double {\n    return this.A.x;\n  }\n\n  get top(): Double {\n    return this.A.y;\n  }\n\n  get right(): Double {\n    return this.B.x;\n  }\n\n  get bottom(): Double {\n    return this.B.y;\n  }\n\n  get width(): Double {\n    return this.B.x - this.A.x;\n  }\n\n  get height(): Double {\n    return this.B.y - this.A.y;\n  }\n\n  get size(): Point {\n    return new Point(this.width, this.height);\n  }\n\n  get cx(): Double {\n    return this.left + this.width * 0.5;\n  }\n\n  get cy(): Double {\n    return this.top + this.height * 0.5;\n  }\n\n  get center(): Point {\n    return new Point(this.cx, this.cy);\n  }\n\n  toString() {\n    return `{${toa(this.left)}, ${toa(this.top)}, ${toa(this.right)}, ${toa(\n      this.bottom\n    )}}`;\n  }\n\n  isEmpty(): boolean {\n    return is0(this.width) && is0(this.height);\n  }\n\n  clone(): Rect {\n    return new Rect(this.A, this.B);\n  }\n\n  updatePoint(pt: Point) {\n    this.A.x = Math.min(this.A.x, pt.x);\n    this.A.y = Math.min(this.A.y, pt.y);\n    this.B.x = Math.max(this.B.x, pt.x);\n    this.B.y = Math.max(this.B.y, pt.y);\n  }\n\n  unite(rc: Rect): Rect {\n    this.updatePoint(rc.A);\n    this.updatePoint(rc.B);\n    return this;\n  }\n\n  move(delta: Point) {\n    this.A.iadd(delta);\n    this.B.iadd(delta);\n  }\n\n  moveXY(deltaX: Double, deltaY: Double) {\n    this.A.add(deltaX, deltaY);\n    this.B.add(deltaX, deltaY);\n  }\n\n  contains(pt: Point): boolean {\n    return (\n      this.A.x <= pt.x &&\n      this.B.x >= pt.x &&\n      this.A.y <= pt.y &&\n      this.B.y >= pt.y\n    );\n  }\n\n  grow(delta: Double, deltaY?: Double): Rect {\n    const realDeltaY: Double = deltaY ?? delta;\n    this.A.x -= delta;\n    this.B.x += delta;\n    this.A.y -= realDeltaY;\n    this.B.y += realDeltaY;\n    return this;\n  }\n\n  scale(k: Double) {\n    this.A.scale(k);\n    this.B.scale(k);\n  }\n\n  clip(a: Point, b: Point): { inside: boolean; a: Point; b: Point } {\n    let { x: x1, y: y1 } = a;\n    let { x: x2, y: y2 } = b;\n    const { left, right, top, bottom } = this;\n\n    const makeOutcodes = (x: number, y: number): number =>\n      mkMask(0, x < left) |\n      mkMask(1, y < top) |\n      mkMask(2, x > right) |\n      mkMask(3, y > bottom);\n    let ocu1 = makeOutcodes(x1, y1);\n    let ocu2 = makeOutcodes(x2, y2);\n    let inside = (ocu1 | ocu2) === 0;\n    let outside = (ocu1 & ocu2) !== 0;\n    let isSwap = false;\n    while (!outside && !inside) {\n      // swap endpoints if necessary so that (x1,y1) needs to be clipped\n      if (ocu1 === 0) {\n        [x1, x2] = [x2, x1];\n        [y1, y2] = [y2, y1];\n        [ocu1, ocu2] = [ocu2, ocu1];\n        isSwap = !isSwap;\n      }\n      if (isMask(0, ocu1)) {\n        // clip left\n        y1 += ((y2 - y1) * (left - x1)) / (x2 - x1);\n        x1 = left;\n      } else if (isMask(1, ocu1)) {\n        // clip above\n        x1 += ((x2 - x1) * (top - y1)) / (y2 - y1);\n        y1 = top;\n      } else if (isMask(2, ocu1)) {\n        // clip right\n        y1 += ((y2 - y1) * (right - x1)) / (x2 - x1);\n        x1 = right;\n      } else if (isMask(3, ocu1)) {\n        // clip below\n        x1 += ((x2 - x1) * (bottom - y1)) / (y2 - y1);\n        y1 = bottom;\n      }\n      ocu1 = makeOutcodes(x1, y1);\n      inside = (ocu1 | ocu2) === 0; // update\n      outside = (ocu1 & ocu2) !== 0; //  4-bit codes\n    }\n    const p1 = new Point(x1, y1);\n    const p2 = new Point(x2, y2);\n    return { inside, a: isSwap ? p2 : p1, b: isSwap ? p1 : p2 };\n  }\n}\n\nconst mkMask = (pos: 0 | 1 | 2 | 3, val: boolean): number =>\n  val ? 1 << pos : 0;\n\nconst isMask = (pos: 0 | 1 | 2 | 3, code: number): boolean =>\n  !!(code & (1 << pos));\n\nexport const updateRect = (pt: Point, srcRect?: Rect): Rect => {\n  if (!srcRect) return new Rect(pt, pt);\n  srcRect.updatePoint(pt);\n  return srcRect;\n};\n","export const normalize360 = (degAngle: number): number => {\n  const m = degAngle % 360;\n  return m < 0 ? 360 + m : m;\n};\n","import { Double } from \"../types\";\n\nexport const is0 = (value: Double) => Math.abs(value) < 0.001;\n\nexport const isClose = (a: Double, b: Double) => is0(Math.abs(a) - Math.abs(b));\n\nexport const toa = (value: Double): string =>\n  value.toFixed(2).replace(/0+$/g, \"\").replace(/\\.$/, \"\").replace(/^-0$/, \"0\");\n","import { toa } from \"./index\";\nimport { Double } from \"../types\";\n\nexport const roundMass = (mass: Double): Double =>\n  Math.round(mass * 100.0) / 100.0;\n\nexport const strMass = (mass: Double) => toa(roundMass(mass));\n","import { Double } from \"../types\";\n\nexport const rad2deg = (angleInRadians: Double) =>\n  (angleInRadians * 180.0) / Math.PI;\n\nexport const deg2rad = (angleInDegrees: Double) =>\n  (angleInDegrees * Math.PI) / 180.0;\n","import { Figure } from \"../drawSys/figures/Figure\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { Point } from \"../math/Point\";\nimport { ResultBuildNode } from \"./buildNode\";\n\nexport interface NodeInfo {\n  node: ChemNode;\n  res: ResultBuildNode;\n  left?: Figure;\n  right?: Figure;\n}\n\n/**\n * Position of node center relative to owner frame\n */\nexport const getNodeCenterPos = (nodeInfo: NodeInfo): Point =>\n  nodeInfo.res.nodeFrame.org.plus(nodeInfo.res.center);\n\nexport const getNodeInfo = (node: ChemNode, nodesInfo: NodeInfo[]): NodeInfo =>\n  nodesInfo[node.index]!;\n// Предполагается, что все узлы уже включены в nodesInfo. Поэтому результат не может быть undefined\n","import { Double } from \"../types\";\nimport { Rect } from \"../math/Rect\";\n\nexport const applyPadding = (\n  src: Rect,\n  pads: Double[],\n  scale: Double\n): Rect => {\n  if (pads.length === 1) {\n    return src.clone().grow(pads[0]! * scale);\n  }\n  if (pads.length === 2) {\n    return src.clone().grow(pads[1]! * scale, pads[0]! * scale);\n  }\n  if (pads.length === 3) {\n    const top = pads[0]! * scale;\n    const dx = pads[1]! * scale;\n    const bot = pads[2]! * scale;\n    return new Rect(\n      src.left - dx,\n      src.top - top,\n      src.right + dx,\n      src.bottom + bot\n    );\n  }\n  const t = pads[0]! * scale;\n  const r = pads[1]! * scale;\n  const b = pads[2]! * scale;\n  const l = pads[3]! * scale;\n  return new Rect(src.left - l, src.top - t, src.right + r, src.bottom + b);\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\n\nexport const clipLine = (\n  rect: Rect,\n  ptInside: Point,\n  ptOutside: Point\n): Point | undefined => {\n  const { inside, b } = rect.clip(ptInside, ptOutside);\n  return inside ? b : ptInside;\n};\n","import { Double } from \"../../types\";\nimport { Point } from \"../../math/Point\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ResultBuildNode } from \"../buildNode\";\nimport { clipLine } from \"./clipLine\";\nimport { isNodeHidden } from \"../../core/isNodeHidden\";\n\nexport const clipLineByNode = (\n  node: ChemNode,\n  nodeRes: ResultBuildNode,\n  a: Point | undefined,\n  b: Point | undefined,\n  margin: Double\n): Point | undefined => {\n  if (!a || !b) return undefined;\n  const result = a.clone();\n  // if (node.autoMode) return result;\n  // Нет смысла отсекать пустой узел - автоматический или состоящий из пустого коммента или абстрактного элемента\n  if (isNodeHidden(node)) return result;\n  const { nodeFrame, rcNodeCore } = nodeRes;\n  // Нужно перевести координаты отсекающих фигур в координаты агента...\n  const rect = rcNodeCore.clone();\n  rect.grow(margin);\n  rect.move(nodeFrame.org);\n\n  return clipLine(rect, a, b);\n};\n","import { StructAnalyzer } from \"../../core/StructAnalyzer\";\nimport { BondAlign, ChemBond } from \"../../core/ChemBond\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { Point } from \"../../math/Point\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { singleLine } from \"./singleLine\";\n\nconst getAlignSign = (\n  bond: ChemBond,\n  stA: StructAnalyzer,\n  align?: BondAlign\n): 0 | 1 | -1 => {\n  if (!align) {\n    return stA.calcBondSign(bond);\n  }\n  switch (align) {\n    case \"l\":\n      return -1;\n    case \"r\":\n      return 1;\n    default:\n      return 0;\n  }\n};\n\n// Нужно ли делать отступ для внутренней линии, чтобы она была короче внешней\nconst isPadding = (bond: ChemBond, side: number): boolean | undefined => {\n  const node = bond.nodes[side];\n  // Узел должен быть автоматическим и иметь более одной связи\n  return node && node.autoMode && node.bonds.size > 1;\n};\n\ninterface ParamsDoubleBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  imgProps: ChemImgProps;\n  p0: Point;\n  p1: Point;\n  styles: string[];\n  color: string;\n  align?: BondAlign;\n  stA: StructAnalyzer;\n}\n\nexport const doubleBond = ({\n  bond,\n  frame,\n  imgProps,\n  p0,\n  p1,\n  styles,\n  color,\n  align,\n  stA,\n}: ParamsDoubleBond) => {\n  const dir = p1.minus(p0);\n  const d1 = dir.normal();\n  const styleL = styles[0];\n  const styleR = styles[1];\n  const left1 = d1.transpon(true);\n  const right1 = d1.transpon();\n  const wL = getBondStyleWidth(imgProps, styleL);\n  const wR = getBondStyleWidth(imgProps, styleR);\n  let aL;\n  let bL;\n  let aR;\n  let bR: Point;\n  if (align === \"x\") {\n    const { lineSpace2x } = imgProps;\n    const dL = left1.times((wL + lineSpace2x) / 2);\n    const dR = right1.times((wR + lineSpace2x) / 2);\n    aL = p0.plus(dL);\n    aR = p0.plus(dR);\n    bL = p1.plus(dR); // cross left to right\n    bR = p1.plus(dL);\n  } else {\n    const aSign = getAlignSign(bond, stA, align);\n    const { lineSpace2 } = imgProps;\n    let dL;\n    let dR: Point;\n    if (aSign < 0) {\n      dL = left1.times((wL + wR) / 2 + lineSpace2);\n      dR = Point.zero;\n    } else if (aSign > 0) {\n      dL = Point.zero;\n      dR = right1.times((wL + wR) / 2 + lineSpace2);\n    } else {\n      dL = left1.times((wL + lineSpace2) / 2);\n      dR = right1.times((wR + lineSpace2) / 2);\n    }\n    aL = p0.plus(dL);\n    aR = p0.plus(dR);\n    bL = p1.plus(dL);\n    bR = p1.plus(dR);\n    if (isPadding(bond, 0)) {\n      if (aSign < 0) aL.iadd(d1.times(lineSpace2));\n      else if (aSign > 0) aR.iadd(d1.times(lineSpace2));\n    }\n    if (isPadding(bond, 1)) {\n      if (aSign < 0) bL.isub(d1.times(lineSpace2));\n      else if (aSign > 0) bR.isub(d1.times(lineSpace2));\n    }\n  }\n  singleLine(bond, frame, imgProps, aL, bL, styleL, color);\n  singleLine(bond, frame, imgProps, aR, bR, styleR, color);\n};\n","import { Point } from \"../../math/Point\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ResultBuildNode } from \"../buildNode\";\nimport { clipLine } from \"./clipLine\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { getBondColor } from \"./getBondColor\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { drawBondArrow } from \"./drawBondArrow\";\nimport { isNodeHidden } from \"../../core/isNodeHidden\";\n\ninterface ParamsBezierBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  props: ChemImgProps;\n  middlePoints: Point[];\n  res0: ResultBuildNode;\n  res1: ResultBuildNode;\n}\n\nexport const drawBezierBond = ({\n  bond,\n  frame,\n  props,\n  middlePoints,\n  res0,\n  res1,\n}: ParamsBezierBond): void => {\n  const L = Math.min(middlePoints.length - 1, 2);\n  if (L <= 0) return;\n  const { line, lineWidth, nodeMargin } = props;\n  // Подключение первого сегмента\n  const rect0 = res0.rcNodeCore.clone();\n  rect0.move(res0.nodeFrame.org);\n  if (bond.nodes[0] && !isNodeHidden(bond.nodes[0])) rect0.grow(nodeMargin);\n  const c0 = res0.center.plus(res0.nodeFrame.org);\n  const rect1 = res1.rcNodeCore.clone();\n  rect1.move(res1.nodeFrame.org);\n  if (bond.nodes[1] && !isNodeHidden(bond.nodes[1])) rect1.grow(nodeMargin);\n  const c1 = res1.center.plus(res1.nodeFrame.org);\n  let prev = c0;\n  const wPoints = middlePoints.slice(0, L).map((vpt) => {\n    const wpt = vpt.times(line).plus(prev);\n    prev = wpt;\n    return wpt;\n  });\n  const p0 = clipLine(rect0, c0, wPoints[0]!);\n  if (!p0) return;\n  const p1 = clipLine(rect1, c1, wPoints[L - 1]!);\n  if (!p1) return;\n\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: p0 },\n    L === 1\n      ? { cmd: \"Q\", cp: wPoints[0]!, pt: p1 }\n      : { cmd: \"C\", cp1: wPoints[0]!, cp2: wPoints[1]!, pt: p1 },\n  ];\n  const color = getBondColor(bond, props);\n  const fig = new FigPath(segs, { stroke: color, strokeWidth: lineWidth });\n  fig.update();\n  frame.addFigure(fig, true);\n  if (bond.arr0) {\n    drawBondArrow(frame, props, wPoints[0]!, p0, color);\n  }\n  if (bond.arr1) {\n    drawBondArrow(frame, props, wPoints[L - 1]!, p1, color);\n  }\n};\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { drawBondAB } from \"./drawBondAB\";\nimport { Point } from \"../../math/Point\";\nimport { clipLineByNode } from \"./clipLineByNode\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { drawBondPoly } from \"./drawBondPoly\";\nimport { StructAnalyzer } from \"../../core/StructAnalyzer\";\nimport { drawBezierBond } from \"./drawBezierBond\";\n\ninterface ParamsDrawBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  props: ChemImgProps;\n  nodesInfo: NodeInfo[];\n  stA: StructAnalyzer;\n}\n\nexport const drawBond = ({\n  bond,\n  props,\n  frame,\n  nodesInfo,\n  stA,\n}: ParamsDrawBond) => {\n  if (!bond.isVisible()) return;\n  const { nodeMargin } = props;\n  if (bond.nodes.length !== 2) {\n    drawBondPoly(bond, frame, props, nodesInfo);\n    return;\n  }\n  // bond between 2 nodes\n  const [node0, node1] = bond.nodes;\n  if (!node0 || !node1) return;\n  const { res: res0 } = getNodeInfo(node0, nodesInfo);\n  const { res: res1 } = getNodeInfo(node1, nodesInfo);\n  let bondA: Point | undefined = res0.nodeFrame.org.plus(res0.center);\n  const { middlePoints } = bond;\n  if (middlePoints && middlePoints.length > 0) {\n    drawBezierBond({ bond, frame, props, middlePoints, res0, res1 });\n    return;\n  }\n  let bondB: Point | undefined = res1.nodeFrame.org.plus(res1.center);\n  bondA = clipLineByNode(node0, res0, bondA, bondB, nodeMargin);\n  if (!bondA) return;\n  bondB = clipLineByNode(node1, res1, bondB, bondA, nodeMargin);\n  if (!bondB) return;\n  drawBondAB({\n    bond,\n    bondA,\n    bondB,\n    frame,\n    imgProps: props,\n    stA,\n  });\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { Point } from \"../../math/Point\";\nimport { getBondColor } from \"./getBondColor\";\nimport { tripleBond } from \"./tripleBond\";\nimport { singleLine } from \"./singleLine\";\nimport { doubleBond } from \"./doubleBond\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { wedgeBond } from \"./wedgeBond\";\nimport { drawBondArrow } from \"./drawBondArrow\";\nimport { StructAnalyzer } from \"../../core/StructAnalyzer\";\n\ninterface ParamsDrawBondAB {\n  bond: ChemBond;\n  bondA: Point;\n  bondB: Point;\n  imgProps: ChemImgProps;\n  frame: FigFrame;\n  stA: StructAnalyzer;\n}\n\nexport const drawBondAB = ({\n  bond,\n  bondA,\n  bondB,\n  imgProps,\n  frame,\n  stA,\n}: ParamsDrawBondAB) => {\n  const { n, style, w0, w1 } = bond;\n  const color = getBondColor(bond, imgProps);\n  let fig: Figure | undefined;\n  if (!w0 && w1 === 1) {\n    fig = wedgeBond(bondA, bondB, imgProps, color, false);\n  } else if (w0 === 1 && !w1) {\n    fig = wedgeBond(bondB, bondA, imgProps, color, false);\n  } else if (!w0 && w1 === -1) {\n    fig = wedgeBond(bondA, bondB, imgProps, color, true);\n  } else if (w0 === -1 && !w1) {\n    fig = wedgeBond(bondB, bondA, imgProps, color, true);\n  }\n  if (fig) {\n    fig.update();\n    frame.addFigure(fig);\n    return;\n  }\n  const stList: string[] = style ? Array.from(style) : new Array(n).fill(\"|\");\n  stList.reverse();\n  if (stList.length === 1 && bond.w0 === 1 && bond.w1 === 1) {\n    stList[0] = \"I\";\n  }\n  switch (stList.length) {\n    case 1:\n      singleLine(bond, frame, imgProps, bondA, bondB, stList[0], color);\n      if (bond.arr1) drawBondArrow(frame, imgProps, bondA, bondB, color);\n      if (bond.arr0) drawBondArrow(frame, imgProps, bondB, bondA, color);\n      break;\n    case 2:\n      doubleBond({\n        bond,\n        frame,\n        imgProps,\n        p0: bondA,\n        p1: bondB,\n        styles: stList,\n        color,\n        align: bond.align,\n        stA,\n      });\n      break;\n    case 3:\n      tripleBond(bond, frame, imgProps, bondA, bondB, stList, color);\n      break;\n    default:\n      break;\n  }\n};\n","import { Point } from \"../../math/Point\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\n\nexport const drawBondArrow = (\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  color: string\n) => {\n  const { arrowL, arrowD, lineWidth } = imgProps;\n  const n = a.minus(b).normal();\n  const c = b.plus(n.times(arrowL));\n  const cL = c.plus(n.transpon(true).times(arrowD));\n  const cR = c.plus(n.transpon().times(arrowD));\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: cR },\n    { cmd: \"L\", pt: b },\n    { cmd: \"L\", pt: cL },\n  ];\n  const style: PathStyle = {\n    stroke: color,\n    strokeWidth: lineWidth,\n  };\n  const fig = new FigPath(segs, style);\n  fig.update();\n  frame.addFigure(fig, true);\n};\n","import { Point } from \"../../math/Point\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { getBondColor } from \"./getBondColor\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigBSpline } from \"../../drawSys/figures/FigBSpline\";\n\nconst calcCenter = (wPoints: Point[]): Point =>\n  wPoints\n    .reduce((sum, wpt) => sum.iadd(wpt), new Point())\n    .scale(1 / wPoints.length);\n\nexport const drawBondPoly = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  nodesInfo: NodeInfo[]\n): void => {\n  const color = getBondColor(bond, imgProps);\n  const { lineWidth, dash } = imgProps;\n  const { nodes } = bond;\n  const wPoints = nodes\n    .filter((n) => !!n)\n    .map((n) => getNodeCenterPos(getNodeInfo(n!, nodesInfo)));\n  if (wPoints.length < 2) return;\n  const center = calcCenter(wPoints);\n  const style: PathStyle = { stroke: color, strokeWidth: lineWidth };\n  if (bond.ext === \"o\") {\n    const p0 = wPoints[0]!;\n    const p1 = wPoints[1]!;\n    const v = p0.plus(p1).times(0.5);\n    const r = center.minus(v).length() * 0.7;\n    const fig = new FigEllipse(center, new Point(r, r), style);\n    frame.addFigure(fig);\n  } else if (bond.ext === \"s\") {\n    //= ==== Связь, объединяющая несколько узлов при помощи Би-сплайна\n    let i = 0;\n    let n = wPoints.length;\n    if (!bond.isCycle) {\n      // не циклический вариант\n      // Линия выходит из концов и проходит на некотором расстоянии от остальных точек, смещаясь к центру\n      i++;\n      n--;\n    }\n    for (; i < n; i++) {\n      const p = wPoints[i]!;\n      const d = center.minus(p);\n      p.iadd(d.times(0.2));\n    }\n    // const segs: PathSeg[] = wPoints.map((pt, i) => ({cmd: i>0 ? \"L\":\"M\", pt}))\n    // if (bond.isCycle) segs.push({cmd:\"Z\"});\n    // const fig = new FigPath(segs, style);\n    const bPoints = FigBSpline.extendsPoints(wPoints, bond.isCycle);\n    if (bPoints) {\n      const fig = new FigBSpline(bPoints, style, dash, bond.style === \":\");\n      frame.addFigure(fig);\n    }\n  }\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const getBondColor = (bond: ChemBond, imgProps: ChemImgProps): string =>\n  bond.color ?? imgProps.stdStyle.style.fill;\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\n\nexport const getBondStyleWidth = (\n  imgProps: ChemImgProps,\n  styleDef?: string\n): number => (styleDef === \"I\" ? imgProps.thickWidth : imgProps.lineWidth);\n","import { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Point } from \"../../math/Point\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { FigHashTrapezoid } from \"../../drawSys/figures/FigHashTrapezoid\";\n\nexport const singleLine = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  style: string | undefined,\n  color: string\n) => {\n  const lnStyle: PathStyle = {\n    stroke: color,\n    strokeWidth: getBondStyleWidth(imgProps, style),\n    cap: \"round\",\n  };\n  let fig: Figure | undefined;\n  if (style === \"~\") {\n    fig = drawWaveLine(bond, a, b, imgProps, lnStyle);\n  } else if (style === \":\") {\n    fig = drawDashedLine(a, b, imgProps, lnStyle);\n  } else if (bond.w0 < 0 && bond.w0 === bond.w1) {\n    const { thickWidth, lineWidth, hatch } = imgProps;\n    fig = new FigHashTrapezoid(\n      a,\n      thickWidth,\n      b,\n      thickWidth,\n      color,\n      lineWidth,\n      hatch\n    );\n    fig.update();\n  }\n  if (!fig) {\n    const segs: PathSeg[] = [\n      { cmd: \"M\", rel: false, pt: a },\n      { cmd: \"L\", rel: false, pt: b },\n    ];\n    fig = new FigPath(segs, lnStyle);\n    fig.update();\n  }\n  frame.addFigure(fig);\n};\n\nconst drawWaveLine = (\n  bond: ChemBond,\n  p0: Point,\n  p1: Point,\n  imgProps: ChemImgProps,\n  style: PathStyle\n) => {\n  const srcSpace = !!bond.arr0;\n  const dstSpace = !!bond.arr1;\n  const { line, arrowL } = imgProps;\n  const ampl = line / 8;\n  const step = line / 6;\n  const arrLen = arrowL * 1.4; // Если стрелка впритык к изгибу, это выглядит плохо\n\n  const dir = p1.minus(p0);\n  let len = dir.length();\n  const d1 = dir.normal();\n  if (srcSpace) len -= arrLen;\n  if (dstSpace) len -= arrLen;\n  if (len < step) return undefined;\n  const wp0 = srcSpace ? p0.plus(d1.times(arrLen)) : p0;\n  const wp1 = dstSpace ? p1.minus(d1.times(arrLen)) : p1;\n\n  const nSegs = Math.floor((len + step / 2) / step);\n  const vAmp = d1.times(ampl);\n  const segDir = wp1.minus(wp0).times(1 / nSegs);\n  const segs: PathSeg[] = [{ cmd: \"M\", pt: p0 }];\n  if (srcSpace) segs.push({ cmd: \"L\", pt: wp0 });\n  let a: Point = wp0;\n  for (let k = 0; k < nSegs; k++) {\n    const pt = a.plus(segDir);\n    const cp1 = a.plus(\n      // eslint-disable-next-line no-bitwise\n      (k & 1) === 0 ? new Point(vAmp.y, -vAmp.x) : new Point(-vAmp.y, vAmp.x)\n    );\n    const cp2 = cp1.plus(segDir);\n    segs.push({ cmd: \"C\", cp1, cp2, pt });\n    a = pt;\n  }\n  if (dstSpace) segs.push({ cmd: \"L\", pt: p1 });\n  const fig = new FigPath(segs, style);\n  fig.update();\n  return fig;\n};\n\nconst drawDashedLine = (\n  p0: Point,\n  p1: Point,\n  imgProps: ChemImgProps,\n  style: PathStyle\n) => {\n  // Общее число отрезков: n. Число всегда нечётное.\n  const dir = p1.minus(p0);\n  const len = dir.length();\n  const { dash } = imgProps;\n  if (len < dash * 2) {\n    // Отрезок слишком короткий, чтобы выводиться прерывистой линией\n    return undefined;\n  }\n  let n = Math.floor(len / dash);\n  // eslint-disable-next-line no-bitwise\n  if (!(n & 1)) n++;\n  const segLen = len / n;\n  const segs: PathSeg[] = [{ cmd: \"M\", pt: p0 }];\n  for (let i = 0; i < n; i++) {\n    const pt = dir.times(((i + 1) * segLen) / len).iadd(p0);\n    // eslint-disable-next-line no-bitwise\n    segs.push({ cmd: (i & 1) === 0 ? \"L\" : \"M\", pt });\n  }\n  const fig = new FigPath(segs, style);\n  fig.update();\n  return fig;\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Point } from \"../../math/Point\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const softBondTemplate = (\n  bond: ChemBond,\n  imgProps: ChemImgProps,\n  src: Point\n) => {\n  const vDir = bond.dir ?? new Point(1, 0);\n  const sign = vDir.x < 0 ? -1 : 1;\n  // Если связь слишком короткая, то использовать близкое соединение без полей. Как будто два узла сливаются в один.\n  const isClose = Math.abs(vDir.x) < 0.1;\n  const dir = isClose\n    ? vDir\n    : new Point(vDir.x * imgProps.horizLine, vDir.y * imgProps.line);\n  const field = isClose ? Point.zero : new Point(sign * imgProps.nodeMargin, 0);\n  const bondA = src.plus(field);\n  const bondB = bondA.plus(dir);\n  const dst = bondB.plus(field);\n  return { src, dst, bondA, bondB, sign };\n};\n","import { Point } from \"../../math/Point\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { singleLine } from \"./singleLine\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const tripleBond = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  styles: string[],\n  color: string\n) => {\n  //   left = style#0\n  //   |\n  //   a********************>b\n  //   |\n  //   right = style#2\n  const dir = b.minus(a);\n  const d1 = dir.normal();\n  const { lineSpace3 } = imgProps;\n  const styleLeft = styles[0];\n  const styleCenter = styles[1];\n  const styleRight = styles[2];\n  const wL = getBondStyleWidth(imgProps, styleLeft);\n  const wC = getBondStyleWidth(imgProps, styleCenter);\n  const wR = getBondStyleWidth(imgProps, styleRight);\n  const left1 = d1.transpon(true).times(lineSpace3 + (wL + wC) / 2);\n  const right1 = d1.transpon().times(lineSpace3 + (wR + wC) / 2);\n  singleLine(\n    bond,\n    frame,\n    imgProps,\n    a.plus(left1),\n    b.plus(left1),\n    styleLeft,\n    color\n  );\n  singleLine(bond, frame, imgProps, a, b, styleCenter, color);\n  singleLine(\n    bond,\n    frame,\n    imgProps,\n    a.plus(right1),\n    b.plus(right1),\n    styleRight,\n    color\n  );\n};\n","import { FigHashTrapezoid } from \"../../drawSys/figures/FigHashTrapezoid\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { Point } from \"../../math/Point\";\n\nexport const wedgeBond = (\n  src: Point,\n  dst: Point,\n  imgProps: ChemImgProps,\n  color: string,\n  hash: boolean\n): Figure => {\n  const { chiralWidth, lineWidth, hatch } = imgProps;\n  if (hash) {\n    return new FigHashTrapezoid(\n      src,\n      lineWidth,\n      dst,\n      chiralWidth,\n      color,\n      lineWidth,\n      hatch\n    );\n  }\n  const d1 = dst.minus(src).normal();\n  const left = d1.transpon(true).times(chiralWidth / 2);\n  const right = d1.transpon().times(chiralWidth / 2);\n  const b = dst.plus(left);\n  const c = dst.plus(right);\n  const left0 = d1.transpon(true).times(lineWidth / 2);\n  const right0 = d1.transpon().times(lineWidth / 2);\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: src.plus(left0) },\n    { cmd: \"L\", pt: b },\n    { cmd: \"L\", pt: c },\n    { cmd: \"L\", pt: src.plus(right0) },\n    { cmd: \"Z\" },\n  ];\n  return new FigPath(segs, {\n    fill: color,\n    cap: \"round\",\n    strokeWidth: lineWidth,\n  });\n};\n","import { PAgentCtx } from \"./PAgentCtx\";\n\nexport class AgentCmd {\n  srcCmd?: AgentCmd;\n\n  dstCmd?: AgentCmd;\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  canPush(ctx: PAgentCtx): boolean {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars, class-methods-use-this\n  postExec(ctx: PAgentCtx): void {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars, class-methods-use-this\n  onPrevious(cmd: AgentCmd, ctx: PAgentCtx): void {}\n}\n","import { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { processBrackets } from \"./brackets/processBrackets\";\n\nexport class AgentCmdBrClose extends AgentCmd {\n  figure?: Figure;\n\n  isRealText?: boolean;\n\n  constructor(public readonly end: ChemBracketEnd) {\n    super();\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    // )]\n    if (cmd instanceof AgentCmdBrClose) {\n      this.srcCmd = cmd;\n    }\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    let isCanUnwindNext = true;\n    unwind(ctx, (cmd) => {\n      if (isCanUnwindNext && cmd instanceof AgentCmdBrOpen) {\n        processBrackets(ctx, cmd, this);\n        isCanUnwindNext = false;\n        return true;\n      }\n      return isCanUnwindNext;\n    });\n    return false;\n  }\n}\n","import { Figure } from \"../../drawSys/figures/Figure\";\nimport { ChemBracketBegin } from \"../../core/ChemBracket\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { AgentCmdNode } from \"./AgentCmdNode\";\n\nexport class AgentCmdBrOpen extends AgentCmd {\n  isBridge: boolean = false;\n\n  prevBracket?: AgentCmdBrClose;\n\n  prevText?: boolean;\n\n  figure?: Figure;\n\n  constructor(public readonly begin: ChemBracketBegin) {\n    super();\n  }\n\n  checkRtl(ctx: PAgentCtx, rtlNode?: ChemNode) {\n    ifDef(rtlNode, (it) => {\n      ctx.rtlNodes.add(it.index);\n      ifDef(this.begin?.end?.nodes[0], (endNode) =>\n        ctx.rtlNodes.add(endNode.index)\n      );\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override canPush(ctx: PAgentCtx) {\n    this.checkRtl(\n      ctx,\n      ifDef(this.begin.bond, (bond) =>\n        ifDef(bond.dir, (dir) => (dir.x < 0 ? bond.nodes[1] : undefined))\n      )\n    );\n    return true;\n  }\n\n  override onPrevious(cmd: AgentCmd, ctx: PAgentCtx): void {\n    // Если перед началом скобки стоит мост или любая скобка,\n    // То предыдущая команда должна на выходе стыковаться с текущей на входе\n    // -(, [(, ](\n    if (cmd instanceof AgentCmdBridge || cmd instanceof AgentCmdBrOpen) {\n      // eslint-disable-next-line no-param-reassign\n      cmd.dstCmd = this;\n      this.srcCmd = cmd;\n    } else if (cmd instanceof AgentCmdBrClose) {\n      // eslint-disable-next-line prefer-destructuring\n      this.begin.nodes[0] = cmd.end.nodes[0];\n\n      ifDef(this.begin.nodes[0], (beginNode) => {\n        if (ctx.rtlNodes.has(beginNode.index)) {\n          this.checkRtl(ctx, beginNode);\n        }\n      });\n      this.isBridge = true;\n      this.prevBracket = cmd;\n    } else {\n      if (cmd instanceof AgentCmdNode) {\n        this.prevText = true;\n        // Если у узла одна связь, то проверить направление\n        const { node } = cmd;\n        if (node.bonds.size === 1) {\n          const nodeBond = Array.from(node.bonds)[0]!;\n          ifDef(nodeBond.dir, (dir) => {\n            if (dir.x < 0) this.checkRtl(ctx, node);\n          });\n        }\n      }\n      const [n1, n2] = this.begin.nodes;\n      if (n1?.subChain !== n2?.subChain) {\n        this.isBridge = true;\n      }\n    }\n  }\n}\n","import { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\n\nexport class AgentCmdBridge extends AgentCmd {\n  override onPrevious(cmd: AgentCmd): void {\n    if (cmd instanceof AgentCmdBrClose) {\n      // ]-\n      this.srcCmd = cmd;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override canPush(ctx: PAgentCtx): boolean {\n    unwind(ctx, (cmd: AgentCmd) => cmd instanceof AgentCmdBridge);\n    return true;\n  }\n}\n","import { ChemMul } from \"../../core/ChemMul\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { createCoeff } from \"./createCoeff\";\nimport { AgentCmdMulBridge } from \"./AgentCmdMulBridge\";\n\nexport const createAgentCmdMul = (mul: ChemMul): AgentCmd =>\n  mul.isFirst ? new AgentCmdMul(mul) : new AgentCmdMulBridge(mul);\n\nexport class AgentCmdMul extends AgentCmd {\n  figure?: FigText;\n\n  constructor(public readonly mul: ChemMul) {\n    super();\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    // множитель внутри скобок. Н.р [2H2O] - это формула для теста, но не имеет практического смысла.\n    // Команды: brBegin, mulBegin, Node, mulEnd, brEnd\n    // Более правдоподобный случай ['n'FeO*'m'Fe2O3*'k'H2O]\n    // Ситуация редкая, но без скобок первый коэффициент применяется не к первому узлу, а ко всему выражению\n    // TODO: Возможно, анализ ситуации перенести в компилятор\n    if (cmd instanceof AgentCmdBrOpen) {\n      const { begin } = cmd;\n      if (!begin.nodes[1]) {\n        // eslint-disable-next-line prefer-destructuring\n        begin.nodes[1] = this.mul.nodes[1];\n      }\n      // eslint-disable-next-line no-param-reassign\n      cmd.dstCmd = this;\n    }\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    const dstNode = this.mul.nodes[1];\n    const { n } = this.mul;\n    if (dstNode && n.isSpecified()) {\n      const ni = getNodeInfo(dstNode, ctx.nodesInfo);\n      const { cluster } = ctx.clusters.findByNode(dstNode);\n      const { frame } = cluster;\n      const figK = createCoeff(this.mul, ctx.props);\n      figK.org.set(\n        frame.bounds.left - figK.bounds.width,\n        ni.res.rcNodeCore.bottom + ni.res.nodeFrame.org.y\n      );\n      frame.addFigure(figK, true);\n      this.figure = figK;\n    }\n    return false;\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  override postExec(): void {}\n}\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { createCoeff } from \"./createCoeff\";\nimport { Point } from \"../../math/Point\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { drawMul } from \"./drawMul\";\n\nexport class AgentCmdMulBridge extends AgentCmdBridge {\n  constructor(public readonly mul: ChemMul) {\n    super();\n  }\n\n  override postExec(ctx: PAgentCtx): void {\n    const { mul } = this;\n    const { props } = ctx;\n    let [srcNode] = mul.nodes;\n    const dstNode = mul.nodes[1];\n    let isPrevBox = false;\n    if (!srcNode && this.srcCmd instanceof AgentCmdBrClose) {\n      // Такая ситуация возникает, если перед множителем закрывается скобка [K]*H\n      [srcNode] = this.srcCmd.end.nodes;\n      isPrevBox = true;\n    }\n    const isNextBox = this.dstCmd instanceof AgentCmdBrOpen;\n    if (!srcNode || !dstNode) return;\n    const bridgeFrame = new FigFrame();\n    const { font: mFont, style: mStyle } = props.getStyleColored(\n      \"multiplier\",\n      mul.color\n    );\n    const mFields = props.line * 0.2;\n    const figMul = drawMul(props, mFont, mStyle);\n    figMul.org.x += mFields;\n    bridgeFrame.addFigure(figMul, true);\n    if (mul.n.isSpecified()) {\n      const figK = createCoeff(mul, props);\n      figK.org.set(bridgeFrame.bounds.right + mFields, 0);\n      bridgeFrame.addFigure(figK, true);\n    } else {\n      bridgeFrame.bounds.B.x += mFields;\n    }\n    const { cluster, srcConn } = ctx.clusters.unite(\n      ctx,\n      { node: srcNode!, allBox: isPrevBox },\n      { node: dstNode!, allBox: isNextBox },\n      new Point(bridgeFrame.bounds.right, 0)\n    );\n    let y = srcConn.yBase;\n    if (y === undefined) {\n      // Такая ситуация возможна если перед множителем пустой узел.\n      // Например, гидрохлорид с нетекстовой левой частью: C-{}*5HCl\n      y = srcConn.yMiddle + mFont.getFontFace().ascent / 2;\n    }\n    bridgeFrame.org.set(srcConn.x, y);\n    cluster.frame.addFigure(bridgeFrame, true);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { makeBridge } from \"./brackets/processBrackets\";\n\nexport class AgentCmdNode extends AgentCmd {\n  prevBracket?: AgentCmdBrClose;\n\n  constructor(public readonly node: ChemNode) {\n    super();\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    const { prevBracket } = this;\n    if (prevBracket) {\n      const br = prevBracket.end;\n      if (br) {\n        const n0 = br.nodes[0];\n        const step = new Point();\n        if (n0) {\n          const ni0 = getNodeInfo(n0, ctx.nodesInfo);\n          step.y = ni0.res.nodeFrame.org.y + ni0.res.center.y;\n        }\n        const isBothText = !!prevBracket.isRealText;\n        makeBridge(ctx, br, true, isBothText);\n      }\n    }\n    return false;\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    if (cmd instanceof AgentCmdBrClose) {\n      this.prevBracket = cmd;\n    }\n  }\n}\n","import { ifDef } from \"../../utils/ifDef\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { Point } from \"../../math/Point\";\nimport { drawBondAB } from \"../bond/drawBondAB\";\nimport { softBondTemplate } from \"../bond/softBondTemplate\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport class AgentCmdSoftBond extends AgentCmdBridge {\n  constructor(\n    public readonly bond: ChemBond,\n    public readonly agent: ChemAgent\n  ) {\n    super();\n  }\n\n  override postExec(ctx: PAgentCtx): void {\n    const {\n      bond,\n      agent: { stA },\n    } = this;\n    const imgProps = ctx.props;\n    const { src, dst, bondA, bondB } = softBondTemplate(\n      bond,\n      ctx.props,\n      Point.zero\n    );\n    const [srcNode, dstNode] = this.bond.nodes;\n    const step = dst.minus(src);\n    const { cluster, srcConn, dstConn, srcNodeInfo, dstNodeInfo } =\n      ctx.clusters.unite(\n        ctx,\n        { node: srcNode!, allBox: !!this.srcCmd },\n        { node: dstNode!, allBox: !!this.dstCmd },\n        step\n      );\n    if (bond.isVisible()) {\n      const y =\n        ifDef(srcConn.yBase, (srcBase) =>\n          ifDef(dstConn.yBase, () => {\n            if (!srcNodeInfo || !dstNodeInfo) return undefined;\n            const srcH = srcNodeInfo.res.rcNodeCore.height ?? 0;\n            const dstH = dstNodeInfo.res.rcNodeCore.height ?? 0;\n            return srcBase - Math.min(srcH / 2, dstH / 2);\n          })\n        ) ?? srcConn.yMiddle;\n      const connPt = new Point(srcConn.x, y);\n      bondA.iadd(connPt);\n      bondB.iadd(connPt);\n      drawBondAB({ bond, bondA, bondB, frame: cluster.frame, imgProps, stA });\n    }\n  }\n}\n","import { ChemNode } from \"../../core/ChemNode\";\nimport { getItemForced } from \"../../utils/getItemForced\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { Point } from \"../../math/Point\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { Rect } from \"../../math/Rect\";\nimport { addAllSet } from \"../../utils/addAllSet\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport interface Cluster {\n  frame: FigFrame;\n  nodes: Set<number>;\n  contentRect?: Rect;\n}\n\nexport const insertToCluster = (\n  cluster: Cluster,\n  node: ChemNode,\n  nodesInfo: NodeInfo[]\n) => {\n  const { frame, nodes } = cluster;\n  nodes.add(node.index);\n  const { res } = getNodeInfo(node, nodesInfo);\n  frame.addFigure(res.nodeFrame, true);\n};\n\ninterface ClusterConnection {\n  x: number;\n  yMiddle: number;\n  yBase?: number;\n}\n\nconst getClusterBoxConnection = (\n  cluster: Cluster,\n  isLeft: boolean\n): ClusterConnection => {\n  const { bounds } = cluster.frame;\n  return {\n    x: isLeft ? bounds.left : bounds.right,\n    yMiddle: (bounds.top + bounds.bottom) / 2,\n  };\n};\n\nexport const getClusterConnection = (\n  allBox: boolean,\n  cluster: Cluster,\n  nodeInfo: NodeInfo,\n  isLeft: boolean\n): ClusterConnection => {\n  const { res } = nodeInfo;\n  let rcNode: Rect | undefined;\n  let x: number | undefined;\n  let yBase: number | undefined;\n  let yMiddle;\n  const { nodeFrame, rcNodeCore } = res;\n  if (rcNodeCore.isEmpty()) {\n    yMiddle = nodeFrame.org.y;\n  } else {\n    rcNode = rcNodeCore.clone();\n    // Верхняя и нижняя границы идут от внутренней рамки\n    // Левая и правая границы идут от фрейма узла, т.к. индексы и заряды не входят в rcNodeCore\n    rcNode.A.x = nodeFrame.bounds.left;\n    rcNode.B.x = nodeFrame.bounds.right;\n    rcNode.move(nodeFrame.org);\n    yBase = rcNode.bottom;\n    yMiddle = yBase - rcNode.height / 2;\n    x = isLeft ? rcNode.left : rcNode.right;\n  }\n\n  if (allBox) {\n    const { bounds } = cluster.frame;\n    x = isLeft ? bounds.left : bounds.right;\n  } else if (x === undefined) {\n    x = getNodeCenterPos(nodeInfo).x;\n  }\n  if (isLeft) {\n    ifDef(nodeInfo.left, (it) => {\n      x = it.getRelativeBounds().left;\n    });\n  } else {\n    ifDef(nodeInfo.right, (it) => {\n      x = it.getRelativeBounds().right;\n    });\n  }\n  return { x, yMiddle, yBase };\n};\n\nconst isBothBaseline = (\n  srcConn: ClusterConnection,\n  dstConn: ClusterConnection\n) => srcConn.yBase !== undefined && dstConn.yBase !== undefined;\n\nexport const calcOffset = (\n  srcConn: ClusterConnection,\n  dstConn: ClusterConnection,\n  step: Point\n) =>\n  new Point(\n    srcConn.x - dstConn.x + step.x,\n    (isBothBaseline(srcConn, dstConn)\n      ? srcConn.yBase! - dstConn.yBase!\n      : srcConn.yMiddle - dstConn.yMiddle) + step.y\n  );\n\nexport const calcOffsetAbs = (c0: Cluster, c1: Cluster, step: Point): Point => {\n  const dx =\n    step.x >= 0\n      ? c0.frame.bounds.right - c1.frame.bounds.left\n      : c0.frame.bounds.left - c1.frame.bounds.right;\n  return new Point(dx + step.x, step.y);\n};\n\nexport const mergeClusters = (\n  srcCluster: Cluster,\n  dstCluster: Cluster,\n  offset: Point\n): void => {\n  addAllSet(srcCluster.nodes, dstCluster.nodes);\n  dstCluster.frame.figures.forEach((fig) => {\n    fig.org.iadd(offset);\n    srcCluster.frame.addFigure(fig, true);\n  });\n};\n\ninterface Connector {\n  node: ChemNode;\n  allBox: boolean;\n}\n\ninterface FindResult {\n  clusterIndex: number;\n  cluster: Cluster;\n}\n\nexport class Clusters {\n  clusters: Cluster[] = [];\n\n  init(nodes: ChemNode[], nodesInfo: NodeInfo[]) {\n    const dict: Record<number, Cluster> = {};\n    nodes.forEach((node) => {\n      const cluster = getItemForced(dict, node.subChain, () => ({\n        frame: new FigFrame(),\n        nodes: new Set<number>(),\n      }));\n      insertToCluster(cluster, node, nodesInfo);\n    });\n    this.clusters = Object.values(dict);\n  }\n\n  findByIndex(nodeIndex: number): FindResult {\n    const clusterIndex = this.clusters.findIndex((cl) =>\n      cl.nodes.has(nodeIndex)\n    );\n    if (clusterIndex < 0)\n      throw new Error(`Not found node with index ${nodeIndex}`);\n    const cluster = this.clusters[clusterIndex]!;\n    return { clusterIndex, cluster };\n  }\n\n  findByNode(node: ChemNode): FindResult {\n    return this.findByIndex(node.index);\n  }\n\n  unite(\n    ctx: PAgentCtx,\n    src: Connector,\n    dst: Connector,\n    step: Point,\n    bAbs?: boolean\n  ) {\n    const { cluster: srcCluster } = this.findByNode(src.node);\n    if (!dst.node) {\n      // Вообще такого быть не должно. Но если рисовать некорректно откомпилированную формулу, то бывает.\n      // Было бы неплохо придумать более удачный способ обработки некорректных ситуаций.\n      return {\n        cluster: srcCluster,\n        srcConn: { x: 0, yMiddle: 0 } as ClusterConnection,\n        dstConn: { x: 0, yMiddle: 0 } as ClusterConnection,\n        offset: Point.zero,\n      };\n    }\n    const srcNodeInfo = getNodeInfo(src.node, ctx.nodesInfo);\n    const { cluster: dstCluster, clusterIndex: dstPos } = this.findByNode(\n      dst.node\n    );\n    const dstNodeInfo = getNodeInfo(dst.node, ctx.nodesInfo);\n    const leftToRight = step.x >= 0;\n    let offset: Point;\n    const srcConn = getClusterConnection(\n      src.allBox,\n      srcCluster,\n      srcNodeInfo,\n      !leftToRight\n    );\n\n    const dstConn = getClusterConnection(\n      dst.allBox,\n      dstCluster,\n      dstNodeInfo,\n      leftToRight\n    );\n    if (bAbs) {\n      offset = calcOffsetAbs(srcCluster, dstCluster, step);\n    } else {\n      offset = calcOffset(srcConn, dstConn, step);\n    }\n    mergeClusters(srcCluster, dstCluster, offset);\n    this.clusters.splice(dstPos, 1);\n    return {\n      cluster: srcCluster,\n      srcConn,\n      dstConn,\n      offset,\n      srcNodeInfo,\n      dstNodeInfo,\n    };\n  }\n\n  uniteRest(ctx: PAgentCtx) {\n    const { clusters } = this;\n    while (clusters.length > 1) {\n      const c0 = clusters[0]!;\n      const c1 = clusters[1]!;\n      const offset = calcOffset(\n        getClusterBoxConnection(c0, false),\n        getClusterBoxConnection(c1, true),\n        new Point(ctx.props.horizLine, 0)\n      );\n      mergeClusters(c0, c1, offset);\n      clusters.splice(1, 1);\n    }\n  }\n}\n","import { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { Clusters } from \"./Clusters\";\nimport { NodeInfo } from \"../NodeInfo\";\nimport { ChemBackground } from \"../../core/ChemBackground\";\n\nexport class PAgentCtx {\n  readonly agentFrame: FigFrame;\n\n  readonly nodesInfo: NodeInfo[] = [];\n\n  readonly cmdStack: AgentCmd[] = [];\n\n  readonly clusters: Clusters = new Clusters();\n\n  readonly backs: ChemBackground[] = [];\n\n  readonly rtlNodes: Set<number> = new Set(); // Для определения направления стыковки без связей\n\n  constructor(\n    public readonly agent: ChemAgent,\n    public readonly props: ChemImgProps\n  ) {\n    this.agentFrame = new FigFrame();\n  }\n}\n","import { isLeftCoeff } from \"../../../types/CoeffPos\";\nimport { ifDef } from \"../../../utils/ifDef\";\nimport { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { CommonBracket, getBracketsContent } from \"../../../core/ChemBracket\";\nimport { ChemCharge } from \"../../../core/ChemCharge\";\nimport { ChemK } from \"../../../core/ChemK\";\nimport { ChemNode } from \"../../../core/ChemNode\";\nimport { ChemObj } from \"../../../core/ChemObj\";\nimport { isTextBracketsCached } from \"../../../core/isTextBrackets\";\nimport { PathStyle } from \"../../../drawSys/AbstractSurface\";\nimport { ChemImgProps } from \"../../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../../drawSys/figures/FigFrame\";\nimport { FigText } from \"../../../drawSys/figures/FigText\";\nimport { Figure } from \"../../../drawSys/figures/Figure\";\nimport { drawRubberFigure } from \"../../../drawSys/figures/rubber/drawRubberFigure\";\nimport { getRubberBracket } from \"../../../drawSys/figures/rubber/getRubberBracket\";\nimport { getFontHeight } from \"../../../drawSys/utils/fontFaceProps\";\nimport { drawCharge } from \"../../drawCharge\";\nimport { drawTextNear } from \"../../drawTextNear\";\nimport { getTextInternalRect } from \"../../getTextInternalRect\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../../NodeInfo\";\nimport { AgentCmdBrClose } from \"../AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"../AgentCmdBrOpen\";\nimport { PAgentCtx } from \"../PAgentCtx\";\nimport { applyPadding } from \"../../applyPadding\";\nimport { AgentCmdMul } from \"../AgentCmdMul\";\n\ninterface ResBracket {\n  figure: Figure;\n  y: number;\n  rect: Rect;\n}\n\nconst bracketCoeffs = (\n  frame: FigFrame,\n  rect: Rect,\n  props: ChemImgProps,\n  color?: string,\n  n?: ChemK,\n  charge?: ChemCharge\n) => {\n  if (charge) {\n    drawCharge({\n      charge,\n      frame,\n      rect,\n      imgProps: props,\n      color,\n      styleId: \"bracketCharge\",\n      type: \"bracket\",\n    });\n  }\n  if (n && n.isSpecified()) {\n    drawTextNear({\n      frame,\n      rcCore: rect,\n      text: String(n),\n      imgProps: props,\n      style: props.getStyleColored(\"bracketCount\", color),\n      pos: n.pos ?? \"RB\",\n      type: \"bracket\",\n    });\n  }\n  frame.update();\n};\n\nconst rubberBracket = (\n  isOpen: boolean,\n  bracket: CommonBracket,\n  props: ChemImgProps,\n  contentRect: Rect,\n  n?: ChemK,\n  charge?: ChemCharge\n): ResBracket => {\n  const rubberFig = getRubberBracket(isOpen, bracket.text);\n  const desiredRect = new Rect(0, 0, props.bracketWidth, contentRect.height);\n  const style: PathStyle = { fill: bracket.color ?? props.stdStyle.style.fill };\n  const frame = new FigFrame();\n  frame.addFigure(drawRubberFigure(rubberFig, desiredRect, style, props), true);\n  const rect = frame.bounds.clone();\n  bracketCoeffs(frame, rect, props, bracket.color, n, charge);\n  return {\n    figure: frame,\n    y: contentRect.top,\n    rect,\n  };\n};\n\nconst textBracket = (\n  bracket: CommonBracket,\n  props: ChemImgProps,\n  contentRect: Rect,\n  k?: ChemK,\n  charge?: ChemCharge\n): ResBracket => {\n  const style = props.getStyleColored(\"bracket\", bracket.color);\n  const frame = new FigFrame();\n  const figText = new FigText(bracket.text, style.font, style.style);\n  frame.addFigure(figText, true);\n  const { top } = frame.bounds;\n  const rect = getTextInternalRect(figText);\n  bracketCoeffs(frame, rect, props, bracket.color, k, charge);\n  return {\n    figure: frame,\n    y: contentRect.top - top,\n    rect,\n  };\n};\n\ninterface ParamsDrawBracket {\n  bracket: CommonBracket;\n  props: ChemImgProps;\n  isText: boolean;\n  isOpen: boolean;\n  contentRect: Rect;\n  nodeInfo: NodeInfo;\n  n?: ChemK;\n  charge?: ChemCharge;\n}\n\nconst drawBracket = ({\n  bracket,\n  contentRect,\n  isOpen,\n  isText,\n  props,\n  nodeInfo,\n  n,\n  charge,\n}: ParamsDrawBracket): Figure => {\n  const { figure, y, rect } = isText\n    ? textBracket(bracket, props, contentRect, n, charge)\n    : rubberBracket(isOpen, bracket, props, contentRect, n, charge);\n  const x = isOpen ? contentRect.left - rect.width : contentRect.right;\n  figure.org.set(x, y);\n\n  // Для присоединения текстовой скобки к текстовому узлу используем базовую линию\n  if (isText && !nodeInfo.node.autoMode) {\n    figure.org.y = nodeInfo.res.nodeFrame.org.y;\n  }\n\n  return figure;\n};\n\nexport const makeBridge = (\n  ctx: PAgentCtx,\n  bracket: CommonBracket,\n  isSrcBracket: boolean,\n  isBothText: boolean\n) => {\n  const [node0, node1] = bracket.nodes;\n  if (node0 && node1) {\n    const src = { node: node0, allBox: isSrcBracket };\n    const dst = { node: node1, allBox: true };\n    const sign = ctx.rtlNodes.has(node0.index) ? -1 : 1;\n    let dy = 0;\n    const flAbs = !isBothText;\n    if (flAbs) {\n      // Стыковка скобки со скобкой. Выравнивание пропорционально высоте содержимого кластеров\n      const { cluster: c0 } = ctx.clusters.findByNode(node0);\n      const { cluster: c1 } = ctx.clusters.findByNode(node1);\n      const b0 = c0.contentRect ?? c0.frame.bounds;\n      const b1 = c1.contentRect ?? c1.frame.bounds;\n      dy = b0.top - b1.top + (b0.height - b1.height) / 2;\n    }\n    ctx.clusters.unite(\n      ctx,\n      src,\n      dst,\n      new Point(sign * ctx.props.bracketSpace, dy),\n      flAbs\n    );\n  }\n};\n\nconst calcBracketRect = (\n  content: ChemObj[],\n  nodesInfo: NodeInfo[]\n): Rect | undefined =>\n  content.reduce((rect, cmd) => {\n    if (cmd instanceof ChemNode) {\n      const nodeInfo = getNodeInfo(cmd, nodesInfo);\n      const rcRel: Rect = nodeInfo.res.nodeFrame.getRelativeBounds();\n      if (!rect) return rcRel;\n      rect.unite(rcRel);\n      return rect;\n    }\n    return rect;\n  }, undefined as Rect | undefined);\n\nexport const processBrackets = (\n  ctx: PAgentCtx,\n  cmdOpen: AgentCmdBrOpen,\n  cmdClose: AgentCmdBrClose\n) => {\n  const { begin } = cmdOpen;\n  const { end } = cmdClose;\n  const { nodesInfo, agent, clusters, props } = ctx;\n  const { useTextBrackets, line, lineWidth } = props;\n  const beginNode = begin.nodes[1];\n  const endNode = end.nodeIn;\n  if (!beginNode || !endNode) return;\n  const { cluster } = clusters.findByNode(beginNode);\n  const beginNi = getNodeInfo(beginNode, nodesInfo);\n  const endNi = getNodeInfo(endNode, nodesInfo);\n  const isText0: boolean = useTextBrackets\n    ? isTextBracketsCached(begin, agent.commands)\n    : false;\n  const content = getBracketsContent(begin, agent.commands);\n  let contentRect0 = calcBracketRect(content, nodesInfo);\n  if (\n    (!contentRect0 || contentRect0.isEmpty()) &&\n    content.length === 1 &&\n    content[0] instanceof ChemNode\n  ) {\n    // Пустые скобки при наличии автоузла внутри. Example: /()'n'\\\n    const { font } = props.getStyle(\"atom\");\n    const ff = font.getFontFace();\n    const h = getFontHeight(ff) / 2;\n    const p = getNodeCenterPos(getNodeInfo(content[0], nodesInfo));\n    contentRect0 = new Rect(\n      new Point(p.x - lineWidth, p.y - h),\n      new Point(p.x + lineWidth, p.y + h)\n    );\n  }\n  const contentRect1 = contentRect0;\n  if (!contentRect1) return;\n\n  const contentRect =\n    ifDef(begin.padding, (p) => applyPadding(contentRect1, p, line)) ??\n    contentRect1;\n  const isText = isText0 && contentRect.height === contentRect1.height;\n  // eslint-disable-next-line no-param-reassign\n  cmdClose.isRealText = isText;\n\n  const xPad = isText ? 0 : lineWidth;\n  if (\n    cmdOpen.dstCmd instanceof AgentCmdBrOpen ||\n    cmdOpen.dstCmd instanceof AgentCmdMul\n  ) {\n    if (cmdOpen.dstCmd.figure) {\n      const rc = cmdOpen.dstCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.left - xPad, rc.center.y));\n    }\n  }\n  if (cmdOpen.srcCmd instanceof AgentCmdBrClose) {\n    if (cmdOpen.srcCmd.figure) {\n      const rc = cmdOpen.srcCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.left, rc.center.y));\n    }\n  }\n  if (cmdClose.srcCmd instanceof AgentCmdBrClose) {\n    if (cmdClose.srcCmd.figure) {\n      const rc = cmdClose.srcCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.right + xPad, rc.center.y));\n    }\n  }\n\n  // TODO: отладочный вывод рамки\n  // const fr = new FigRect(contentRect, {stroke: \"red\", strokeWidth: 0.5});\n  // cluster.frame.addFigure(fr);\n\n  const { charge, n } = end;\n  const ch = (open: boolean): ChemCharge | undefined =>\n    open === charge?.isLeft ? charge : undefined;\n  const coeff = (open: boolean): ChemK | undefined =>\n    open === isLeftCoeff(n.pos) ? n : undefined;\n  const figOpen = drawBracket({\n    isOpen: true,\n    bracket: begin,\n    isText,\n    props,\n    contentRect,\n    nodeInfo: beginNi,\n    n: coeff(true),\n    charge: ch(true),\n  });\n  const figClose = drawBracket({\n    isOpen: false,\n    bracket: end,\n    isText,\n    props,\n    contentRect,\n    nodeInfo: endNi,\n    n: coeff(false),\n    charge: ch(false),\n  });\n  cluster.frame.addFigure(figOpen, true);\n  cluster.frame.addFigure(figClose, true);\n\n  // Для вложенных скобок внешние переписывают внутренние.\n  beginNi.left = figOpen;\n  endNi.right = figClose;\n\n  // eslint-disable-next-line no-param-reassign\n  cmdOpen.figure = figOpen;\n  // eslint-disable-next-line no-param-reassign\n  cmdClose.figure = figClose;\n  cluster.contentRect = contentRect;\n\n  if (cmdOpen.isBridge) {\n    const isBothText =\n      isText && (!!cmdOpen?.prevBracket?.isRealText || !!cmdOpen.prevText);\n    makeBridge(ctx, cmdOpen.begin, !!cmdOpen.prevBracket, isBothText);\n  }\n};\n","/**\n * Алгоритм построения агента, использующий приоритет команд\n *\n */\n\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { prepareNodes } from \"./prepareNodes\";\nimport { processCommands } from \"./processCommands\";\nimport { drawAllBonds } from \"./drawAllBonds\";\nimport { Point } from \"../../math/Point\";\nimport { findAgentCenter } from \"./findAgentCenter\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { getTextInternalRect } from \"../getTextInternalRect\";\nimport { drawBackground } from \"./drawBackground\";\n\nexport interface ResultBuildAgent {\n  agentFrame: FigFrame;\n  center: Point;\n  ctx: PAgentCtx;\n}\n\nexport const buildAgentPrior = (\n  agent: ChemAgent,\n  imgProps: ChemImgProps\n): ResultBuildAgent => {\n  const ctx = new PAgentCtx(agent, imgProps);\n  const { agentFrame } = ctx;\n\n  prepareNodes(ctx);\n  processCommands(ctx);\n  ctx.clusters.uniteRest(ctx);\n  drawAllBonds(ctx);\n\n  const cluster = ctx.clusters.clusters.shift();\n  if (cluster) {\n    cluster.frame.figures.forEach((fig) => agentFrame.addFigure(fig));\n    agentFrame.update();\n  }\n  drawBackground(ctx);\n  const center = findAgentCenter(ctx);\n\n  if (agent.n.isSpecified()) {\n    const kStyle = imgProps.getStyleColored(\"agentK\", agent.n.color);\n    const figK = new FigText(agent.n.toString(), kStyle.font, kStyle.style);\n    const irc = getTextInternalRect(figK);\n    figK.org.x =\n      agentFrame.bounds.left - figK.bounds.width - imgProps.agentKSpace;\n    figK.org.y = center.y - irc.center.y;\n    agentFrame.addFigure(figK, true);\n  }\n\n  return { agentFrame, ctx, center };\n};\n","import { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemObj } from \"../../core/ChemObj\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { AgentCmdNode } from \"./AgentCmdNode\";\nimport { AgentCmdSoftBond } from \"./AgentCmdSoftBond\";\nimport { ChemMul, ChemMulEnd } from \"../../core/ChemMul\";\nimport { createAgentCmdMul } from \"./AgentCmdMul\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\n\nexport const createAgentCmd = (\n  obj: ChemObj,\n  agent: ChemAgent\n): AgentCmd | undefined => {\n  if (obj instanceof ChemBond) {\n    if (obj.soft) return new AgentCmdSoftBond(obj, agent);\n  } else if (obj instanceof ChemBracketBegin) {\n    return new AgentCmdBrOpen(obj);\n  } else if (obj instanceof ChemBracketEnd) {\n    return new AgentCmdBrClose(obj);\n  } else if (obj instanceof ChemMul) {\n    return createAgentCmdMul(obj);\n  } else if (obj instanceof ChemNode) {\n    return new AgentCmdNode(obj);\n  } else if (obj instanceof ChemMulEnd) {\n    return undefined;\n  }\n  return new AgentCmd();\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\n\nexport const createCoeff = (mul: ChemMul, props: ChemImgProps): FigText => {\n  const kStyle = props.getStyleColored(\"multiK\", mul.color);\n  return new FigText(String(mul.n), kStyle.font, kStyle.style);\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { drawBond } from \"../bond/drawBond\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const drawAllBonds = (ctx: PAgentCtx) => {\n  const { agent, props, agentFrame, nodesInfo } = ctx;\n  agent.commands.forEach((cmd) => {\n    if (cmd instanceof ChemBond && !cmd.soft) {\n      drawBond({\n        bond: cmd,\n        props,\n        frame: agentFrame,\n        nodesInfo,\n        stA: agent.stA,\n      });\n    }\n  });\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { ParamsChemBackground } from \"../../core/ChemBackground\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigRect } from \"../../drawSys/figures/FigRect\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { applyPadding } from \"../applyPadding\";\n\nexport const calcBgRect = (\n  ctx: PAgentCtx,\n  nodes: ChemNode[] = []\n): Rect | undefined =>\n  nodes.reduce((rc: Rect | undefined, node: ChemNode) => {\n    const ni = getNodeInfo(node, ctx.nodesInfo);\n    const rcNode = ni.res.nodeFrame.getRelativeBounds();\n    return rc ? rc.unite(rcNode) : rcNode;\n  }, undefined);\n\nconst createBgRect = (rc: Rect, style: PathStyle, radius?: Point) =>\n  new FigRect(rc, style, radius);\n\nconst createBgEllipse = (rc: Rect, style: PathStyle) => {\n  const p0 = rc.center;\n  const w = rc.width;\n  const h = rc.height;\n  // if (is0(w - h)) return createBgRound(rc, style);\n  const calcAB = (c: number, p: number) => {\n    const d = p * p + 4 * c * c;\n    const e = (-p + Math.sqrt(d)) / (2 * c);\n    const a = c / e;\n    const b = (c * Math.sqrt(1 - e * e)) / e;\n    return { a, b };\n  };\n  if (w > h) {\n    const { a, b } = calcAB(w / 2, h / 2);\n    return new FigEllipse(p0, new Point(a, b), style);\n  }\n  const { a, b } = calcAB(h / 2, w / 2);\n  return new FigEllipse(p0, new Point(b, a), style);\n};\n\nconst calcRadius = (\n  ctx: PAgentCtx,\n  rect: Rect,\n  srcNodes?: ChemNode[]\n): number => {\n  const nodes = srcNodes ?? ctx.agent.nodes;\n  const { center } = rect;\n  let maxSqr = 0;\n  nodes.forEach((node) => {\n    const ni = getNodeInfo(node, ctx.nodesInfo);\n    const rc = ni.res.nodeFrame.getRelativeBounds();\n    const cc = rc.center;\n    const p = new Point(\n      cc.x < center.x ? rc.left : rc.right,\n      cc.y < center.y ? rc.top : rc.bottom\n    );\n    maxSqr = Math.max(maxSqr, center.minus(p).lengthSqr());\n  });\n  return Math.sqrt(maxSqr);\n};\n\nexport const makeBackFigure = (\n  ctx: PAgentCtx,\n  params: ParamsChemBackground\n): Figure => {\n  const {\n    nodes,\n    isAll,\n    padding,\n    fill,\n    stroke,\n    strokeWidth,\n    shape,\n    borderRadius,\n  } = params;\n  const { agentFrame, props } = ctx;\n  // TODO: Использование agentFrame.bounds норм для rect.\n  // Но для round это обычно плохо, т.к углы часто пустые. А круги считают углы радиусом. Поэтому получается слишком широкий отступ.\n  // Было бы лучше перебрать все узлы и найти максимальное расстояние от центра\n  let rect: Rect | undefined = isAll\n    ? agentFrame.bounds.clone()\n    : calcBgRect(ctx, nodes);\n  if (!rect) {\n    // Выгоднее использовать заглушку, чем потом контролировать пригодность полученных объектов.\n    return new FigFrame();\n  }\n  const srcRect = rect.clone();\n  if (padding) {\n    rect = applyPadding(rect, padding, props.line);\n  }\n\n  const style: PathStyle = {};\n  if (fill) style.fill = fill;\n  if (stroke) style.stroke = stroke;\n  if (strokeWidth) style.strokeWidth = props.lineWidth * strokeWidth;\n\n  if (shape === \"round\") {\n    const r0 = calcRadius(ctx, rect, nodes);\n    const rPad = Math.min(\n      (rect.width - srcRect.width) / 2,\n      (rect.height - srcRect.height) / 2\n    );\n    const r = r0 + rPad;\n    return new FigEllipse(rect.center, new Point(r, r), style);\n  }\n  if (shape === \"ellipse\") return createBgEllipse(rect, style);\n  const radius = ifDef(\n    borderRadius,\n    (it) => new Point(it * props.line, it * props.line)\n  );\n  return createBgRect(rect, style, radius);\n};\n\nexport const drawBackground = (ctx: PAgentCtx) => {\n  const { backs } = ctx;\n  if (backs.length === 0) return;\n  const figs = backs.map((bg) => makeBackFigure(ctx, bg.params));\n  figs.forEach((fig, i) => ctx.agentFrame.insertFigure(i, fig, true));\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { LocalFont, TextStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { Point } from \"../../math/Point\";\nimport { getFontHeight } from \"../../drawSys/utils/fontFaceProps\";\n\nexport const drawMul = (\n  props: ChemImgProps,\n  mFont: LocalFont,\n  mStyle: TextStyle\n): Figure => {\n  const { mulRadius } = props;\n  if (mulRadius) {\n    const ff = mFont.getFontFace();\n    const r = getFontHeight(ff) * mulRadius;\n    return new FigEllipse(new Point(r, -ff.capHeight * 0.5), new Point(r, r), {\n      fill: mStyle.fill,\n    });\n  }\n  return new FigText(props.mulChar, mFont, mStyle);\n};\n","import { Rect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const findAgentCenter = (ctx: PAgentCtx): Point =>\n  calcExplicitCenter(findExplicitlyCentred(ctx.nodesInfo)) ??\n  monoCycle(ctx) ??\n  findDefaultCenter(ctx.nodesInfo, ctx.agentFrame.bounds) ??\n  ctx.agentFrame.bounds.center;\n\nconst monoCycle = (ctx: PAgentCtx): Point | undefined => {\n  const {\n    agent: { stA },\n    nodesInfo,\n  } = ctx;\n  stA.analyze();\n  if (stA.cycles.length !== 1) return undefined;\n  const cy = stA.cycles[0]!;\n  return cy.nodes\n    .reduce(\n      (sum, node) => sum.iadd(getNodeCenterPos(getNodeInfo(node, nodesInfo))),\n      new Point()\n    )\n    .scale(1 / cy.nodes.length);\n};\n\nexport const findExplicitlyCentred = (allNodesInfo: NodeInfo[]): NodeInfo[] =>\n  allNodesInfo.filter(({ node }) => node.bCenter);\n\nexport const calcExplicitCenter = (\n  expNodesInfo: NodeInfo[]\n): Point | undefined => {\n  const centers: Point[] = expNodesInfo.map((ni) => getNodeCenterPos(ni));\n  if (centers.length === 0) {\n    return undefined;\n  }\n  if (centers.length === 1) {\n    return centers[0]!;\n  }\n  const summa = centers.reduce((acc, p) => acc.iadd(p), new Point());\n  return summa.times(1 / centers.length);\n};\n\nconst findDefaultCenter = (\n  nodesInfo: NodeInfo[],\n  rect: Rect\n): Point | undefined =>\n  ifDef(findDefaultY(nodesInfo), (y) => new Point(rect.center.x, y));\n\nexport const findDefaultY = (nodesInfo: NodeInfo[]): number | undefined => {\n  // Алгоритм: найти наибольшее количество узлов с одинаковым y\n  // Если таких несколько, то взять из них среднее\n  const dict: Record<number, number> = {};\n  let maxCount = 0;\n  nodesInfo.forEach((ni) => {\n    // Ключом является значение y, округленное до сотых\n    const y = Math.round(getNodeCenterPos(ni).y * 100);\n    const count = (dict[y] ?? 0) + 1;\n    dict[y] = count;\n    maxCount = Math.max(count, maxCount);\n  });\n  let cy = 0;\n  let n = 0;\n  Object.entries(dict).forEach(([y, count]) => {\n    if (count === maxCount) {\n      cy += +y;\n      n++;\n    }\n  });\n  return n ? cy / 100 / n : undefined;\n};\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { buildNode } from \"../buildNode\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const prepareNodes = (ctx: PAgentCtx) => {\n  const { agent, props } = ctx;\n  agent.nodes.forEach((node) => {\n    const res = buildNode(node, props) ?? {\n      nodeFrame: new FigFrame(),\n      rcNodeCore: new Rect(),\n      center: new Point(),\n    };\n    const pos = node.pt.times(props.line);\n    const { nodeFrame, center } = res;\n    nodeFrame.org.iadd(pos);\n    nodeFrame.org.isub(center);\n\n    ctx.nodesInfo[node.index] = { node, res };\n  });\n\n  ctx.clusters.init(agent.nodes, ctx.nodesInfo);\n};\n","import { ChemBackground } from \"../../core/ChemBackground\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { createAgentCmd } from \"./createAgentCmd\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\n\nexport const processCommands = (ctx: PAgentCtx) => {\n  let previousCmd: AgentCmd;\n  ctx.agent.commands.forEach((obj) => {\n    if (obj instanceof ChemBackground) {\n      ctx.backs.push(obj);\n      return;\n    }\n    const cmd = createAgentCmd(obj, ctx.agent);\n    if (cmd) {\n      if (previousCmd) cmd.onPrevious(previousCmd, ctx);\n      if (cmd.canPush(ctx)) {\n        ctx.cmdStack.unshift(cmd);\n      }\n      previousCmd = cmd;\n    }\n  });\n  unwind(ctx, () => true);\n};\n","import { AgentCmd } from \"./AgentCmd\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const unwind = (ctx: PAgentCtx, canPop: (cmd: AgentCmd) => boolean) => {\n  const { cmdStack } = ctx;\n  for (;;) {\n    const head = cmdStack.shift();\n    if (!head) return;\n    if (!canPop(head)) {\n      cmdStack.unshift(head);\n      return;\n    }\n    head.postExec(ctx);\n  }\n};\n","import { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildAgentPrior } from \"./buildAgentPrior/buildAgentPrior\";\nimport { buildOp } from \"./buildOp\";\n\ninterface ResultBuildExpr {\n  frame: FigFrame;\n}\n\ninterface EntityInfo {\n  frame: FigFrame;\n  y: number;\n}\n\nexport const buildExpression = (\n  expr: ChemExpr,\n  props: ChemImgProps\n): ResultBuildExpr => {\n  const frame = new FigFrame();\n  let x = 0;\n  expr.entities.forEach((obj) => {\n    let einfo: EntityInfo | undefined;\n    if (obj instanceof ChemAgent) {\n      const { agentFrame, center } = buildAgentPrior(obj, props);\n      einfo = { frame: agentFrame, y: center.y };\n    } else if (obj instanceof ChemOp) {\n      const { frame: opFrame, center } = buildOp(obj, props);\n      einfo = { frame: opFrame, y: center.y };\n    }\n    if (einfo) {\n      einfo.frame.org.y -= einfo.y;\n      einfo.frame.org.x = x - einfo.frame.bounds.left;\n      x += einfo.frame.bounds.width + props.opSpace;\n      frame.addFigure(einfo.frame, true);\n    }\n  });\n  frame.bounds.grow(1); // Небольшое поле позволяет скрыть недостатки определения границ. Иначе отсекаются края.\n  return { frame };\n};\n","import { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildExpression } from \"./buildExpression\";\nimport { buildAgentPrior } from \"./buildAgentPrior/buildAgentPrior\";\n\nexport const buildFrame = (\n  expr: ChemExpr | ChemAgent,\n  imgProps: ChemImgProps\n): FigFrame =>\n  expr instanceof ChemExpr\n    ? buildExpression(expr, imgProps).frame\n    : buildAgentPrior(expr, imgProps).agentFrame;\n","import { ChemNodeItem } from \"../core/ChemNodeItem\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { drawText } from \"./drawText\";\nimport { Rect } from \"../math/Rect\";\nimport { drawTextNear } from \"./drawTextNear\";\nimport { getTextInternalRect } from \"./getTextInternalRect\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { drawTextWithMarkup } from \"./drawTextWithMarkup\";\nimport { drawLewisShell } from \"./drawLewisShell\";\nimport { FigEllipse } from \"../drawSys/figures/FigEllipse\";\nimport { Point } from \"../math/Point\";\nimport { LocalFont } from \"../drawSys/AbstractSurface\";\nimport { ChemStyleId } from \"../drawSys/ChemStyleId\";\nimport { CoeffPos } from \"../types/CoeffPos\";\nimport { locateAtomNumber } from \"../inspectors/locateAtomNumber\";\nimport { ifDef } from \"../utils/ifDef\";\n\ninterface BuildItemResult {\n  itemFrame: FigFrame;\n  figText?: Figure;\n  rcCore?: Rect;\n}\n\nexport const buildItem = (\n  item: ChemNodeItem,\n  imgProps: ChemImgProps\n): BuildItemResult => {\n  const itemFrame = new FigFrame();\n  itemFrame.label = \"item\";\n  const { color } = item;\n  let itemFont: LocalFont | undefined;\n  const { fig, rcCore } = item.walkExt({\n    fig: undefined as Figure | undefined,\n    rcCore: undefined as Rect | undefined,\n    onText(text: string, style: TextProps) {\n      const txFig = drawText(itemFrame, text, style);\n      this.fig = txFig;\n      this.rcCore = getTextInternalRect(txFig);\n      itemFont = style.font;\n    },\n    onMarkup(textWithMarkup: string, style: TextProps) {\n      itemFont = style.font;\n      const { fig: figM, irc } = drawTextWithMarkup(\n        textWithMarkup,\n        imgProps,\n        style\n      );\n      itemFrame.addFigure(figM, true);\n      this.fig = figM;\n      this.rcCore = irc;\n    },\n\n    atom(obj) {\n      this.onText(\n        obj.id,\n        imgProps.getStyleColored(\"atom\", item.atomColor ?? item.color)\n      );\n    },\n    radical(obj) {\n      this.onText(obj.label, imgProps.getStyleColored(\"radical\", item.color));\n    },\n    comment(obj) {\n      this.onMarkup(obj.text, imgProps.getStyleColored(\"comment\", item.color));\n    },\n    custom(obj) {\n      this.onMarkup(obj.text, imgProps.getStyleColored(\"custom\", item.color));\n    },\n    comma() {\n      this.onText(\",\", imgProps.getStyleColored(\"comma\", item.color));\n    },\n  });\n  if (rcCore) {\n    const drawIndex = (value: unknown, styleName: ChemStyleId, pos: CoeffPos) =>\n      drawTextNear({\n        frame: itemFrame,\n        rcCore,\n        text: String(value),\n        imgProps,\n        style: imgProps.getStyleColored(styleName, item.color),\n        pos,\n      });\n\n    const { atomNum, n, charge, mass, dots } = item;\n    if (n.isSpecified()) {\n      drawIndex(n.toString(), \"itemCount\", \"RB\");\n    }\n    if (charge) {\n      drawIndex(charge.text, \"oxidationState\", \"CU\");\n    }\n    ifDef(mass, (it) => drawIndex(it, \"itemMass\", \"LT\"));\n    ifDef(atomNum, (it) => {\n      const atomNumber = it === \"\" ? locateAtomNumber(item) : it;\n      if (atomNumber !== undefined) drawIndex(atomNumber, \"atomNumber\", \"LB\");\n    });\n    if (dots) {\n      const rc = rcCore.clone();\n      if (itemFont) {\n        rc.B.y -= (itemFont as LocalFont).getFontFace().descent;\n        rc.B.y -= imgProps.lineWidth;\n      }\n      const radius = imgProps.electronDotD / 2;\n      const pr = new Point(radius, radius);\n      rc.grow(imgProps.lineWidth + radius);\n      drawLewisShell(rc, dots, imgProps, ({ p, color: dotColor }) => {\n        const figDot = new FigEllipse(p, pr, {\n          fill: dotColor || color || imgProps.stdStyle.style.fill,\n        });\n        figDot.bounds.grow(imgProps.lineWidth);\n        itemFrame.addFigure(figDot);\n      });\n    }\n    // TODO: dashes\n  }\n  itemFrame.update();\n  return { itemFrame, figText: fig, rcCore };\n};\n","import { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildItem } from \"./buildItem\";\nimport { Point } from \"../math/Point\";\nimport { Rect } from \"../math/Rect\";\nimport { drawCharge } from \"./drawCharge\";\nimport { isEmptyNode } from \"../core/isEmptyNode\";\n\nexport interface ResultBuildNode {\n  nodeFrame: FigFrame;\n  rcNodeCore: Rect; // in local coordinates\n  center: Point; // in local coordinates (relative (0,0) of frame bounds)\n}\n\nexport const buildNode = (\n  node: ChemNode,\n  imgProps: ChemImgProps\n): ResultBuildNode | undefined => {\n  if ((node.autoMode || isEmptyNode(node)) && !node.charge) {\n    // auto node dont draw items. Example: /\\/\\\n    return undefined;\n  }\n  const nodeFrame = new FigFrame();\n  nodeFrame.label = \"node\";\n  const centerItem = node.getCenterItem();\n  let x = 0;\n  let center: Point | undefined;\n  let rcNodeCore: Rect | undefined;\n  if (node.autoMode) {\n    // Для автоузлов нужно имитировать область, вокруг которой будет выводиться заряд\n    // Координаты так подобраны, чтобы соответствовать тексту (то есть, относительно базовой линии)\n    const d = imgProps.line * 0.2;\n    nodeFrame.bounds = new Rect(0, -d, d, 0);\n  } else {\n    node.items.forEach((item) => {\n      const { itemFrame, rcCore } = buildItem(item, imgProps);\n      itemFrame.org.x = x - itemFrame.bounds.left;\n      nodeFrame.addFigure(itemFrame);\n      if (rcCore) {\n        const irc = rcCore.clone();\n        irc.moveXY(itemFrame.org.x, 0);\n        if (item === centerItem) {\n          center = irc.center;\n        }\n        if (!rcNodeCore) {\n          rcNodeCore = irc.clone();\n        } else {\n          rcNodeCore.unite(irc);\n        }\n      }\n      x += itemFrame.bounds.width;\n    });\n    nodeFrame.update();\n  }\n  const { charge } = node;\n  rcNodeCore = rcNodeCore ?? nodeFrame.bounds.clone();\n  if (charge) {\n    drawCharge({\n      charge,\n      frame: nodeFrame,\n      rect: rcNodeCore,\n      imgProps,\n      color: node.color,\n    });\n  }\n\n  center = center ?? rcNodeCore.center;\n  return { nodeFrame, rcNodeCore, center };\n};\n","import { ChemOp } from \"../core/ChemOp\";\r\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\r\nimport { FigText } from \"../drawSys/figures/FigText\";\r\nimport { Point } from \"../math/Point\";\r\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\r\nimport { getTextInternalRect } from \"./getTextInternalRect\";\r\nimport { Figure } from \"../drawSys/figures/Figure\";\r\nimport { Rect } from \"../math/Rect\";\r\nimport { ChemComment } from \"../core/ChemComment\";\r\nimport { ifDef } from \"../utils/ifDef\";\r\nimport { FigPath } from \"../drawSys/figures/FigPath\";\r\nimport { PathSeg } from \"../drawSys/path\";\r\nimport { LocalFont, PathStyle, TextStyle } from \"../drawSys/AbstractSurface\";\r\nimport { drawTextWithMarkup, ResultTextWithMarkup } from \"./drawTextWithMarkup\";\r\n\r\ninterface FigDef {\r\n  figOp: Figure;\r\n  irc: Rect;\r\n}\r\n\r\ninterface ParamsOpDraw {\r\n  srcText: string;\r\n  dstText: string;\r\n  props: ChemImgProps;\r\n  font: LocalFont;\r\n  style: TextStyle;\r\n  commWidth: number;\r\n}\r\n\r\ninterface ResultBuildOp {\r\n  frame: FigFrame;\r\n  center: Point;\r\n}\r\n\r\nexport const buildOp = (op: ChemOp, props: ChemImgProps): ResultBuildOp => {\r\n  const comms: [\r\n    ResultTextWithMarkup | undefined,\r\n    ResultTextWithMarkup | undefined\r\n  ] = [\r\n    ifDef(op.commentPre, (it) => buildOpComment(it, props, op.color)),\r\n    ifDef(op.commentPost, (it) => buildOpComment(it, props, op.color)),\r\n  ];\r\n  const { srcText, dstText } = op;\r\n  const commWidth = comms.reduce(\r\n    (width, com) => Math.max(width, com ? com.fig.bounds.width : 0),\r\n    0\r\n  );\r\n  const frame = new FigFrame();\r\n  const style = props.getStyleColored(\"operation\", op.color);\r\n  const drawFn = opDict[srcText] ?? opTextFigure;\r\n  const { figOp, irc } = drawFn({\r\n    srcText,\r\n    dstText,\r\n    props,\r\n    commWidth,\r\n    ...style,\r\n  });\r\n  frame.addFigure(figOp, true);\r\n  comms.forEach((com, i) =>\r\n    ifDef(com, (it) => addOpComment(frame, irc, it, i === 0))\r\n  );\r\n  return { frame, center: irc.center };\r\n};\r\n\r\nconst makeStrokeStyle = ({ props, style }: ParamsOpDraw): PathStyle => ({\r\n  stroke: style.fill,\r\n  strokeWidth: props.lineWidth,\r\n});\r\n\r\nconst opTextFigure = ({ dstText, font, style }: ParamsOpDraw): FigDef => {\r\n  const figOp = new FigText(dstText, font, style);\r\n  const irc = getTextInternalRect(figOp);\r\n  return { figOp, irc };\r\n};\r\n\r\ntype FnCoordCvt = (x: number, y: number) => Point;\r\nconst mathArrWorldWidth = 40;\r\nconst mathArrWorldDx = 109;\r\n\r\nconst makeMathCoordCvt = (props: ChemImgProps): FnCoordCvt => {\r\n  const { lineWidth } = props;\r\n  // lineWidth -- mathArrWorldWidth\r\n  // view Value -- world Value\r\n  // view Value = world Value * lineWidth / mathArrowWorldWidth;\r\n  const k = lineWidth / mathArrWorldWidth;\r\n  return (x, y) => new Point(x * k, y * k);\r\n};\r\n\r\nconst mathRightArrowCommands = (cvt: FnCoordCvt): PathSeg[] => [\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-47.3, 35.3),\r\n    cp2: cvt(-84, 78),\r\n    pt: cvt(-110, 128),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-16.7, 32),\r\n    cp2: cvt(-27.7, 63.7),\r\n    pt: cvt(-33, 95),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(0, 1.3),\r\n    cp2: cvt(-0.2, 2.7),\r\n    pt: cvt(-0.5, 4),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-0.3, 1.3),\r\n    cp2: cvt(-0.5, 2.3),\r\n    pt: cvt(-0.5, 3),\r\n  },\r\n  { cmd: \"C\", rel: true, cp1: cvt(0, 7.3), cp2: cvt(6.7, 11), pt: cvt(20, 11) },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(8, 0),\r\n    cp2: cvt(13.2, -0.8),\r\n    pt: cvt(15.5, -2.5),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(2.3, -1.7),\r\n    cp2: cvt(4.2, -5.5),\r\n    pt: cvt(5.5, -11.5),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(2, -13.3),\r\n    cp2: cvt(5.7, -27),\r\n    pt: cvt(11, -41),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(14.7, -44.7),\r\n    cp2: cvt(39, -84.5),\r\n    pt: cvt(73, -119.5),\r\n  },\r\n  { cmd: \"S\", rel: true, cp2: cvt(73.7, -60.2), pt: cvt(119, -75.5) },\r\n  { cmd: \"C\", rel: true, cp1: cvt(6, -2), cp2: cvt(9, -5.7), pt: cvt(9, -11) },\r\n  { cmd: \"S\", rel: true, cp2: cvt(-3, -9), pt: cvt(-9, -11) },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-45.3, -15.3),\r\n    cp2: cvt(-85, -40.5),\r\n    pt: cvt(-119, -75.5),\r\n  },\r\n  { cmd: \"S\", rel: true, cp2: cvt(-58.3, -74.8), pt: cvt(-73, -119.5) },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-4.7, -14),\r\n    cp2: cvt(-8.3, -27.3),\r\n    pt: cvt(-11, -40),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-1.3, -6.7),\r\n    cp2: cvt(-3.2, -10.8),\r\n    pt: cvt(-5.5, -12.5),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-2.3, -1.7),\r\n    cp2: cvt(-7.5, -2.5),\r\n    pt: cvt(-15.5, -2.5),\r\n  },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(-14, 0),\r\n    cp2: cvt(-21, 3.7),\r\n    pt: cvt(-21, 11),\r\n  },\r\n  { cmd: \"C\", rel: true, cp1: cvt(0, 2), cp2: cvt(2, 10.3), pt: cvt(6, 25) },\r\n  {\r\n    cmd: \"C\",\r\n    rel: true,\r\n    cp1: cvt(20.7, 83.3),\r\n    cp2: cvt(67, 151.7),\r\n    pt: cvt(139, 205),\r\n  },\r\n];\r\nconst mathLeftArrowCommands = (cvt: FnCoordCvt): PathSeg[] =>\r\n  mathRightArrowCommands((x, y) => cvt(-x, y));\r\n\r\ntype FnDrawSegs = (cvt: FnCoordCvt, width: number) => PathSeg[];\r\n\r\nconst mathArrow = (params: ParamsOpDraw, drawSegs: FnDrawSegs): FigDef => {\r\n  const { props, commWidth, font, dstText, style } = params;\r\n  const { lineWidth, line, thickWidth } = props;\r\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\r\n  const arrDx = (mathArrWorldDx * lineWidth) / mathArrWorldWidth;\r\n  const width = Math.max(commWidth + 2 * (thickWidth + arrDx), minWidth);\r\n  const cvt = makeMathCoordCvt(props);\r\n  const figOp = new FigPath(drawSegs(cvt, width), style);\r\n  figOp.update();\r\n  return { figOp, irc: figOp.bounds };\r\n};\r\nconst drawMathRightSegs: FnDrawSegs = (cvt, width) => [\r\n  { cmd: \"M\", pt: cvt(0, 0) },\r\n  { cmd: \"V\", rel: true, y: cvt(0, mathArrWorldWidth).y },\r\n  { cmd: \"H\", x: width - cvt(mathArrWorldDx, 0).x },\r\n  ...mathRightArrowCommands(cvt),\r\n  { cmd: \"Z\" },\r\n];\r\n\r\nconst drawMathLeftSegs: FnDrawSegs = (cvt, width) => [\r\n  { cmd: \"M\", pt: new Point(width, 0).plus(cvt(0, 241)) },\r\n  { cmd: \"H\", x: cvt(110, 0).x },\r\n  ...mathLeftArrowCommands(cvt),\r\n  { cmd: \"H\", x: width },\r\n  { cmd: \"Z\" },\r\n];\r\n\r\nconst drawMathBiSegs: FnDrawSegs = (cvt, width) => {\r\n  const p0 = new Point(width - cvt(mathArrWorldDx, 0).x, 0);\r\n  return [\r\n    { cmd: \"M\", pt: p0 },\r\n    ...mathRightArrowCommands(cvt),\r\n    { cmd: \"Z\" },\r\n    { cmd: \"H\", x: cvt(110, 0).x },\r\n    ...mathLeftArrowCommands(cvt),\r\n    { cmd: \"H\", x: p0.x },\r\n    { cmd: \"Z\" },\r\n  ];\r\n};\r\n\r\nconst drawMathBothSegs: FnDrawSegs = (cvt, width) => [\r\n  { cmd: \"M\", pt: cvt(0, 0) },\r\n  { cmd: \"V\", rel: true, y: cvt(0, mathArrWorldWidth).y },\r\n  { cmd: \"H\", x: width - cvt(mathArrWorldDx, 0).x },\r\n  ...mathRightArrowCommands(cvt),\r\n  { cmd: \"Z\" },\r\n\r\n  { cmd: \"M\", pt: new Point(width, 0).plus(cvt(0, 400)) },\r\n  { cmd: \"H\", x: cvt(110, 0).x },\r\n  ...mathLeftArrowCommands(cvt),\r\n  { cmd: \"H\", x: width },\r\n  { cmd: \"Z\" },\r\n];\r\n\r\nconst mathRightArrow = (params: ParamsOpDraw): FigDef =>\r\n  mathArrow(params, drawMathRightSegs);\r\nconst mathLeftArrow = (params: ParamsOpDraw): FigDef =>\r\n  mathArrow(params, drawMathLeftSegs);\r\nconst mathBiArrow = (params: ParamsOpDraw): FigDef =>\r\n  mathArrow(params, drawMathBiSegs);\r\nconst mathBothArrow = (params: ParamsOpDraw): FigDef =>\r\n  mathArrow(params, drawMathBothSegs);\r\n\r\nconst opLongArrow = (params: ParamsOpDraw): FigDef => {\r\n  const { props, style, font, commWidth, srcText, dstText } = params;\r\n  const { arrowD, arrowL, line } = props;\r\n  const isFilledArrow = srcText === \"--|>\";\r\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\r\n  const width = Math.max(commWidth + 2 * props.opSpace, minWidth);\r\n  const lineLen = width - arrowL;\r\n\r\n  const segs: PathSeg[] = [\r\n    { cmd: \"M\", pt: Point.zero },\r\n    { cmd: \"L\", pt: new Point(isFilledArrow ? lineLen : width, 0) },\r\n  ];\r\n  const figLine = new FigPath(segs, makeStrokeStyle(params));\r\n  figLine.update();\r\n\r\n  const tri: PathSeg[] = [\r\n    { cmd: \"M\", pt: new Point(lineLen, -arrowD) },\r\n    { cmd: \"L\", pt: new Point(width, 0) },\r\n    { cmd: \"L\", pt: new Point(lineLen, arrowD) },\r\n  ];\r\n  if (isFilledArrow) tri.push({ cmd: \"Z\" });\r\n  const triStyle: PathStyle = isFilledArrow\r\n    ? { fill: style.fill }\r\n    : makeStrokeStyle(params);\r\n  triStyle.join = \"miter\";\r\n  const figArrow = new FigPath(tri, triStyle);\r\n  figArrow.update();\r\n\r\n  const figOp = new FigFrame();\r\n  figOp.addFigure(figLine, true);\r\n  figOp.addFigure(figArrow, true);\r\n  return { figOp, irc: figOp.bounds };\r\n};\r\n\r\nconst opLongLeftArrow = (params: ParamsOpDraw): FigDef => {\r\n  const { props, style, font, commWidth, srcText, dstText } = params;\r\n  const { arrowD, arrowL, line } = props;\r\n  const isFilledArrow = srcText === \"<|--\";\r\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\r\n  const width = Math.max(commWidth + 2 * props.opSpace, minWidth);\r\n\r\n  const segs: PathSeg[] = [\r\n    { cmd: \"M\", pt: new Point(width, 0) },\r\n    { cmd: \"L\", pt: new Point(isFilledArrow ? arrowL : 0, 0) },\r\n  ];\r\n  const figLine = new FigPath(segs, makeStrokeStyle(params));\r\n  figLine.update();\r\n\r\n  const tri: PathSeg[] = [\r\n    { cmd: \"M\", pt: new Point(arrowL, -arrowD) },\r\n    { cmd: \"L\", pt: new Point(0, 0) },\r\n    { cmd: \"L\", pt: new Point(arrowL, arrowD) },\r\n  ];\r\n  if (isFilledArrow) tri.push({ cmd: \"Z\" });\r\n  const triStyle: PathStyle = isFilledArrow\r\n    ? { fill: style.fill }\r\n    : makeStrokeStyle(params);\r\n  triStyle.join = \"miter\";\r\n  const figArrow = new FigPath(tri, triStyle);\r\n  figArrow.update();\r\n\r\n  const figOp = new FigFrame();\r\n  figOp.addFigure(figLine, true);\r\n  figOp.addFigure(figArrow, true);\r\n  return { figOp, irc: figOp.bounds };\r\n};\r\n\r\nconst opDict: Record<string, (params: ParamsOpDraw) => FigDef> = {\r\n  \"-->\": mathRightArrow, // opLongArrow,\r\n  \"--|>\": opLongArrow,\r\n  \"<==>\": mathBothArrow, // opLongBothArrow,\r\n  \"<--\": mathLeftArrow, // opLongLeftArrow,\r\n  \"<|--\": opLongLeftArrow,\r\n  \"<-->\": mathBiArrow, // opLongBiArrow,\r\n};\r\n\r\nconst addOpComment = (\r\n  frame: FigFrame,\r\n  opRect: Rect,\r\n  comm: ResultTextWithMarkup,\r\n  isTop: boolean\r\n): void => {\r\n  const { fig, irc } = comm;\r\n  const { bounds } = fig;\r\n  fig.org.set(\r\n    irc.left + opRect.width / 2 - irc.width / 2,\r\n    isTop ? -(bounds.bottom - irc.bottom) + opRect.top : opRect.bottom - irc.top\r\n  );\r\n  frame.addFigure(fig, true);\r\n};\r\n\r\nconst buildOpComment = (\r\n  comm: ChemComment,\r\n  props: ChemImgProps,\r\n  color: string | undefined\r\n): ResultTextWithMarkup => {\r\n  const tp = props.getStyleColored(\"opComment\", color);\r\n  return drawTextWithMarkup(comm.text, props, tp);\r\n};\r\n","import { ChemStyleId } from \"../drawSys/ChemStyleId\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { Rect } from \"../math/Rect\";\nimport { drawTextNear, moveNearFigure, NearTextType } from \"./drawTextNear\";\nimport { FigEllipse } from \"../drawSys/figures/FigEllipse\";\nimport { Point } from \"../math/Point\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { FigPath } from \"../drawSys/figures/FigPath\";\nimport { PathSeg } from \"../drawSys/path\";\n\ninterface ParamsDrawCharge {\n  charge: ChemCharge;\n  frame: FigFrame;\n  rect: Rect;\n  imgProps: ChemImgProps;\n  color?: string;\n  styleId?: ChemStyleId;\n  type?: NearTextType;\n}\n\nexport const drawCharge = ({\n  charge,\n  frame,\n  rect,\n  imgProps,\n  color,\n  styleId = \"nodeCharge\",\n  type,\n}: ParamsDrawCharge) => {\n  const style = imgProps.getStyleColored(styleId, color);\n  const pos = charge.pos ?? \"RT\";\n  const figTxt: Figure =\n    charge.text === \"+\" || charge.text === \"-\"\n      ? drawSpecialCharge({\n          frame,\n          rect,\n          text: charge.text,\n          isRound: charge.isRound,\n          pos,\n          style,\n          imgProps,\n          type,\n        })\n      : drawTextNear({\n          frame,\n          rcCore: rect,\n          text: charge.text,\n          imgProps,\n          style,\n          pos,\n          type,\n        });\n  frame.updateFigure(figTxt);\n};\n\ninterface ParamsDrawSpechialCharge {\n  frame: FigFrame;\n  rect: Rect;\n  text: \"+\" | \"-\";\n  isRound: boolean;\n  pos: CoeffPosOrAngle;\n  style: TextProps;\n  imgProps: ChemImgProps;\n  type: NearTextType;\n}\nconst drawSpecialCharge = (params: ParamsDrawSpechialCharge): Figure => {\n  const { frame, rect, text, isRound, pos, style, imgProps, type } = params;\n  const ff = style.font.getFontFace();\n  const lw = imgProps.lineWidth;\n  const w = style.font.getTextWidth(\"+\") * 0.9 - (text === \"-\" ? lw : 0);\n\n  // Для пиксельных поверхностей лучше было бы использовать вывод линий, а не закрашенных многоугольников\n  // Но пока этого не делаем. Считаем, что всё выводится в вектор.\n\n  // Координаты фигуры должны соответствовать принципам вывода текста. Т.е. начало в левом нижнем углу.\n  const maxX = w;\n  const maxY = -ff.capHeight;\n  const minY = 0; // -ff.descent;\n  const cx = maxX / 2;\n  const cy = (maxY + minY) / 2;\n  const lw2 = lw / 2;\n  const segs: PathSeg[] =\n    text === \"-\"\n      ? [\n          { cmd: \"M\", pt: new Point(0, cy - lw2) },\n          { cmd: \"H\", x: maxX },\n          { cmd: \"V\", y: lw, rel: true },\n          { cmd: \"H\", x: 0 },\n          { cmd: \"Z\" },\n        ]\n      : [\n          { cmd: \"M\", pt: new Point(0, cy - lw2) },\n          { cmd: \"H\", x: cx - lw2 },\n          { cmd: \"V\", y: cy - w / 2 },\n          { cmd: \"H\", rel: true, x: lw },\n          { cmd: \"V\", y: cy - lw2 },\n          { cmd: \"H\", x: maxX },\n          { cmd: \"V\", rel: true, y: lw },\n          { cmd: \"H\", x: cx + lw2 },\n          { cmd: \"V\", y: cy + w / 2 },\n          { cmd: \"H\", rel: true, x: -lw },\n          { cmd: \"V\", y: cy + lw2 },\n          { cmd: \"H\", x: 0 },\n          { cmd: \"Z\" },\n        ];\n  const fig = new FigFrame();\n  const figCharge = new FigPath(segs, { fill: style.style.fill });\n  figCharge.update();\n  figCharge.bounds.unite(new Rect(0, maxY, maxX, minY));\n  fig.addFigure(figCharge);\n\n  if (isRound) {\n    const bounds = new Rect(0, maxY, maxX, minY);\n    const r = Math.max(bounds.width, bounds.height) * 0.5;\n    const figR = new FigEllipse(bounds.center, new Point(r, r), {\n      stroke: style.style.fill,\n    });\n    fig.addFigure(figR);\n  }\n\n  fig.update();\n  const rcFig = fig.bounds.clone();\n  rcFig.A.y = -ff.ascent;\n  rcFig.B.y = -ff.descent;\n  moveNearFigure(fig, rcFig, pos, rect, imgProps, type);\n\n  frame.addFigure(fig);\n  frame.update();\n  return fig;\n};\n","import { ifDef } from \"../utils/ifDef\";\nimport { LewisDot } from \"../core/ChemNodeItem\";\nimport { Point, pointFromDeg } from \"../math/Point\";\nimport { Rect } from \"../math/Rect\";\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\n\nexport interface LewisDotExt {\n  c: Point;\n  p: Point;\n  color?: string;\n}\n\nconst div = 3.5;\n\nconst calcPos: ((rc: Rect) => Point)[] = [\n  (rc) => new Point(rc.right, rc.bottom - rc.height / div), // 0: right bottom\n  (rc) => new Point(rc.right - rc.width / div, rc.bottom), // 1: bottom right\n  (rc) => new Point(rc.left + rc.width / div, rc.bottom), // 2: bottom left\n  (rc) => new Point(rc.left, rc.bottom - rc.height / div), // 3: left bottom\n  (rc) => new Point(rc.left, rc.top + rc.height / div), // 4: left top\n  (rc) => new Point(rc.left + rc.width / div, rc.top), // 5: top left\n  (rc) => new Point(rc.right - rc.width / div, rc.top), // 6: top right\n  (rc) => new Point(rc.right, rc.top + rc.height / div), // 7: right top\n];\n\nexport const drawLewisShell = (\n  rc: Rect,\n  dots: LewisDot[],\n  props: ChemImgProps,\n  onDot: (dot: LewisDotExt) => void\n) => {\n  const c = rc.center;\n  const d = rc.width + rc.height;\n  dots.forEach(({ angle, pos, color, margin }) => {\n    const rcCur = rc.clone();\n    if (margin) rcCur.grow(margin * props.line);\n    ifDef(angle, (it) => {\n      const pExt = pointFromDeg(it).times(d).plus(c);\n      const { b: p } = rcCur.clip(c, pExt);\n      onDot({ c, p, color });\n    });\n    ifDef(pos, (it) => {\n      const fn = calcPos[it];\n      if (fn) onDot({ c, p: fn(rcCur), color });\n    });\n  });\n};\n","import { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { TextProps } from \"../drawSys/ChemImgProps\";\nimport { FigText } from \"../drawSys/figures/FigText\";\n\nexport const drawText = (\n  frame: FigFrame,\n  text: string,\n  style: TextProps\n): FigText => {\n  const fig = new FigText(text, style.font, style.style);\n  frame.addFigure(fig);\n  return fig;\n};\n","import { isClose } from \"../math\";\nimport { Rect } from \"../math/Rect\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { drawText } from \"./drawText\";\nimport { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { pointFromDeg } from \"../math/Point\";\nimport { Figure } from \"../drawSys/figures/Figure\";\n\nexport type NearTextType = \"bracket\" | undefined;\n\ninterface ParamsDrawTextNear {\n  frame: FigFrame;\n  rcCore: Rect;\n  text: string;\n  imgProps: ChemImgProps;\n  style: TextProps;\n  pos: CoeffPosOrAngle;\n  type?: NearTextType;\n}\n\nconst getShiftCoeff = (\n  imgProps: ChemImgProps,\n  pos: \"sup\" | \"sub\",\n  type: NearTextType\n): number => {\n  switch (type) {\n    case \"bracket\":\n      return pos === \"sup\" ? imgProps.bracketSupKY : imgProps.bracketSubKY;\n    default:\n      return pos === \"sup\" ? imgProps.supKY : imgProps.subKY;\n  }\n};\n\nconst makeRectExt = (\n  rcCore: Rect,\n  type: NearTextType,\n  imgProps: ChemImgProps\n): Rect => {\n  const rcCoreExt = rcCore.clone();\n  if (type === \"bracket\") {\n    const sp = imgProps.lineWidth * 2;\n    rcCoreExt.A.x -= sp;\n    rcCoreExt.B.x += sp;\n  }\n  return rcCoreExt;\n};\n\nexport const moveNearFigure = (\n  fig: Figure,\n  rcFig: Rect,\n  pos: CoeffPosOrAngle,\n  rcCore: Rect,\n  imgProps: ChemImgProps,\n  type: NearTextType\n) => {\n  const rcCoreExt = makeRectExt(rcCore, type, imgProps);\n\n  /* eslint no-param-reassign: \"off\" */\n  if (typeof pos === \"number\") {\n    const { center } = rcCoreExt;\n    const { b } = rcCoreExt.clip(\n      center,\n      center.plus(pointFromDeg(pos).times(rcCoreExt.width + rcCoreExt.height))\n    );\n    if (isClose(b.x, rcCoreExt.right)) {\n      fig.org.x = b.x - rcFig.left;\n    } else if (isClose(b.x, rcCoreExt.left)) {\n      fig.org.x = b.x - rcFig.right;\n    } else {\n      fig.org.x = b.x - rcFig.left - rcFig.width / 2;\n    }\n    if (isClose(b.y, rcCoreExt.top)) {\n      fig.org.y = b.y - rcFig.bottom;\n    } else if (isClose(b.y, rcCoreExt.bottom)) {\n      fig.org.y = b.y - rcFig.top;\n    } else {\n      fig.org.y = b.y - rcFig.top - rcFig.height / 2; // fontFace.ascent / 2;\n    }\n  } else {\n    if (pos[0] === \"R\") {\n      fig.org.x = rcCoreExt.right - rcFig.left;\n    } else if (pos[0] === \"L\") {\n      fig.org.x = rcCoreExt.left - rcFig.right;\n    } else if (pos[0] === \"C\") {\n      fig.org.x = rcCoreExt.cx - fig.bounds.width * 0.5;\n    }\n    if (pos[1] === \"T\") {\n      fig.org.y =\n        rcCoreExt.top +\n        rcFig.height * (1 - getShiftCoeff(imgProps, \"sup\", type));\n    } else if (pos[1] === \"B\") {\n      fig.org.y =\n        rcCoreExt.bottom + rcFig.height * getShiftCoeff(imgProps, \"sub\", type);\n    } else if (pos[1] === \"U\") {\n      fig.org.y = rcCoreExt.top - rcFig.bottom;\n    } else if (pos[1] === \"D\") {\n      fig.org.y = rcCoreExt.bottom - rcFig.top;\n    }\n  }\n};\n\nexport const drawTextNear = ({\n  frame,\n  rcCore,\n  text,\n  imgProps,\n  style,\n  pos,\n  type,\n}: ParamsDrawTextNear) => {\n  const rcCoreExt = makeRectExt(rcCore, type, imgProps);\n  const fig = drawText(frame, text, style);\n  const figFF = fig.font.getFontFace();\n  if (typeof pos === \"number\") {\n    const { center } = rcCoreExt;\n    const { b } = rcCoreExt.clip(\n      center,\n      center.plus(pointFromDeg(pos).times(rcCoreExt.width + rcCoreExt.height))\n    );\n    if (isClose(b.x, rcCoreExt.right)) {\n      fig.org.x = b.x;\n    } else if (isClose(b.x, rcCoreExt.left)) {\n      fig.org.x = b.x - fig.font.getTextWidth(text);\n    } else {\n      fig.org.x = b.x - fig.font.getTextWidth(text) / 2;\n    }\n    if (isClose(b.y, rcCoreExt.top)) {\n      fig.org.y = b.y + figFF.descent;\n    } else if (isClose(b.y, rcCoreExt.bottom)) {\n      fig.org.y = b.y + figFF.ascent;\n    } else {\n      fig.org.y = b.y + figFF.ascent / 2;\n    }\n  } else {\n    if (pos[0] === \"R\") {\n      fig.org.x = rcCoreExt.right;\n    } else if (pos[0] === \"L\") {\n      fig.org.x = -fig.bounds.width;\n    } else if (pos[0] === \"C\") {\n      fig.org.x = rcCoreExt.cx - fig.bounds.width * 0.5;\n    }\n    if (pos[1] === \"T\") {\n      fig.org.y =\n        rcCoreExt.top +\n        figFF.ascent * (1 - getShiftCoeff(imgProps, \"sup\", type));\n    } else if (pos[1] === \"B\") {\n      fig.org.y =\n        rcCoreExt.bottom + figFF.ascent * getShiftCoeff(imgProps, \"sub\", type);\n    } else if (pos[1] === \"U\") {\n      fig.org.y = rcCoreExt.top + figFF.descent;\n    } else if (pos[1] === \"D\") {\n      fig.org.y = rcCoreExt.bottom + figFF.ascent;\n    }\n  }\n  return fig;\n};\n","import { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { MarkupChunk, parseMarkup } from \"../utils/markup\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { Rect } from \"../math/Rect\";\nimport { FigText } from \"../drawSys/figures/FigText\";\nimport { is0 } from \"../math\";\nimport { LocalFont, TextStyle } from \"../drawSys/AbstractSurface\";\n\nexport interface ResultTextWithMarkup {\n  fig: Figure;\n  irc: Rect;\n}\n\ninterface ParamsDrawMarkup {\n  chunk: MarkupChunk;\n  imgProps: ChemImgProps;\n  font: LocalFont;\n  style: TextStyle;\n  scale: number;\n}\n\nconst drawMarkup = ({\n  chunk,\n  imgProps,\n  font,\n  style,\n  scale,\n}: ParamsDrawMarkup): ResultTextWithMarkup => {\n  const irc = new Rect(0, -font.getFontFace().ascent, 0, 0);\n  const fig = new FigFrame();\n  fig.label = \"markup\";\n  let xSup = 0;\n  let xSub = 0;\n  const updateX = () => {\n    xSup = fig.bounds.right;\n    xSub = xSup;\n  };\n  chunk.chunks.forEach((subChunk) => {\n    if (typeof subChunk === \"string\") {\n      const txFig = new FigText(subChunk, font, style);\n      txFig.org.x = fig.bounds.right;\n      fig.addFigure(txFig, true);\n      updateX();\n      return;\n    }\n    const { type, color } = subChunk;\n    if (type === \"sup\" || type === \"sub\") {\n      const isSup = type === \"sup\";\n      const newFont: LocalFont = font.createScaled\n        ? font.createScaled(scale)\n        : font;\n      const ff = newFont.getFontFace();\n      const height = ff.ascent - ff.descent;\n      const rs = drawMarkup({\n        chunk: subChunk,\n        font: newFont,\n        style,\n        scale,\n        imgProps,\n      });\n      const rsFig = rs.fig;\n      if (isSup) {\n        const dY = height * imgProps.supKY;\n        rsFig.org.set(xSup, irc.top + ff.ascent - dY);\n        xSup += rsFig.bounds.width;\n      } else {\n        const dY = height * imgProps.subKY;\n        rsFig.org.set(xSub, irc.bottom + dY);\n        xSub += rsFig.bounds.width;\n      }\n      fig.addFigure(rsFig, true);\n      return;\n    }\n    const newStyle = { ...style };\n    if (color) newStyle.fill = color;\n    const res = drawMarkup({\n      chunk: subChunk,\n      imgProps,\n      font,\n      style: newStyle,\n      scale,\n    });\n    res.fig.org.x = fig.bounds.right;\n    fig.addFigure(res.fig, true);\n    updateX();\n  });\n  irc.B.x = fig.bounds.right;\n  return { fig, irc };\n};\n\nexport const drawTextWithMarkup = (\n  text: string,\n  imgProps: ChemImgProps,\n  { font, style }: TextProps\n): ResultTextWithMarkup => {\n  const stdH = imgProps.stdStyle.font.getFontFace().ascent;\n  const subH = imgProps.getStyle(\"itemCount\").font.getFontFace().ascent;\n  const scale = is0(stdH - subH) ? 0.7 : subH / stdH;\n  const chunk = parseMarkup(text);\n  return drawMarkup({ chunk, imgProps, font, style, scale });\n};\n","import { Rect } from \"../math/Rect\";\nimport { FigText } from \"../drawSys/figures/FigText\";\n\nexport const getTextInternalRect = (figText: FigText): Rect => {\n  const rc = figText.bounds.clone();\n  rc.A.y = -figText.font.getFontFace().ascent;\n  rc.B.y = 0;\n  return rc;\n};\n","import { ChemAtom } from \"../core/ChemAtom\";\nimport { Lang } from \"../lang/Lang\";\nimport { drawTag } from \"../utils/xml/drawTag\";\nimport { escapeXml } from \"../utils/xml/escapeXml\";\n\nconst div = (\n  cls: string,\n  value: string | number,\n  attrs?: Record<string, string>,\n  tag?: string\n): string =>\n  `${\n    drawTag(tag ?? \"div\", { ...attrs, class: cls }) + escapeXml(String(value))\n  }</div>`;\n\nexport type FieldRenderFn = (elem: ChemAtom, stdOut: typeof div) => string;\n\nexport type CellRenderField = \"number\" | \"id\" | \"name\" | \"mass\";\n\nconst fieldsDict: Record<CellRenderField, FieldRenderFn> = {\n  number: (elem, stdOut) => stdOut(\"number\", elem.n),\n  id: (elem, stdOut) => stdOut(\"id\", elem.id),\n  name: (elem, stdOut) => stdOut(\"name\", Lang.tr(elem.id)),\n  mass: (elem, stdOut) => stdOut(\"mass\", elem.mass),\n};\n\nexport class CellRender {\n  fields: FieldRenderFn[];\n\n  constructor(\n    fields: (CellRenderField | FieldRenderFn)[] = [\n      \"number\",\n      \"id\",\n      \"name\",\n      \"mass\",\n    ]\n  ) {\n    // В старых JS версиях вместо массива fields может быть строка, разделенная запятыми\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = (fields as unknown as string).split(\",\") as CellRenderField[];\n    }\n    this.fields = fields.map((f) =>\n      typeof f === \"function\" ? f : fieldsDict[f]\n    );\n  }\n\n  draw(elem: ChemAtom): string {\n    return this.fields.map((field) => (field ? field(elem, div) : \"\")).join(\"\");\n  }\n}\n","/**\n * Site: https://chemistry-easy.ru/\n *\n * In certain circles, this version of the table is the most correct.\n * Although it does not correspond to the form adopted by IUPAC.\n * Discussion:\n * https://vk.com/topic-93343283_35170908\n * Images:\n * https://drive.google.com/drive/folders/1H8VT9UcX0UsWWIIiXh5O19C_FryArFYC\n */\n\nimport { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryBlockDLa } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [\n    { NCol: 19, NRow: 7 }, // 18 + Short column for lanthanides and actinides placeholder.\n    { NCol: 15, NRow: 2 },\n  ],\n  category: categoryBlockDLa,\n  points: {\n    He: [18, 0],\n    B: [13, 1],\n    Al: [13, 2],\n    Ti: [4, 3],\n    Zr: [4, 4],\n    Ce: [1, 0, 1],\n    Hf: [4, 5],\n    Th: [1, 1, 1],\n    Rf: [4, 6],\n  },\n  hardNotes: [\n    { text: \"*\", x: 3, y: 5, cls: \"chem-element f_block mtbl-note\" },\n    { text: \"*<br>*\", x: 3, y: 6, cls: \"chem-element f2_block mtbl-note\" },\n    { text: \"*\", x: 0, y: 0, tblN: 1, cls: \"chem-element f_block mtbl-note\" },\n    {\n      text: \"*<br>*\",\n      x: 0,\n      y: 1,\n      tblN: 1,\n      cls: \"chem-element f2_block mtbl-note\",\n    },\n  ],\n  drawGroups: fallingNumbers,\n  groupIds: \"1,2,3,,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\".split(\",\"),\n  groupCls: \"group-id\",\n  tableCls: \"mentable easy-chem-table\",\n  elementBoxCls: \"element-box\",\n};\n\nexport const tableRulesEasyChemistry = Object.freeze(rules);\n","/*\n * Короткая форма таблицы отменена ИЮПАК в 1989 году.\n * Из современной иностранной литературы короткая форма исключена полностью,\n * вместо неё используется длинная форма, (Std)\n * однако, благодаря своей привычности и распространённости, она все ещё периодически встречается в российских справочниках и пособиях\n * https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%BE%D1%82%D0%BA%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%BF%D0%B5%D1%80%D0%B8%D0%BE%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2\n */\n/* eslint-disable no-param-reassign */\n\nimport { Lang } from \"../lang/Lang\";\nimport { categoryBlock, subGroup } from \"./tableCategories\";\nimport { TableRules, TCell } from \"./TableRules\";\n\nexport const tableRulesShort: TableRules = {\n  tables: [\n    { NCol: 11, NRow: 11, periodCols: 2, groupRows: 2 },\n    { NCol: 15, NRow: 2 },\n  ],\n  points: {\n    H: [0, 0],\n    He: [10, 0],\n    Ne: [10, 1],\n    Ar: [10, 2],\n    Cu: [0, 4],\n    Kr: [10, 4],\n    Ag: [0, 6],\n    Xe: [10, 6],\n    La: [0, 0, 1],\n    Hf: [3, 7],\n    Au: [0, 8],\n    Rn: [10, 8],\n    Ac: [0, 1, 1],\n    Rf: [3, 9],\n    Rg: [0, 10],\n  },\n  flLanAct: true,\n  notes: { La: [2, 7], Ac: [2, 9] },\n\n  category: categoryBlock,\n  categoryExt: [subGroup],\n  groupIds:\n    \"I:a;b,II:a;b,III:a;b,IV:a;b,V:a;b,VI:a;b,VII:a;b,::R,VIII:b:LR,::LR,:a:L\".split(\n      \",\"\n    ),\n  groupCls: \"chem-cell\",\n\n  drawGroups({ cells, actualTables, rules }) {\n    const tdef = actualTables[0]!;\n    const t0 = cells[0]!;\n\n    for (let i = 0; i < tdef.NCol; i++) {\n      const v = rules.groupIds![i]!.split(\":\");\n      const p = {\n        cls: rules.groupCls,\n        rowspan: 2,\n        text: `${v[0]}<div class=\"mentable-subgroup-hd\">`,\n      };\n      if (v.length > 1) {\n        const w = v[1]!.split(\";\");\n        if (w.length === 2)\n          p.text += `<span class=\"left\">${w[0]}</span><span class=\"right\">${w[1]}</span>`;\n        else p.text += w[0];\n      }\n      if (v.length > 2) {\n        if (v[2]!.indexOf(\"L\") >= 0) p.cls += \" noleft\";\n        if (v[2]!.indexOf(\"R\") >= 0) p.cls += \" noright\";\n      }\n\n      p.text += \"</div>\";\n      t0[tdef.y1 - 2]![i + tdef.x1] = p;\n      t0[tdef.y1 - 1]![i + tdef.x1] = { colspan: 0 };\n    }\n  },\n\n  drawPeriods({ cells, actualTables }) {\n    // var i,p,\n    let n = 1;\n    const tdef = actualTables[0]!;\n    const t0 = cells[0]!;\n    for (let i = 0; i < tdef.NRow; i++) {\n      const p: TCell =\n        // eslint-disable-next-line no-bitwise\n        i < 3 || i & 1\n          ? { text: String(n++), cls: \"period-id\" }\n          : { colspan: 0 };\n      if (p && i >= 3) p.rowspan = 2;\n      t0[tdef.y1 + i]![tdef.x1 - 2] = p;\n    }\n    for (let i = 0; i < tdef.NRow; i++)\n      t0[tdef.y1 + i]![tdef.x1 - 1] = { text: String(i + 1), cls: \"period-id\" };\n  },\n  post({ cells }) {\n    if (this.flGroups && this.flPeriods) {\n      cells[0]![0]![0] = {\n        text: `${Lang.tr(\"Group\")}→`,\n        cls: \"mentable-text period-id\",\n        colspan: 2,\n      };\n      cells[0]![0]![1] = { colspan: 0 };\n      cells[0]![1]![0] = {\n        text: Lang.tr(\"Period\"),\n        cls: \"mentable-text period-id\",\n      };\n      cells[0]![1]![1]! = {\n        text: Lang.tr(\"Row\"),\n        cls: \"mentable-text period-id\",\n      };\n    }\n  },\n  pre({ cells, actualTables }) {\n    // Разметка. Колонки 0-6,10 имеют границы со всех сторон, 7,8,9-только сверху и снизу\n    //  var a,i,\n    // row,\n    const t0 = cells[0]!;\n    const tdef = actualTables[0]!;\n    for (let j = 0; j < tdef.NRow; j++) {\n      const row = t0[j + tdef.y1]!;\n      for (let i = 0; i < tdef.NCol; i++) {\n        row[i + tdef.x1] =\n          i > 6 && i < 10 ? { cls: \"chem-row\" } : { cls: \"chem-cell\" };\n      }\n    }\n  },\n};\n","/**\n * IUPAC Periodic Table of the Elements\n * https://iupac.org/what-we-do/periodic-table-of-elements/\n */\nimport { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryProps } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [\n    { NCol: 18, NRow: 7 },\n    { NCol: 15, NRow: 2 },\n  ],\n  category: categoryProps,\n  points: {\n    He: [17, 0],\n    B: [12, 1],\n    Al: [12, 2],\n    La: [0, 0, 1],\n    Hf: [3, 5],\n    Ac: [0, 1, 1],\n    Rf: [3, 6],\n  },\n  notes: { La: [2, 5], Ac: [2, 6] },\n  drawGroups: fallingNumbers,\n  groupIds: [\n    \"1A\",\n    \"2A\",\n    \"3B\",\n    \"4B\",\n    \"5B\",\n    \"6B\",\n    \"7B\",\n    \"┌──\",\n    \"─8B─\",\n    \"──┐\",\n    \"1B\",\n    \"2B\",\n    \"3A\",\n    \"4A\",\n    \"5A\",\n    \"6A\",\n    \"7A\",\n    \"8A\",\n  ],\n  groupCls: \"group-id\",\n};\n\nexport const tableRulesStd = Object.freeze(rules);\n","import { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryProps } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [{ NCol: 32, NRow: 7, ofsX: 1, ofsY: 1, width: 33, height: 8 }],\n  category: categoryProps,\n  points: {\n    H: [0, 0],\n    He: [31, 0],\n    B: [26, 1],\n    Al: [26, 2],\n    Sc: [16, 3],\n    Y: [16, 4],\n  },\n  groupIds:\n    \"1A,2A,,,,,,,,,,,,,,,3B,4B,5B,6B,7B,┌──,8B,──┐,1B,2B,3A,4A,5A,6A,7A,8A\".split(\n      \",\"\n    ),\n  groupCls: \"group-id\",\n  drawGroups: fallingNumbers,\n};\n\nexport const tableRulesWide = Object.freeze(rules);\n","import { Lang } from \"../lang/Lang\";\nimport { PeriodicTable } from \"../core/PeriodicTable\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { CellRender } from \"./CellRender\";\nimport { Category, TableConfigItemExt, TableRules, TCell } from \"./TableRules\";\nimport { tableRulesStd } from \"./TableRulesStd\";\nimport { drawTag } from \"../utils/xml/drawTag\";\n\nexport const drawPeriodicTable = (rules: TableRules = tableRulesStd) => {\n  const {\n    tables,\n    category,\n    categoryExt = [],\n    points,\n    notes,\n    cellFields,\n  } = rules;\n  const { cellRender = new CellRender(cellFields) } = rules;\n  const cells: TCell[][][] = [];\n  // Заготовка структкры\n  const actualTables: TableConfigItemExt[] = tables.map((srcItem, n) => {\n    const { NCol, NRow, ofsX = 0, ofsY = 0 } = srcItem;\n    const { width = NCol, height = NRow } = srcItem;\n    const tdef: TableConfigItemExt = {\n      ...srcItem,\n      width,\n      height,\n      ofsX,\n      ofsY,\n      w1: width,\n      h1: height,\n      x1: ofsX,\n      y1: ofsY,\n    };\n    if (n === 0) {\n      const { groupRows = 1, periodCols = 1 } = tdef;\n      if (rules.flGroups) {\n        tdef.y1 += groupRows;\n        tdef.h1 += groupRows;\n      }\n      if (rules.flPeriods) {\n        tdef.x1 += periodCols;\n        tdef.w1 += periodCols;\n      }\n    }\n    const row: TCell[][] = [];\n    for (let j = 0; j < tdef.h1; j++) {\n      row[j] = new Array<TCell>(tdef.w1);\n    }\n    cells[n] = row;\n    return tdef;\n  });\n  if (rules.pre) rules.pre({ cells, actualTables, rules });\n\n  // Развернуть свойства\n  const categories: Category[] = [\n    ...(category ? [category] : []),\n    ...categoryExt,\n  ];\n  const grpMaps = categories.map((curCat) => {\n    const catDict: Record<string, string> = {};\n    Object.entries(curCat).forEach(([catName, catValues]) => {\n      const list = Array.isArray(catValues) ? catValues : catValues.split(\",\");\n      list.forEach((catValue) => {\n        catDict[catValue] = catName;\n      });\n    });\n    return catDict;\n  });\n\n  // набор текущих значений для каждой группы свойств из списка grpMaps\n  let t = 0;\n  let tdef = actualTables[t]!;\n  let j = tdef.y1;\n  let i = tdef.x1;\n  const Ga = new Array(grpMaps.length);\n\n  PeriodicTable.elements.forEach((elem) => {\n    const { id } = elem;\n    ifDef(points[id], (pos) => {\n      t = pos[2] ?? 0;\n      tdef = actualTables[t]!;\n      i = pos[0] + tdef.x1;\n      j = pos[1] + tdef.y1;\n    });\n    let cls = \"chem-element\";\n    // перебираем все элементы grpMaps и достаём свойства, если они назначены на элемент\n    grpMaps.forEach((G, gm) => {\n      // очередная группа свойств\n      ifDef(G[id], (grp) => {\n        Ga[gm] = grp;\n      });\n      cls += ` ${Ga.join(\" \")}`;\n    });\n    cells[t]![j]![i] = { elem, cls };\n    if (++i === tdef.x1 + tdef.NCol) {\n      i = tdef.x1;\n      j++;\n    }\n  });\n\n  // Номера групп\n  if (rules.flGroups) {\n    if (rules.drawGroups) rules.drawGroups({ cells, actualTables, rules });\n    else\n      for (i = 0; i < tdef.NCol; i++)\n        cells[0]![tdef.y1 - 1]![tdef.x1 + i] = { text: String(i + 1) };\n  }\n\n  // Расставить номера периодов\n  tdef = actualTables[0]!;\n  if (rules.flPeriods) {\n    const { drawPeriods } = rules;\n    if (drawPeriods) {\n      drawPeriods({ cells, actualTables, rules });\n    } else {\n      for (i = 0; i < tdef.NRow; i++)\n        cells[0]![tdef.y1 + i]![tdef.x1 - 1] = {\n          text: String(i + 1),\n          cls: \"period-id\",\n        };\n    }\n  }\n\n  if (rules.post) rules.post({ cells, actualTables, rules });\n\n  // Подписи к лантаноидам и актиноидам\n  const LanActMap: Record<string, string> = {\n    La: `57-71<br>${Lang.tr(\"Lanthanides\")}`,\n    Ac: `89-103<br>${Lang.tr(\"Actinides\")}`,\n  };\n  if (rules.flLanAct && notes) {\n    tdef = actualTables[0]!;\n    Object.entries(notes).forEach(([id, pos]) => {\n      cells[0]![pos[1] + tdef.y1]![pos[0] + tdef.x1] = {\n        text: LanActMap[id],\n        cls: \"chem-cell mentable-text\",\n      };\n    });\n  }\n  // Безусловные подписи\n  ifDef(rules.hardNotes, (list) =>\n    list.forEach(({ text, x, y, tblN = 0, cls }) => {\n      const curTable = actualTables[tblN]!;\n      cells[tblN]![y + curTable.y1]![x + curTable.x1] = { text, cls };\n    })\n  );\n\n  // Финальный рендер\n  let s = \"\";\n  cells.forEach((curTable, n) => {\n    s +=\n      ifDef(rules.beginTable, (beginTable) => beginTable(n, rules)) ??\n      drawTag(\"table\", { class: rules.tableCls || \"mentable\" });\n    curTable.forEach((row) => {\n      s += \"<tr>\";\n      for (const c of row) {\n        if (!c) {\n          s += \"<td></td>\";\n        } else if (c.colspan !== 0) {\n          s += `<td class=\"${c.cls || \"chem-element\"}\"`;\n          if (c.colspan) s += ` colspan=\"${c.colspan}\"`;\n          if (c.rowspan) s += ` rowspan=\"${c.rowspan}\"`;\n          s += \">\";\n          if (c.elem) {\n            if (rules.elementBoxCls) {\n              s += drawTag(\"div\", { class: rules.elementBoxCls });\n            }\n            s += cellRender.draw(c.elem);\n            if (rules.elementBoxCls) {\n              s += \"</div>\";\n            }\n          } else if (c.text) s += c.text;\n          s += \"</td>\";\n        }\n      }\n      s += \"</tr>\";\n    });\n    s += \"</table>\";\n  });\n  return s;\n};\n","import { ParamsTableCallback } from \"./TableRules\";\n\n/**  Функция, выводящая номера из массива rules.groupIds над первой заполненной ячейкой\n */\nexport const fallingNumbers = ({\n  cells,\n  actualTables,\n  rules,\n}: ParamsTableCallback) => {\n  const t0 = cells[0]!;\n  const tdef = actualTables[0]!;\n  const X: number[] = [];\n  const Y: number[] = [];\n  let y: number;\n\n  for (let j = 0; j < tdef.NCol; j++) {\n    const x = tdef.x1 + j;\n    X.push(x);\n    // опускаемся по столбцу до последней незаполненной ячейки. первая всегда незаполнена. для H и He она же последняя.\n    y = tdef.y1;\n    while (y < t0.length && !t0[y]![x]) y++;\n    Y.push(y);\n    if (y < t0.length) {\n      t0[y - 1]![x] = { text: rules.groupIds?.[j] ?? \"\", cls: rules.groupCls };\n    }\n  }\n  // Объединение ячеек 7,8,9\n  y = Y[7]!;\n  if (\n    (rules.groupIds?.[8]?.indexOf(\"8B\") ?? -1) >= 0 &&\n    y < t0.length &&\n    y === Y[8] &&\n    Y[8] === Y[9]\n  ) {\n    const x = X[7] ?? 0;\n    y--;\n    t0[y]![x]!.text += t0[y]![x + 1]!.text! + t0[y]![x + 2]!.text!;\n    t0[y]![x]!.colspan = 3;\n    t0[y]![x + 1]!.colspan = 0;\n    t0[y]![x + 2]!.colspan = 0;\n  }\n};\n","import { PeriodicTable } from \"../core/PeriodicTable\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { Lang } from \"../lang/Lang\";\nimport { TCategories } from \"./tableCategories\";\n\n// Поиск категории для элемента\nconst GrpCache = new Map<TCategories, Record<string, string>>();\n\nexport const findCategory = (\n  table: TCategories,\n  item: string,\n  locale?: string\n) => {\n  if (!GrpCache.has(table)) {\n    const dict: Record<string, string> = {};\n    GrpCache.set(table, dict);\n    const revMap = Object.entries(table).reduce(\n      (map, [categoryKey, pkList]) => {\n        pkList.split(\",\").forEach((id) => {\n          // eslint-disable-next-line no-param-reassign\n          map[id] = categoryKey;\n        });\n        return map;\n      },\n      {} as Record<string, string>\n    );\n    let curCategory = \"\";\n    PeriodicTable.elements.forEach(({ id }) => {\n      ifDef(revMap[id], (it) => {\n        curCategory = it;\n      });\n      dict[id] = curCategory;\n    });\n  }\n  let cat = GrpCache.get(table)![item] ?? \"\";\n  cat = cat.replace(/-/g, \" \").replace(/_/g, \"-\");\n  cat = Lang.tr(cat, {}, locale);\n  return cat;\n};\n","export type TCategories = Record<string, string>;\n\n// Распределение элементов по цветовым группам\n// по электронам\nexport const categoryBlock: TCategories = {\n  s_block: \"H,Na,K,Rb,Cs,Fr\",\n  p_block: \"B,Al,Ga,In,Tl,Nh\",\n  d_block: \"Sc,Y,Hf,Rf\",\n  f_block: \"La,Ac\",\n};\n\n// La and Ac in d-blocks\nexport const categoryBlockDLa: TCategories = {\n  s_block: \"H,Na,K,Rb,Cs,Fr\",\n  p_block: \"B,Al,Ga,In,Tl,Nh\",\n  d_block: \"Sc,Y,La,Hf,Ac,Rf\",\n  f_block: \"Ce\",\n  f2_block: \"Th\",\n};\n\n// по свойствам\nexport const categoryProps: TCategories = {\n  \"Alkali-metals\": \"Li,Na,K,Rb,Cs,Fr\",\n  \"Alkaline-earth-metals\": \"Be,Mg,Ca,Sr,Ba,Ra\",\n  Lanthanides: \"La\",\n  Actinides: \"Ac\",\n  \"Transition-metals\": \"Sc,Y,Hf,Rf,Cn\",\n  \"Post-transition-metals\": \"Al,Ga,In,Tl,Nh\",\n  Metalloids: \"B,Si,Ge,Sb\",\n  \"Other-nonmetals\": \"H,C,P,Se\",\n  Halogens: \"F,Cl,Br,I,At,Ts\",\n  \"Noble-gases\": \"He,Ne,Ar,Kr,Xe,Rn,Og\",\n  // 'Unknown-props': 'Mt'\n};\n\nexport const subGroup = {\n  subgr_a: \"H,Ga,In,Tl\",\n  subgr_b: \"Sc,Y,La,Ac\",\n};\n","import { ChemNodeItem } from \"../../core/ChemNodeItem\";\r\nimport { TextNode } from \"./TextNode\";\r\nimport { locateAtomNumber } from \"../../inspectors/locateAtomNumber\";\r\nimport { ChemK } from \"../../core/ChemK\";\r\nimport { ifDef } from \"../../utils/ifDef\";\r\n\r\nexport const addItemProps = (\r\n  obj: ChemNodeItem,\r\n  addItem: (node: TextNode) => void\r\n) => {\r\n  const { color } = obj;\r\n  if (obj.n.isSpecified())\r\n    addItem({\r\n      type: \"k\",\r\n      k: obj.n,\r\n      pos: \"RB\",\r\n      kType: \"item\",\r\n      color,\r\n    });\r\n  const rawAtomNum = obj.atomNum;\r\n  let atomMass: number | undefined;\r\n  if (typeof rawAtomNum === \"number\" || rawAtomNum === \"\") {\r\n    // Вывести двухэтажную конструкцию: масса/атомный номер слева от элемента\r\n    const atomNum = rawAtomNum === \"\" ? locateAtomNumber(obj) : rawAtomNum;\r\n    atomMass = obj.mass ?? 0;\r\n    if (atomNum !== undefined) {\r\n      addItem({\r\n        type: \"k\",\r\n        k: new ChemK(atomNum),\r\n        pos: \"LB\",\r\n        kType: \"atomNum\",\r\n        color,\r\n      });\r\n    }\r\n  } else {\r\n    atomMass = ifDef(obj.mass, (it) => it);\r\n  }\r\n  if (atomMass !== undefined)\r\n    addItem({\r\n      type: \"k\",\r\n      k: new ChemK(atomMass),\r\n      pos: \"LT\",\r\n      kType: \"mass\",\r\n      color,\r\n    });\r\n\r\n  if (obj.charge) {\r\n    addItem({\r\n      type: \"charge\",\r\n      charge: obj.charge,\r\n      color,\r\n      pos: \"T\",\r\n    });\r\n  }\r\n};\r\n","import { isLeftCoeff } from \"../../types/CoeffPos\";\r\nimport { ChemObj } from \"../../core/ChemObj\";\r\nimport { GroupType, TextNode } from \"./TextNode\";\r\nimport { addItemProps } from \"./addItemProps\";\r\nimport { createTextOp } from \"./createTextOp\";\r\nimport { splitRichText } from \"./splitRichText\";\r\nimport { correctBondsDirection } from \"./correctBondsDirection\";\r\n\r\n/* eslint no-param-reassign: \"off\" */\r\n\r\nexport const buildTextNodes = (srcExpr: ChemObj): TextNode => {\r\n  const rootNode: TextNode = { type: \"group\", groupType: \"expr\" };\r\n  const stack: [TextNode] | TextNode[] = [rootNode];\r\n\r\n  const addItemTo = (item: TextNode, owner: TextNode) => {\r\n    owner.items = owner.items ?? [];\r\n    owner.items.push(item);\r\n  };\r\n  const addItem = (item: TextNode) => addItemTo(item, stack[0]);\r\n  const pushLevel = (node: TextNode) => {\r\n    addItem(node);\r\n    stack.unshift(node);\r\n    return node;\r\n  };\r\n  const pushGroupLevel = (groupType?: GroupType) =>\r\n    pushLevel({ type: \"group\", groupType });\r\n  const popLevel = (): TextNode | undefined => stack.shift();\r\n\r\n  let prevEntity: \"agent\" | \"op\" | undefined;\r\n  let autoNode = false;\r\n  let firstItem: TextNode | undefined;\r\n  let lastItem: TextNode | undefined;\r\n  let atomColor: string | undefined;\r\n  let itemColor: string | undefined;\r\n\r\n  const addSpace = (curEntityType: \"agent\" | \"op\") => {\r\n    if (prevEntity) {\r\n      const node: TextNode = {\r\n        type: \"space\",\r\n        spaceType: \"agentOp\",\r\n      };\r\n      if (prevEntity === \"agent\" && curEntityType === \"agent\") {\r\n        node.spaceType = \"agentAgent\";\r\n      } else if (prevEntity === \"op\" && curEntityType === \"op\") {\r\n        node.spaceType = \"opOp\";\r\n      }\r\n      addItem(node);\r\n    }\r\n    prevEntity = curEntityType;\r\n  };\r\n\r\n  srcExpr.walk({\r\n    agentPre(obj) {\r\n      addSpace(\"agent\");\r\n      pushGroupLevel(\"agent\");\r\n      if (obj.n.isSpecified())\r\n        addItem({\r\n          type: \"k\",\r\n          k: obj.n,\r\n          kType: \"agent\",\r\n          color: obj.n.color,\r\n        });\r\n    },\r\n    agentPost() {\r\n      correctBondsDirection(stack[0]);\r\n      popLevel();\r\n    },\r\n    atom(obj) {\r\n      if (autoNode) return;\r\n      addItem({\r\n        type: \"atom\",\r\n        atom: obj,\r\n        color: atomColor ?? itemColor,\r\n      });\r\n    },\r\n    bond(obj) {\r\n      addItem({ type: \"bond\", bond: obj, color: obj.color });\r\n    },\r\n    bracketBegin(obj) {\r\n      pushLevel({\r\n        type: \"brackets\",\r\n        color: obj.color,\r\n      });\r\n      pushGroupLevel();\r\n      addItem({\r\n        type: \"bracket\",\r\n        text: obj.text,\r\n        begin: true,\r\n        color: obj.color,\r\n      });\r\n    },\r\n    bracketEnd(obj) {\r\n      addItem({\r\n        type: \"bracket\",\r\n        text: obj.text,\r\n        begin: false,\r\n        color: obj.color,\r\n      });\r\n      correctBondsDirection(stack[0]);\r\n      // Есть особый случай, когда buildTextNode вызывается непосредственно для ChemBtacketEnd\r\n      if (stack.length > 1) popLevel();\r\n      if (obj.n.isSpecified())\r\n        addItem({\r\n          type: \"k\",\r\n          k: obj.n,\r\n          kType: \"bracket\",\r\n          pos: isLeftCoeff(obj.n.pos) ? \"LB\" : \"RB\",\r\n        });\r\n      if (obj.charge)\r\n        addItem({\r\n          type: \"charge\",\r\n          charge: obj.charge,\r\n          pos: obj.charge.isLeft ? \"LT\" : \"RT\",\r\n        });\r\n      popLevel();\r\n    },\r\n    comma() {\r\n      addItem({ type: \"comma\" });\r\n    },\r\n    comment(obj) {\r\n      addItem({\r\n        type: \"comment\",\r\n        comment: obj,\r\n        items: [splitRichText(obj.text, itemColor)],\r\n        color: itemColor,\r\n      });\r\n    },\r\n    custom(obj) {\r\n      addItem({\r\n        type: \"custom\",\r\n        custom: obj,\r\n        items: [splitRichText(obj.text, itemColor)],\r\n        color: itemColor,\r\n      });\r\n    },\r\n    itemPre(obj) {\r\n      if (autoNode) return;\r\n      itemColor = obj.color;\r\n      atomColor = obj.atomColor;\r\n      const itemNode = pushLevel({\r\n        type: \"item\",\r\n        item: obj,\r\n        color: obj.color,\r\n      });\r\n      firstItem = firstItem || itemNode;\r\n      lastItem = itemNode;\r\n    },\r\n    itemPost(obj) {\r\n      if (autoNode) return;\r\n      addItemProps(obj, addItem);\r\n      popLevel();\r\n    },\r\n    mul(obj) {\r\n      if (!obj.isFirst)\r\n        addItem({\r\n          type: \"mul\",\r\n          color: obj.color,\r\n        });\r\n      pushGroupLevel();\r\n      if (obj.n.isSpecified()) {\r\n        addItem({ type: \"k\", k: obj.n, kType: \"mul\" });\r\n      }\r\n    },\r\n    mulEnd() {\r\n      popLevel();\r\n    },\r\n    nodePre(obj) {\r\n      firstItem = undefined;\r\n      lastItem = undefined;\r\n      autoNode = obj.autoMode;\r\n      pushGroupLevel(\"node\");\r\n    },\r\n    nodePost(obj) {\r\n      popLevel();\r\n      if (obj.charge) {\r\n        const { isLeft } = obj.charge;\r\n        const itemNode = isLeft ? firstItem : lastItem;\r\n        if (itemNode) {\r\n          addItemTo(\r\n            {\r\n              type: \"charge\",\r\n              charge: obj.charge,\r\n              pos: isLeft ? \"LT\" : \"RT\",\r\n            },\r\n            itemNode\r\n          );\r\n        }\r\n      }\r\n    },\r\n    operation(obj) {\r\n      addSpace(\"op\");\r\n      addItem(createTextOp(obj));\r\n    },\r\n\r\n    radical(obj) {\r\n      addItem({\r\n        type: \"radical\",\r\n        radical: obj,\r\n        color: itemColor,\r\n      });\r\n    },\r\n  });\r\n\r\n  return rootNode;\r\n};\r\n","import { TextNode } from \"./TextNode\";\n\nexport const cloneTextNode = (node: TextNode): TextNode => ({\n  ...node,\n  items: node.items?.map(cloneTextNode),\n});\n","import { TextNode } from \"./TextNode\";\n\nexport const correctBondsDirection = (\n  groupNode: TextNode | undefined\n): void => {\n  if (groupNode?.type !== \"group\") return;\n  const { items } = groupNode;\n  if (!items?.some((node) => node.type === \"bond\" && node.bond.isNeg)) {\n    return;\n  }\n  items.reverse();\n  const n = items.length - 1;\n  if (n > 0 && items[0]?.type === \"bracket\" && items[n]?.type === \"bracket\") {\n    const tmp = items[0]!;\n    items[0] = items[n]!;\n    items[n] = tmp;\n  }\n};\n","import { ChemOp } from \"../../core/ChemOp\";\r\nimport { TextNode } from \"./TextNode\";\r\nimport { splitRichText } from \"./splitRichText\";\r\n\r\nexport const createTextOp = (op: ChemOp): TextNode => {\r\n  const opItem: TextNode = {\r\n    type: \"op\",\r\n    op,\r\n    color: op.color,\r\n  };\r\n  const { commentPre, commentPost } = op;\r\n  if (!commentPre && !commentPost) {\r\n    return opItem;\r\n  }\r\n  const items: TextNode[] = [opItem];\r\n  const colItem: TextNode = {\r\n    type: \"column\",\r\n    columnType: \"op\",\r\n    color: op.color,\r\n    items,\r\n  };\r\n  if (commentPre)\r\n    items.push({\r\n      ...splitRichText(commentPre.text, op.color, true),\r\n      pos: \"T\",\r\n    });\r\n  if (commentPost)\r\n    items.push({\r\n      ...splitRichText(commentPost.text, op.color, true),\r\n      pos: \"B\",\r\n    });\r\n  return colItem;\r\n};\r\n","export const dictKeys = (dict: Record<string, unknown>): string =>\n  Object.entries(dict)\n    .filter(([, value]) => value !== undefined)\n    .map(([key]) => key)\n    .sort()\n    .join(\",\");\n","export * from \"./buildTextNodes\";\nexport * from \"./TextNode\";\n","/* eslint no-param-reassign: \"off\" */\n/* eslint prefer-destructuring: \"off\" */\n\nexport const optimizeColors = <T extends { color?: string }>(\n  node: T,\n  getList: (owner: T) => T[] | undefined\n) => {\n  const list = getList(node);\n  if (!list) return;\n  const { color: nodeColor } = node;\n  list.forEach((it) => optimizeColors(it, getList));\n\n  const subColors = new Set<string>();\n  list.forEach((it) => subColors.add(it.color ?? \"\"));\n  const aColors = Array.from(subColors).sort();\n  if (aColors.length === 1 && aColors[0]) {\n    // Если все подчинённые элементы имеют одинаковый и непустой цвет, то он становится цветом узла, а из элементов убирается\n    node.color = aColors[0];\n    list.forEach((it) => {\n      delete it.color;\n    });\n  } else if (aColors.length === 2 && !aColors[0] && aColors[1] === node.color) {\n    // Если одни подчиненные имеют такой же цвет, как узел, а у других цевет не указан, то просто убрать цвет у подчиненных\n    list.forEach((it) => {\n      delete it.color;\n    });\n  } else if (nodeColor && subColors.has(nodeColor)) {\n    // Если есть элементы с таким же цветом как узел, то убрать цвет только у них\n    list.forEach((it) => {\n      if (it.color === nodeColor) {\n        delete it.color;\n      }\n    });\n  }\n};\n","import { TextNode } from \"./TextNode\";\n\ntype ColKey = \"C\" | \"T\" | \"B\";\n\nexport const splitColumn = (nodes: TextNode[] = []) => {\n  const dict: Partial<Record<ColKey, TextNode[]>> = {};\n  nodes.forEach((it) => {\n    const { pos } = it;\n    const key: ColKey = pos === \"T\" || pos === \"B\" ? pos : \"C\";\n    dict[key] = [...(dict[key] ?? []), it];\n  });\n  return dict;\n};\n","import { MarkupChunk, parseMarkup } from \"../../utils/markup\";\r\nimport { TextNode } from \"./TextNode\";\r\n\r\nexport const splitRichText = (\r\n  srcText: string,\r\n  textColor: string | undefined,\r\n  needSrc?: boolean\r\n): TextNode => {\r\n  const onChunk = (\r\n    chunk: MarkupChunk | string,\r\n    color: string | undefined\r\n  ): TextNode => {\r\n    if (typeof chunk === \"string\") {\r\n      return { type: \"text\", text: chunk, color };\r\n    }\r\n    const locColor = chunk.color ?? color;\r\n    const res: TextNode = {\r\n      type: \"richText\",\r\n      items: chunk.chunks.map((c) => onChunk(c, locColor)),\r\n      color: locColor,\r\n    };\r\n    if (needSrc) {\r\n      res.src = srcText;\r\n    }\r\n    if (chunk.type === \"sub\") {\r\n      res.pos = \"RB\";\r\n    } else if (chunk.type === \"sup\") {\r\n      res.pos = \"RT\";\r\n    }\r\n    return res;\r\n  };\r\n  return onChunk(groupScripted(parseMarkup(srcText)), textColor);\r\n};\r\n\r\n/**\r\n * H2SO4 -> <rt>\r\n *   <text>H</text>\r\n *   <rt pos=RB><text>2</text></rt>\r\n *\r\n *   <text>S</text>\r\n *\r\n *   <text>O</text>\r\n *   <rt pos=RB><text>4</text>\r\n * </rt>\r\n *                ==>\r\n * <rt>\r\n *   <rt>\r\n *     <text>H</text>\r\n *     <rt pos=RB><text>2</text></rt>\r\n *   </rt>\r\n *   <text>S</text>\r\n *   <rt>\r\n *     <text>O</text>\r\n *     <rt pos=RB><text>4</text></rt>\r\n *   </rt>\r\n * </rt>\r\n * Такая структура позволяет получить группы с индексами. н.р. <msub><mi>H</mi><mn>2</mn></msub>\r\n * @param chunk\r\n */\r\nconst groupScripted = (chunk: MarkupChunk): MarkupChunk => {\r\n  const { chunks: ungrouped } = chunk;\r\n  const grouped: (MarkupChunk | string)[][] | [(MarkupChunk | string)[]] = [[]];\r\n  ungrouped.forEach((subChunk) => {\r\n    if (\r\n      typeof subChunk === \"string\" ||\r\n      (subChunk.type !== \"sub\" && subChunk.type !== \"sup\")\r\n    ) {\r\n      grouped.unshift([]);\r\n    }\r\n    grouped[0].push(subChunk);\r\n  });\r\n  grouped.reverse();\r\n  const optimized: (MarkupChunk | string)[] = grouped\r\n    .filter((group) => group.length > 0)\r\n    .map((group) => {\r\n      if (group.length === 1) return group[0]!;\r\n      return {\r\n        type: \"\",\r\n        chunks: group,\r\n      };\r\n    });\r\n  return { ...chunk, chunks: optimized };\r\n};\r\n","import { ifDef } from \"../../utils/ifDef\";\nimport { TextNode, TextPosition } from \"./TextNode\";\n\nexport type ScriptKey = \"C\" | \"RT\" | \"RB\" | \"LT\" | \"LB\";\nconst scriptKeys: Readonly<Record<TextPosition, ScriptKey>> = {\n  C: \"C\",\n  T: \"C\",\n  B: \"C\",\n  LT: \"LT\",\n  RT: \"RT\",\n  LB: \"LB\",\n  RB: \"RB\",\n};\n\nexport const splitScripts = (nodes: TextNode[] = []) => {\n  const dict: Partial<Record<ScriptKey, TextNode[]>> = {};\n  nodes.forEach((it) => {\n    const { pos } = it;\n    const key: ScriptKey = ifDef(pos, (p) => scriptKeys[p]) ?? \"C\";\n    dict[key] = [...(dict[key] ?? []), it];\n  });\n  return dict;\n};\n","import { ChemAtom } from \"../../core/ChemAtom\";\r\nimport { ChemK } from \"../../core/ChemK\";\r\nimport { ifDef } from \"../../utils/ifDef\";\r\n\r\nexport type CCTFunc = {\r\n  name: string;\r\n  params?: string[];\r\n};\r\n\r\n/**\r\n * CharChem Text Node\r\n */\r\nexport type CCTNode = {\r\n  colorType?: \"item\" | \"atom\";\r\n  color?: string;\r\n  content: string | CCTNode[];\r\n  order?: number;\r\n  funcs?: CCTFunc[];\r\n\r\n  mass?: ChemK;\r\n  atomNum?: ChemK;\r\n  atom?: ChemAtom;\r\n  atomColor?: string;\r\n};\r\n\r\nexport const addFunc = (node: CCTNode, f: CCTFunc) => {\r\n  // eslint-disable-next-line no-param-reassign\r\n  node.funcs = node.funcs ?? [];\r\n  node.funcs.push(f);\r\n};\r\n\r\nexport const funcStr = (f?: CCTFunc): string => {\r\n  if (!f) return \"\";\r\n  return `$${f.name}(${ifDef(f.params, (it) => it.join(\",\")) ?? \"\"})`;\r\n};\r\n","import { TextNode } from \"../buildTextNodes\";\r\nimport { buildCharChemTextNodes } from \"./buildCharChemTextNodes\";\r\nimport { addFunc, CCTFunc, CCTNode, funcStr } from \"./CCTNode\";\r\n\r\n/* eslint no-param-reassign: \"off\" */\r\n\r\nexport const buildCharChemText = (srcNode: TextNode): string => {\r\n  const dstNode = buildCharChemTextNodes(srcNode);\r\n\r\n  const flatList: CCTNode[] = [];\r\n  correctItemColor(dstNode);\r\n  makeFlat(dstNode, flatList);\r\n  setFlatColors(flatList);\r\n  setAtomColors(flatList);\r\n  return cctn2str(dstNode);\r\n};\r\n\r\nconst cctn2str = ({ content, funcs }: CCTNode): string => {\r\n  let code: string =\r\n    typeof content === \"string\" ? content : content.map(cctn2str).join(\"\");\r\n  if (funcs) {\r\n    code = funcs.map(funcStr).join(\"\") + code;\r\n  }\r\n  return code;\r\n};\r\n\r\nconst correctItemColor = (node: CCTNode) => {\r\n  const { content, colorType, color } = node;\r\n  if (\r\n    colorType === \"item\" &&\r\n    Array.isArray(content) &&\r\n    content[0]?.colorType === \"atom\" &&\r\n    content[0]?.color !== color\r\n  ) {\r\n    content[0].atomColor = content[0].color;\r\n    content.forEach((subNode) => {\r\n      subNode.color = color;\r\n    });\r\n  }\r\n  if (Array.isArray(content)) {\r\n    content.forEach(correctItemColor);\r\n  }\r\n};\r\n\r\nconst setAtomColors = (list: CCTNode[]) => {\r\n  const atoms = list.filter(({ colorType }) => colorType === \"atom\");\r\n  type Group = {\r\n    first: CCTNode;\r\n    count: number;\r\n    color: string | undefined;\r\n    type?: \"single\" | \"none\";\r\n  };\r\n  const groups: Group[] = [];\r\n  let prevGroup: Group | undefined;\r\n  atoms.forEach((node) => {\r\n    if (!prevGroup || prevGroup.color !== node.atomColor) {\r\n      prevGroup = {\r\n        first: node,\r\n        color: node.atomColor === node.color ? undefined : node.atomColor,\r\n        count: 1,\r\n      };\r\n      groups.push(prevGroup);\r\n    } else {\r\n      prevGroup.count++;\r\n    }\r\n  });\r\n  prevGroup = undefined;\r\n  groups.forEach((gr) => {\r\n    if (prevGroup?.count === 1 && !gr.color) {\r\n      prevGroup.type = \"single\";\r\n      gr.type = \"none\";\r\n    }\r\n    prevGroup = gr;\r\n  });\r\n  if (groups[0] && !groups[0].color) {\r\n    groups[0].type = \"none\";\r\n  }\r\n  groups.forEach(({ first, color, type }) => {\r\n    if (type !== \"none\") {\r\n      const fn: CCTFunc =\r\n        type === \"single\"\r\n          ? {\r\n              name: \"atomColor1\",\r\n              params: [color ?? \"\"],\r\n            }\r\n          : {\r\n              name: \"atomColor\",\r\n              params: [color ?? \"\"],\r\n            };\r\n      addFunc(first, fn);\r\n    }\r\n  });\r\n};\r\n\r\nconst makeFlat = (node: CCTNode, flatList: CCTNode[]) => {\r\n  if (Array.isArray(node.content)) {\r\n    node.content.forEach((it) => makeFlat(it, flatList));\r\n  } else {\r\n    flatList.push(node);\r\n  }\r\n};\r\n\r\nconst setFlatColors = (flatList: CCTNode[]) => {\r\n  let prevColor: string | undefined;\r\n  flatList.forEach((node) => {\r\n    const { color } = node;\r\n    if (prevColor !== color) {\r\n      addFunc(node, {\r\n        name: \"color\",\r\n        params: color ? [color] : [],\r\n      });\r\n      prevColor = color;\r\n    }\r\n  });\r\n};\r\n","import { isShortRadical } from \"../../core/ChemRadical\";\r\nimport { CoeffType, TextNode } from \"../buildTextNodes\";\r\nimport { addFunc, CCTNode } from \"./CCTNode\";\r\n\r\n/* eslint no-param-reassign: \"off\" */\r\n\r\nexport const buildCharChemTextNodes = (srcNode: TextNode): CCTNode => {\r\n  const dstNode: CCTNode = {\r\n    content: [],\r\n  };\r\n  onTextNode(srcNode, dstNode);\r\n  return dstNode;\r\n};\r\n\r\nconst add = (dstNode: CCTNode, newNode: CCTNode) => {\r\n  if (Array.isArray(dstNode.content)) {\r\n    dstNode.content.push(newNode);\r\n  }\r\n};\r\n\r\nconst enum Order {\r\n  agent = -2,\r\n  mul = -1,\r\n  commPre = -1,\r\n  commPost = 1,\r\n  oxi,\r\n  coeff,\r\n  charge,\r\n}\r\n\r\nconst onTextNode = (srcNode: TextNode, dstNode: CCTNode) => {\r\n  const addText = (content: string, order?: number) => {\r\n    add(dstNode, {\r\n      color: srcNode.color,\r\n      content,\r\n      order,\r\n    });\r\n  };\r\n  switch (srcNode.type) {\r\n    case \"space\":\r\n      addText(\" \");\r\n      return;\r\n    case \"atom\":\r\n      add(dstNode, {\r\n        colorType: \"atom\",\r\n        color: srcNode.color,\r\n        content: srcNode.atom.id,\r\n      });\r\n      dstNode.atom = srcNode.atom;\r\n      return;\r\n    case \"bond\":\r\n      addText(fromDict(srcNode.bond.tx, bondDict));\r\n      return;\r\n    case \"bracket\":\r\n      addText(fromDict(srcNode.text, brackets));\r\n      return;\r\n    case \"brackets\":\r\n      onGroup(srcNode, dstNode);\r\n      return;\r\n    case \"charge\":\r\n      addText(\r\n        (chargePosDict[srcNode.pos ?? \"\"] ?? \"^@\").replace(\r\n          \"@\",\r\n          srcNode.charge.text.toLowerCase()\r\n        ),\r\n        srcNode.pos === \"T\" ? Order.oxi : Order.charge\r\n      );\r\n      return;\r\n    case \"column\":\r\n      if (srcNode.columnType === \"op\") {\r\n        onGroup(srcNode, dstNode);\r\n      }\r\n      break;\r\n    case \"comma\":\r\n      addText(\",\");\r\n      return;\r\n    case \"comment\":\r\n      addText(`\"${srcNode.comment.text}\"`);\r\n      return;\r\n    case \"custom\":\r\n      addText(`{${srcNode.custom.text}}`);\r\n      return;\r\n    case \"group\":\r\n      onGroup(srcNode, dstNode);\r\n      return;\r\n    case \"item\":\r\n      onItem(srcNode, dstNode);\r\n      return;\r\n    case \"k\":\r\n      if (srcNode.kType === \"mass\") {\r\n        dstNode.mass = srcNode.k;\r\n      } else if (srcNode.kType === \"atomNum\") {\r\n        dstNode.atomNum = srcNode.k;\r\n      } else {\r\n        addText(\r\n          (srcNode.pos === \"LB\" ? \"`\" : \"\") +\r\n            (srcNode.k.isNumber()\r\n              ? srcNode.k.toString()\r\n              : `'${srcNode.k.toString()}'`),\r\n          kOrder[srcNode.kType] ?? Order.coeff\r\n        );\r\n      }\r\n      return;\r\n    case \"mul\":\r\n      addText(\"*\");\r\n      return;\r\n    case \"op\":\r\n      addText(srcNode.op.srcText);\r\n      return;\r\n    case \"radical\":\r\n      {\r\n        const { label } = srcNode.radical;\r\n        addText(isShortRadical(label) ? label : `{${label}}`);\r\n      }\r\n      return;\r\n    case \"richText\":\r\n      if (srcNode.src && (srcNode.pos === \"T\" || srcNode.pos === \"B\")) {\r\n        addText(\r\n          `\"${srcNode.src}\"`,\r\n          srcNode.pos === \"T\" ? Order.commPre : Order.commPost\r\n        );\r\n      }\r\n      break;\r\n    // case \"text\":\r\n    //   break;\r\n    default:\r\n      break;\r\n  }\r\n};\r\n\r\nconst fromDict = (key: string, dict: Record<string, string>): string =>\r\n  dict[key] ?? key;\r\n\r\nconst bondDict: Record<string, string> = {\r\n  \"≡\": \"%\",\r\n};\r\n\r\nconst kOrder: Partial<Record<CoeffType, Order>> = {\r\n  agent: Order.agent,\r\n  mul: Order.mul,\r\n};\r\n\r\nconst chargePosDict: Record<string, string> = {\r\n  T: \"(@)\",\r\n  LT: \"`^@\",\r\n};\r\nconst brackets: Record<string, string> = {\r\n  \"{\": \"{{\",\r\n  \"}\": \"}}\",\r\n};\r\n\r\nconst onGroup = (srcNode: TextNode, dstNode: CCTNode) => {\r\n  const group = {\r\n    content: [],\r\n  } satisfies CCTNode;\r\n  add(dstNode, group);\r\n  srcNode.items?.forEach((node) => onTextNode(node, group));\r\n  group.content.sort(cmpOrder);\r\n};\r\n\r\nconst onItem = (srcNode: TextNode, dstNode: CCTNode) => {\r\n  const itemNode: CCTNode = {\r\n    colorType: \"item\",\r\n    color: srcNode.color,\r\n    content: [],\r\n  };\r\n  add(dstNode, itemNode);\r\n  srcNode?.items?.forEach((node) => {\r\n    onTextNode(node, itemNode);\r\n  });\r\n  if (Array.isArray(itemNode.content)) {\r\n    itemNode.content.sort(cmpOrder);\r\n    const chargePos = itemNode.content.findIndex(\r\n      ({ order }) => order === Order.charge\r\n    );\r\n    if (chargePos >= 0) {\r\n      add(dstNode, itemNode.content[chargePos]!);\r\n      itemNode.content.splice(chargePos, 1);\r\n    }\r\n  }\r\n  if (itemNode.mass) {\r\n    if (itemNode.atomNum) {\r\n      const params: string[] = [itemNode.mass.toString()];\r\n      if (!itemNode.atom) {\r\n        params.push(itemNode.atomNum.toString());\r\n      }\r\n      addFunc(itemNode, {\r\n        name: \"nM\",\r\n        params,\r\n      });\r\n    } else {\r\n      addFunc(itemNode, {\r\n        name: \"M\",\r\n        params: [itemNode.mass.toString()],\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst cmpOrder = (a: CCTNode, b: CCTNode) => (a.order ?? 0) - (b.order ?? 0);\r\n","export type PoorHtmlPart = \"agentK\" | \"custom\" | \"comment\";\r\n\r\nexport type OptionsHtmlPoor = {\r\n  oxidationState?: \"ignore\" | \"sup\";\r\n  opComments?: \"text\" | \"ignore\" | \"script\";\r\n  tags?: \"std\" | \"span\";\r\n};\r\n\r\nexport const stdTagsMap: Record<PoorHtmlPart, string> = {\r\n  agentK: \"b\",\r\n  comment: \"em\",\r\n  custom: \"i\",\r\n};\r\n","import { TextNode } from \"../buildTextNodes\";\r\nimport { optimizeColors } from \"../buildTextNodes/optimizeColors\";\r\nimport { renderXmlNodes } from \"../xmlNode/renderXmlNode\";\r\nimport { XmlNode } from \"../xmlNode/XmlNode\";\r\nimport { htmlPoorNodes } from \"./htmlPoorNodes\";\r\nimport { OptionsHtmlPoor } from \"./OptionsHtmlPoor\";\r\n\r\n/* eslint no-param-reassign: \"off\" */\r\n\r\nexport const htmlPoor = (\r\n  srcNode: TextNode,\r\n  options?: OptionsHtmlPoor\r\n): string => {\r\n  const dstNodes = htmlPoorNodes(srcNode, options);\r\n  dstNodes?.forEach((n) =>\r\n    optimizeColors(n, (owner) =>\r\n      Array.isArray(owner.content) ? owner.content : undefined\r\n    )\r\n  );\r\n  hideSpanNodes(dstNodes);\r\n  return renderXmlNodes(dstNodes, { noSelfClosed: true });\r\n};\r\n\r\nconst hideSpanNodes = (nodes: XmlNode[] | undefined) =>\r\n  nodes?.forEach(hideSpans);\r\n\r\nconst hideSpans = (node: XmlNode) => {\r\n  if (node.tag === \"span\" && !node.attrs && !node.color) {\r\n    node.tag = \"\";\r\n  }\r\n  if (Array.isArray(node.content)) {\r\n    hideSpanNodes(node.content);\r\n  }\r\n};\r\n","import { ChemOp } from \"../../core/ChemOp\";\r\nimport { addAll } from \"../../utils/addAll\";\r\nimport { TextNode } from \"../buildTextNodes\";\r\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\r\nimport { splitScripts } from \"../buildTextNodes/splitScripts\";\r\nimport { XmlNode } from \"../xmlNode/XmlNode\";\r\nimport { OptionsHtmlPoor, PoorHtmlPart, stdTagsMap } from \"./OptionsHtmlPoor\";\r\nimport { textInsideTag } from \"../../utils/xml/textInsideTag\";\r\n\r\nexport const htmlPoorNodes = (\r\n  srcNode: TextNode,\r\n  options?: OptionsHtmlPoor\r\n): XmlNode[] | undefined => createHtmlPoorNodes(srcNode, options);\r\n\r\nconst createHtmlPoorNodes = (\r\n  node: TextNode,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] | undefined => {\r\n  const textTag = (content: string, tag: string = \"span\"): XmlNode[] => [\r\n    { tag, color: node.color, content },\r\n  ];\r\n  switch (node.type) {\r\n    case \"atom\":\r\n      return textTag(node.atom.id);\r\n    case \"bond\":\r\n      return textTag(node.bond.tx);\r\n    case \"bracket\":\r\n      return textTag(node.text);\r\n    case \"brackets\":\r\n      return makeScripted(node, ctx, (items) => nodesList(items, ctx));\r\n    case \"charge\":\r\n      return textTag(node.charge.text);\r\n    case \"column\":\r\n      if (node.columnType === \"op\") return makeComplexOp(node, ctx);\r\n      break;\r\n    case \"comma\":\r\n      return textTag(\",\");\r\n    case \"comment\":\r\n      return optGroupTag(specTag(\"comment\", ctx), node.color, node.items, ctx);\r\n    case \"custom\":\r\n      return optGroupTag(specTag(\"custom\", ctx), node.color, node.items, ctx);\r\n    case \"group\":\r\n      return nodesList(node.items, ctx);\r\n    case \"item\":\r\n      return makeItem(node, ctx);\r\n    case \"k\":\r\n      return textTag(\r\n        node.k.toString(),\r\n        node.kType === \"agent\" ? specTag(\"agentK\", ctx) : undefined\r\n      );\r\n    case \"mul\":\r\n      return textTag(\"∙\");\r\n    case \"op\":\r\n      return operationCode(node, node.op);\r\n    case \"radical\":\r\n      return textTag(node.radical.label);\r\n    case \"richText\":\r\n      return makeRichText(node, ctx);\r\n    case \"space\":\r\n      return textTag(\" \");\r\n    case \"text\":\r\n      return textTag(textInsideTag(node.text));\r\n    default:\r\n      break;\r\n  }\r\n  return undefined;\r\n};\r\n\r\nconst nodesList = (\r\n  items: TextNode[] | undefined,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] =>\r\n  (items ?? [])\r\n    .map((it) => createHtmlPoorNodes(it, ctx) ?? [])\r\n    .flatMap((it) => it);\r\n\r\nconst optGroupTag = (\r\n  tag: string,\r\n  color: string | undefined,\r\n  items: TextNode[] | undefined,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] => {\r\n  const content = nodesList(items, ctx);\r\n  if (content.length === 0) return [];\r\n  return [{ tag, color, content }];\r\n};\r\n\r\nconst specTag = (\r\n  type: PoorHtmlPart,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): string => {\r\n  if (!ctx?.tags || ctx?.tags === \"std\") {\r\n    return stdTagsMap[type] ?? \"span\";\r\n  }\r\n  return \"span\";\r\n};\r\n\r\nconst makeScripted = (\r\n  srcNode: TextNode,\r\n  ctx: OptionsHtmlPoor | undefined,\r\n  makeCenter: (items: TextNode[]) => XmlNode[]\r\n): XmlNode[] => {\r\n  const { items = [] } = srcNode;\r\n  const scr = splitScripts(items);\r\n  return [\r\n    ...optGroupTag(\"sup\", undefined, scr.LT, ctx),\r\n    ...optGroupTag(\"sub\", undefined, scr.LB, ctx),\r\n    ...(scr.C ? makeCenter(scr.C) : []),\r\n    ...optGroupTag(\"sub\", undefined, scr.RB, ctx),\r\n    ...optGroupTag(\"sup\", undefined, scr.RT, ctx),\r\n  ];\r\n};\r\n\r\nconst operationCode = (node: TextNode, op: ChemOp): XmlNode[] => [\r\n  { tag: \"span\", color: node.color, content: op.dstText },\r\n];\r\n\r\nconst makeComplexOp = (\r\n  node: TextNode,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] => {\r\n  const { C, T, B } = splitColumn(node.items ?? []);\r\n  const mode = ctx?.opComments ?? \"text\";\r\n  const result: XmlNode[] = [];\r\n  const onComment = (textNodes: TextNode[] | undefined, scriptTag: string) => {\r\n    if (mode !== \"ignore\") {\r\n      if (mode === \"script\") {\r\n        result.push({\r\n          tag: scriptTag,\r\n          content: nodesList(textNodes, ctx),\r\n        });\r\n      } else {\r\n        addAll(result, nodesList(textNodes, ctx));\r\n      }\r\n    }\r\n  };\r\n  onComment(T, \"sup\");\r\n  addAll(result, nodesList(C, ctx));\r\n  onComment(B, \"sub\");\r\n  return result;\r\n};\r\n\r\nconst makeItem = (\r\n  srcNode: TextNode,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] => [\r\n  {\r\n    tag: \"span\",\r\n    content: makeScripted(srcNode, ctx, (items) => {\r\n      const col = splitColumn(items);\r\n      return [\r\n        ...nodesList(col.C, ctx),\r\n        ...(col.T && ctx?.oxidationState === \"sup\"\r\n          ? optGroupTag(\"sup\", undefined, col.T, ctx)\r\n          : []),\r\n      ];\r\n    }),\r\n  },\r\n];\r\n\r\nconst makeRichText = (\r\n  node: TextNode,\r\n  ctx: OptionsHtmlPoor | undefined\r\n): XmlNode[] => {\r\n  const scr = splitScripts(node.items ?? []);\r\n  const center = nodesList(scr.C, ctx);\r\n  if (!scr.RB && !scr.RT) {\r\n    return center;\r\n  }\r\n  return [\r\n    {\r\n      tag: \"span\",\r\n      color: node.color,\r\n      content: [\r\n        ...center,\r\n        ...optGroupTag(\"sub\", undefined, scr.RB, ctx),\r\n        ...optGroupTag(\"sup\", undefined, scr.RT, ctx),\r\n      ],\r\n    },\r\n  ];\r\n};\r\n","export * from \"./htmlPoor\";\r\n","export type HtmlRichClass =\n  | \"agent\"\n  | \"agent-k\"\n  | \"arrow-bidir\"\n  | \"arrow-bkwd\"\n  | \"arrow-both\"\n  | \"arrow-both-left\"\n  | \"arrow-both-right\"\n  | \"arrow-fwd\"\n  | \"charge\"\n  | \"expr\"\n  | \"has-over\"\n  | \"minus\"\n  | \"mul\"\n  | \"node-item\"\n  | \"op\"\n  | \"op-arrow\"\n  | \"op-both\"\n  | \"op-code\"\n  | \"op-comment\"\n  | \"op-footer\"\n  | \"op-head\"\n  | \"over\"\n  | \"supsub\"\n  | \"supsub-left\"\n  | \"symbols\";\n\nexport const htmlRichCls = (clsCode: HtmlRichClass | HtmlRichClass[]): string =>\n  (Array.isArray(clsCode) ? clsCode : [clsCode])\n    .map((c) => `cch-${c}`)\n    .join(\" \");\n","import { TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { createHtmlRichNodes, CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichMap } from \"./HtmlRichMap\";\nimport { OptionsHtmlRich } from \"./OptionsHtmlRich\";\n\nexport type ResultHtmlRich = {\n  nodes: XmlNode[] | undefined;\n  srcMap?: HtmlRichMap;\n};\n\nexport const buildHtmlRich = (\n  srcNode: TextNode,\n  options?: OptionsHtmlRich\n): ResultHtmlRich => {\n  const rootNode = cloneTextNode(srcNode);\n  // optimizeColors(rootNode, (n) => Array.isArray(n.items) ? n.items : undefined);\n\n  const ctx: CtxHtmlRich = { options };\n  if (options?.srcMap) {\n    ctx.srcMap = {};\n  }\n  const nodes = createHtmlRichNodes(rootNode, ctx);\n  // v-- stack overflow\n  // nodes.forEach(it => optimizeColors(it, n => Array.isArray(it.content) ? it.content : undefined));\n  const res: ResultHtmlRich = { nodes };\n  if (ctx.srcMap) res.srcMap = ctx.srcMap;\n  return res;\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { ChemOp } from \"../../core/ChemOp\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichClass } from \"./HtmlRichClasses\";\nimport { makeCchTag } from \"./makeCchTag\";\n\n// .cch-op tag\nexport const cchOperation = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  op: ChemOp\n): XmlNode => {\n  const arrow = cchArrowTag(ctx, srcNode, op);\n  const cls: HtmlRichClass[] = [\"op\"];\n  const arrows: XmlNode[] = [];\n  if (arrow) {\n    cls.push(\"op-arrow\");\n    arrows.push(arrow);\n  }\n  return makeCchTag({\n    ctx,\n    srcNode,\n    cls,\n    attrs: { \"data-op\": op.srcText },\n    content: [\n      ...arrows,\n      makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: \"op-code\",\n        content: op.dstText,\n      }),\n    ],\n  });\n};\n\nconst cchArrowTag = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  op: ChemOp\n): XmlNode | undefined => {\n  const { srcText } = op;\n  if (srcText === \"-->\" || srcText === \"-->\") {\n    return longRightArrow(ctx);\n  }\n  if (srcText === \"<--\" || srcText === \"<|--\") {\n    return longLeftArrow(ctx);\n  }\n  if (srcText === \"<==>\") {\n    return makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"arrow-both\",\n      content: [bothArrowsLeft(ctx), bothArrowsRight(ctx)],\n    });\n  }\n  if (srcText === \"<-->\" || srcText === \"<|--|>\") {\n    return makeCchTag({\n      ctx,\n      srcNode,\n      cls: [\"arrow-bidir\"],\n      content: [longLeftArrow(ctx), longRightArrow(ctx)],\n    });\n  }\n  return undefined;\n};\n\nconst figure = ({\n  ctx,\n  width,\n  height,\n  d,\n  cls,\n}: {\n  ctx: CtxHtmlRich;\n  width: number;\n  height: number;\n  d: string;\n  cls: HtmlRichClass;\n}): XmlNode => {\n  const attrs: XmlAttrs = {\n    width: `${width / 1000}em`,\n    height: `${height / 1000}em`,\n    viewBox: `0 0 ${width} ${height}`,\n    preserveAspectRatio: \"xMaxYMin slice\",\n    fill: \"currentColor\",\n  };\n  return makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls,\n    content: [\n      {\n        tag: \"svg\",\n        attrs,\n        content: [\n          {\n            tag: \"path\",\n            attrs: { d },\n          },\n        ],\n      },\n    ],\n  });\n};\n\nconst longRightArrow = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    cls: \"arrow-fwd\",\n    width: 400000,\n    height: 522,\n    d: `M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n  151.7 139 205zm0 0v40h399900v-40z`,\n  });\n\nconst longLeftArrow = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 522,\n    cls: \"arrow-bkwd\",\n    d: `M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z`,\n  });\n\nconst bothArrowsLeft = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 901,\n    cls: \"arrow-both-left\",\n    d: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,\n  });\n\nconst bothArrowsRight = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 901,\n    cls: \"arrow-both-right\",\n    d: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n  -27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n  13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n  -84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n  -119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n  -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n  151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,\n  });\n","import { addAll } from \"../../utils/addAll\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { splitScripts } from \"../buildTextNodes/splitScripts\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { HtmlRichClass, htmlRichCls } from \"./HtmlRichClasses\";\nimport { HtmlRichMap } from \"./HtmlRichMap\";\nimport { OptionsHtmlRich } from \"./OptionsHtmlRich\";\nimport { addClassToXmlNode } from \"../xmlNode/addClassToXmlNode\";\nimport { makeCchTag } from \"./makeCchTag\";\nimport { cchOperation } from \"./cchOperation\";\nimport { textInsideTag } from \"../../utils/xml/textInsideTag\";\n\n/*\n Приняты следующие допущения.\n Агент.\n - все вложенные конструкции (узлы и скобки) раскрываются в плоский список элементов\n - не предполагается наличие подстрочных индексов\n - надстрочными индексами считаются только степени окисления\n - если есть хотя бы один надстрочный индекс, то у сверху резервируется padding,\n   а сами индексы выводятся при помощи position:absolute. \n   padding нужен, чтобы они не вылезали за границы формулы.\n*/\n\nexport type CtxHtmlRich = {\n  options?: OptionsHtmlRich;\n  srcMap?: HtmlRichMap;\n};\n\nexport const createHtmlRichNodes = (\n  srcNode: TextNode,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  const textTag = (content: string, cls?: HtmlRichClass) => [\n    makeCchTag({ ctx, srcNode, content, cls }),\n  ];\n  switch (srcNode.type) {\n    case \"atom\":\n      return textTag(srcNode.atom.id);\n    case \"bond\":\n      return textTag(bondMap[srcNode.bond.tx] ?? srcNode.bond.tx);\n    case \"bracket\":\n      return textTag(srcNode.text);\n    case \"brackets\":\n      return makeScripted(srcNode, ctx, (nodes) => nodesList(nodes, ctx));\n    case \"charge\":\n      return makeCharge(srcNode, srcNode.charge.text, ctx);\n    case \"column\":\n      if (srcNode.columnType === \"op\") return makeComplexOp(srcNode, ctx);\n      return [];\n    case \"comma\":\n      return textTag(\",\");\n    case \"comment\":\n      return makeRichText(srcNode, ctx);\n    case \"custom\":\n      return [\n        makeCchTag({\n          ctx,\n          srcNode,\n          cls: \"symbols\",\n          content: nodesList(srcNode.items, ctx),\n        }),\n      ];\n    case \"group\":\n      if (srcNode.groupType === \"node\" || !srcNode.groupType) {\n        return nodesList(srcNode.items, ctx);\n      }\n      return makeGroup(srcNode, srcNode.groupType, ctx);\n    case \"item\":\n      return makeItem(srcNode, ctx);\n    case \"k\":\n      return textTag(\n        srcNode.k.toString(),\n        srcNode.kType === \"agent\" ? \"agent-k\" : undefined\n      );\n    case \"mul\":\n      return textTag(\"∙\", \"mul\");\n    case \"op\":\n      return [cchOperation(ctx, srcNode, srcNode.op)];\n    case \"radical\":\n      return textTag(srcNode.radical.label);\n    case \"richText\":\n      return makeRichText(srcNode, ctx);\n    case \"space\":\n      return []; // implemented by gap in .cch-expr\n    case \"text\":\n      return textTag(textInsideTag(srcNode.text));\n    default:\n      break;\n  }\n  return [];\n};\n\nconst bondMap: Record<string, string> = {\n  \"-\": \"–\",\n};\n\nconst nodesList = (\n  items: TextNode[] | undefined,\n  ctx: CtxHtmlRich\n): XmlNode[] =>\n  (items ?? []).map((it) => createHtmlRichNodes(it, ctx)).flatMap((it) => it);\n\nconst hasOver = (srcNode: TextNode): boolean => {\n  if (srcNode.type === \"item\") {\n    return (srcNode.items ?? []).some((it) => it.pos === \"T\");\n  }\n  return (srcNode.items ?? []).some(hasOver);\n};\n\nconst makeGroup = (\n  srcNode: TextNode,\n  groupType: string | undefined,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  let cls: HtmlRichClass | HtmlRichClass[] | undefined;\n  if (groupType === \"expr\") {\n    cls = \"expr\";\n  } else if (groupType === \"agent\") {\n    cls = [\"agent\"];\n    if (hasOver(srcNode)) cls.push(\"has-over\");\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls,\n      content: () => nodesList(srcNode.items, ctx),\n    }),\n  ];\n};\n\nconst optionalGroup = (\n  list: TextNode[] | undefined,\n  ctx: CtxHtmlRich,\n  cls?: HtmlRichClass | HtmlRichClass[]\n): XmlNode => {\n  let tag: XmlNode | undefined;\n  if (list?.length === 1) {\n    const n = nodesList(list, ctx);\n    if (n.length === 1) tag = n[0]!;\n  }\n  if (!tag) {\n    tag = makeCchTag({\n      ctx,\n      srcNode: undefined,\n      content: () => nodesList(list, ctx),\n    });\n  }\n  if (cls) {\n    addClassToXmlNode(tag, htmlRichCls(cls));\n  }\n  return tag;\n};\n\nconst makeItem = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  // Если нужно оптимизировать количество тегов, то конечно лучше выдавать result\n  // Но если нужно иметь возможность при наведении курсора находить элемент узла, то нужен дополнительный тег\n  const content = () =>\n    makeScripted(srcNode, ctx, (items) => makeColumn(splitColumn(items), ctx));\n  if (!ctx.srcMap) {\n    return content();\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      content,\n      cls: \"node-item\",\n    }),\n  ];\n};\n\nconst makeScripted = (\n  srcNode: TextNode,\n  ctx: CtxHtmlRich,\n  makeCenter: (items: TextNode[]) => XmlNode[]\n): XmlNode[] => {\n  const { items = [] } = srcNode;\n  const result: XmlNode[] = [];\n  const scr = splitScripts(items);\n  const addScripts = (\n    top: TextNode[] | undefined,\n    bottom: TextNode[] | undefined,\n    left: boolean\n  ) => {\n    result.push(\n      makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: left ? [\"supsub\", \"supsub-left\"] : \"supsub\",\n        content: () => [optionalGroup(top, ctx), optionalGroup(bottom, ctx)],\n      })\n    );\n  };\n  if (scr.LT || scr.LB) addScripts(scr.LT, scr.LB, true);\n  if (scr.C) {\n    addAll(result, makeCenter(scr.C));\n  }\n  if (scr.RT || scr.RB) addScripts(scr.RT, scr.RB, false);\n  return result;\n};\n\nconst makeColumn = (\n  col: ReturnType<typeof splitColumn>,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  if (!col.T && !col.B) {\n    return nodesList(col.C, ctx);\n  }\n  const colItems: XmlNode[] = [optionalGroup(col.C, ctx)];\n  let cls: HtmlRichClass | undefined;\n  if (col.T) {\n    cls = \"over\";\n    colItems.push(optionalGroup(col.T, ctx));\n  }\n  const box = makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls,\n    content: colItems,\n  });\n  return [box];\n};\n\nconst makeCharge = (\n  srcNode: TextNode,\n  chargeText: string,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  const create = (value: string) => {\n    if (value === \"-\") {\n      return makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: \"minus\",\n        content: \"–\",\n      });\n    }\n    return makeCchTag({ ctx, content: value, srcNode: undefined });\n  };\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"charge\",\n      content: chargeText.includes(\"-\")\n        ? () => splitChargeText(chargeText, create)\n        : chargeText,\n    }),\n  ];\n};\n\nconst splitChargeText = (\n  text: string,\n  create: (value: string) => XmlNode\n): XmlNode[] =>\n  text\n    .split(/(-)/)\n    .filter((s) => !!s)\n    .map(create);\n\nconst makeRichText = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  const scr = splitScripts(srcNode.items ?? []);\n  if (!scr.RB && !scr.RT) {\n    return nodesList(scr.C, ctx);\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"symbols\",\n      content: () => [\n        ...nodesList(scr.C, ctx),\n        makeCchTag({\n          ctx,\n          srcNode: undefined,\n          cls: \"supsub\",\n          content: () => [\n            optionalGroup(scr.RT, ctx),\n            optionalGroup(scr.RB, ctx),\n          ],\n        }),\n      ],\n    }),\n  ];\n};\n\nconst opComment = (ctx: CtxHtmlRich, items: TextNode[]): XmlNode =>\n  makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls: \"op-comment\",\n    content: () => nodesList(items, ctx),\n  });\n\nconst opContainer = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  cls: HtmlRichClass,\n  content: () => XmlNode[]\n): XmlNode[] => [makeCchTag({ ctx, srcNode, cls, content })];\n\nconst makeComplexOp = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  const { C: center, T: top, B: bottom } = splitColumn(srcNode.items ?? []);\n  const opCode = (): XmlNode => optionalGroup(center, ctx, \"op-code\");\n  if (top && bottom) {\n    return opContainer(ctx, srcNode, \"op-both\", () => [\n      opComment(ctx, top),\n      opCode(),\n      opComment(ctx, bottom),\n    ]);\n  }\n  if (top) {\n    return opContainer(ctx, srcNode, \"op-head\", () => [\n      opComment(ctx, top),\n      opCode(),\n    ]);\n  }\n  if (bottom) {\n    return opContainer(ctx, srcNode, \"op-footer\", () => [\n      opCode(),\n      opComment(ctx, bottom),\n    ]);\n  }\n  return [];\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichClass, htmlRichCls } from \"./HtmlRichClasses\";\n\nexport const makeCchTag = (p: {\n  ctx: CtxHtmlRich;\n  srcNode: TextNode | undefined;\n  cls?: HtmlRichClass | HtmlRichClass[];\n  attrs?: XmlAttrs;\n  content?: XmlNode[\"content\"] | (() => XmlNode[\"content\"]);\n}): XmlNode => {\n  const { content, ctx, srcNode, cls } = p;\n  const node: XmlNode = {\n    tag: \"span\",\n  };\n  if (p.attrs) node.attrs = p.attrs;\n  if (srcNode?.color) {\n    node.color = srcNode.color;\n  }\n  const setAttr = (name: string, value: string) => {\n    let { attrs } = node;\n    if (!attrs) {\n      attrs = {};\n      node.attrs = attrs;\n    }\n    attrs[name] = value;\n  };\n  if (ctx.options?.idGen) {\n    const id = ctx.options.idGen(srcNode);\n    if (id) {\n      setAttr(\"id\", id);\n      if (ctx.srcMap && srcNode) {\n        ctx.srcMap[id] = { txtNode: srcNode };\n      }\n    }\n  }\n  if (cls) {\n    setAttr(\"class\", htmlRichCls(cls));\n  }\n  if (content) {\n    node.content = typeof content === \"function\" ? content() : content;\n  }\n  return node;\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\n\nexport type MathMLOptions = {\n  namespace?: boolean | string;\n};\n\nexport const mathMLRootAttrs = (options?: MathMLOptions): XmlAttrs => {\n  const res: XmlAttrs = {};\n  let ns = options?.namespace;\n  if (ns === undefined || ns === true)\n    ns = \"http://www.w3.org/1998/Math/MathML\";\n  if (ns) {\n    res.xmlns = ns;\n  }\n  return res;\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { TextNode } from \"../buildTextNodes/TextNode\";\nimport { optimizeXmlColors } from \"../xmlNode/optimizeXmlColors\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { createMathMLNode } from \"./createMathMLNode\";\nimport { CtxCreateMathMLNode } from \"./CtxCreateMathMLNode\";\nimport { MathMLOptions, mathMLRootAttrs } from \"./MathMLOptions\";\n\nexport const buildMathML = (\n  rootNode: TextNode,\n  options?: MathMLOptions\n): XmlNode => {\n  const ctx: CtxCreateMathMLNode = {};\n  const dstNode: XmlNode = {\n    tag: \"math\",\n    attrs: mathMLRootAttrs(options),\n    content: ifDef(createMathMLNode(rootNode, ctx), (it) => [it]),\n  };\n  optimizeXmlColors(dstNode);\n  return dstNode;\n};\n","import { textInsideTag } from \"../../utils/xml/textInsideTag\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { TextNode } from \"../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxCreateMathMLNode } from \"./CtxCreateMathMLNode\";\nimport { mathColumn } from \"./utils/mathColumn\";\nimport { mathItem } from \"./utils/mathItem\";\nimport { mathOptRow } from \"./utils/mathOptRow\";\nimport { mathRichText } from \"./utils/mathRichText\";\nimport { mathScripted } from \"./utils/mathScripted\";\nimport { mathText } from \"./utils/mathText\";\nimport { onNodeItem } from \"./utils/onNodeItem\";\n\nconst customNode = (\n  srcNode: TextNode,\n  ctx: CtxCreateMathMLNode\n): XmlNode | undefined => {\n  // в отличие от comment, тут основной тег mi\n  const customCtx = {\n    ...ctx,\n    textMode: \"custom\",\n  } satisfies CtxCreateMathMLNode;\n  return mathOptRow(srcNode.items ?? [], (node: TextNode) =>\n    createMathMLNode(node, customCtx)\n  );\n};\n\nexport const createMathMLNode = (\n  srcNode: TextNode,\n  ctx: CtxCreateMathMLNode\n): XmlNode | undefined => {\n  let dstNode: XmlNode | undefined;\n  const create: FnNodeToXml = (node: TextNode) => createMathMLNode(node, ctx);\n  const { color } = srcNode;\n  switch (srcNode.type) {\n    case \"atom\":\n      dstNode = mathItem(srcNode.atom.id, color);\n      break;\n    case \"charge\":\n      dstNode = mathText(\n        { ...ctx, textMode: \"charge\" },\n        srcNode.charge.text,\n        color\n      );\n      break;\n    case \"column\":\n      dstNode = mathColumn(splitColumn(srcNode.items ?? []), create);\n      break;\n    case \"comma\":\n      dstNode = { tag: \"mo\", content: \",\", color };\n      break;\n    case \"custom\":\n      dstNode = customNode(srcNode, ctx);\n      break;\n    case \"bond\":\n      {\n        const { tx } = srcNode.bond;\n        dstNode = {\n          tag: \"mo\",\n          content: tx === \"-\" ? \"–\" : tx,\n          color,\n          attrs: { lspace: \"0\", rspace: \"0\" },\n        };\n      }\n      break;\n    case \"bracket\":\n      dstNode = { tag: \"mo\", content: srcNode.text, color };\n      break;\n    case \"brackets\":\n      dstNode = mathScripted(srcNode.items ?? [], create);\n      break;\n    case \"item\":\n      dstNode = onNodeItem(srcNode, create);\n      break;\n    case \"k\":\n      dstNode = {\n        tag: srcNode.k.isNumber() ? \"mn\" : \"mi\",\n        content: srcNode.k.toString(),\n        color,\n      };\n      break;\n    case \"mul\":\n      // Google Chrome 132.0.6834.84 dont understand &sdot; and &#x22c5;\n      dstNode = { tag: \"mo\", content: \"\\u22c5\", color };\n      break;\n    case \"op\":\n      dstNode = {\n        tag: \"mo\",\n        content: stdOp(srcNode.op.srcText, srcNode.op.dstText),\n      };\n      break;\n    case \"radical\":\n      dstNode = mathItem(srcNode.radical.label, color);\n      break;\n    case \"richText\":\n      dstNode = mathRichText(srcNode, create);\n      break;\n    case \"space\":\n      dstNode =\n        srcNode.spaceType === \"agentOp\"\n          ? undefined\n          : { tag: \"mspace\", attrs: { width: \"0.5em\" } };\n      break;\n    case \"text\":\n      dstNode = mathText(ctx, textInsideTag(srcNode.text), color);\n      break;\n    default:\n      dstNode = mathOptRow(srcNode.items ?? [], create);\n      break;\n  }\n  return dstNode;\n};\n\nexport const stdOpsDict: Record<string, string> = {\n  \"-->\": \"\\u27F6\",\n  \"--|>\": \"→\",\n  \"->\": \"→\",\n  \"®\": \"→\",\n  \"<->\": \"↔\",\n  \"<-->\": \"↔\",\n  \"<=>\": \"⇌\",\n  \"<==>\": \"\\u21CC\",\n  \"!=\": \"≠\",\n  \"<-\": \"←\",\n  \"<--\": \"\\u2190\",\n  \"<|--\": \"←\",\n};\n\nexport const stdOp = (srcText: string, dstText: string): string =>\n  stdOpsDict[srcText] ?? dstText;\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { dictKeys } from \"../../buildTextNodes/dictKeys\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { mathOptRow } from \"./mathOptRow\";\nimport { ifDef } from \"../../../utils/ifDef\";\n\ntype ColDict = {\n  C?: TextNode[] | XmlNode;\n  B?: TextNode[];\n  T?: TextNode[];\n};\n\nexport const mathColumn = (\n  dict: ColDict,\n  create: FnNodeToXml\n): XmlNode | undefined => {\n  const keys = dictKeys(dict);\n  const { C = [], T, B } = dict;\n  const xC = \"tag\" in C ? C : mathOptRow(C, create);\n  if (keys === \"C\" || keys === \"\") {\n    return xC;\n  }\n  let tag = \"\";\n  const xB = ifDef(B, (it) => mathOptRow(it, create));\n  const xT = ifDef(T, (it) => mathOptRow(it, create));\n  let content: XmlNode[] = [];\n  if (xB && xT) {\n    tag = \"munderover\";\n    content = [xC, xB, xT];\n  } else if (xB) {\n    tag = \"munder\";\n    content = [xC, xB];\n  } else if (xT) {\n    tag = \"mover\";\n    content = [xC, xT];\n  }\n  if (!tag) return undefined;\n  return { tag, content };\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\n\nexport const mathItem = (text: string, color: string | undefined): XmlNode => {\n  const res: XmlNode = {\n    tag: \"mi\",\n    color,\n    content: text,\n  };\n  if (text.length === 1) res.attrs = { mathvariant: \"normal\" };\n  return res;\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\n\nexport const mathOptRow = (nodes: TextNode[], create: FnNodeToXml): XmlNode => {\n  // TODO: так как используется немного устаревшая версия TypeScript, то он не умеет правильно определять тип после filter\n  const content: XmlNode[] = nodes\n    .map(create)\n    .filter((it) => !!it) as XmlNode[];\n  if (content.length === 0) return { tag: \"mrow\" };\n  if (content.length === 1) return content[0]!;\n  return {\n    tag: \"mrow\",\n    content,\n  };\n};\n","import { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { mathScripted } from \"./mathScripted\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\n\nexport const mathRichText = (node: TextNode, create: FnNodeToXml) =>\n  mathScripted(node.items ?? [], create);\n","import { splitScripts } from \"../../buildTextNodes/splitScripts\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { dictKeys } from \"../../buildTextNodes/dictKeys\";\nimport { mathOptRow } from \"./mathOptRow\";\n\nexport const mathScripted = (\n  nodes: TextNode[],\n  create: FnNodeToXml,\n  createCenter?: FnNodeToXml\n): XmlNode => {\n  const dict = splitScripts(nodes);\n  const { C = [], RT, RB, LT, LB } = dict;\n  const key = dictKeys(dict);\n  if (key === \"C\") {\n    return mathOptRow(C, create);\n  }\n  let tag = \"\";\n  let groups: (TextNode[] | string | undefined)[] = [];\n  if (RB && key === \"C,RB\") {\n    tag = \"msub\";\n    groups = [C, RB];\n  } else if (RT && key === \"C,RT\") {\n    tag = \"msup\";\n    groups = [C, RT];\n  } else if (RB && RT && key === \"C,RB,RT\") {\n    tag = \"msubsup\";\n    groups = [C, RB, RT];\n  } else {\n    tag = \"mmultiscripts\";\n    groups = [C, RB, RT, \"mprescripts\", LB, LT];\n  }\n  const content: XmlNode[] = groups.map((it, i): XmlNode => {\n    if (!it) return { tag: \"mrow\" };\n    if (typeof it === \"string\") return { tag: it };\n    const fn = i ? create : createCenter ?? create;\n    return mathOptRow(it, fn) ?? { tag: \"mrow\" };\n  });\n  return { tag, content };\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { CtxCreateMathMLNode } from \"../CtxCreateMathMLNode\";\nimport { mathItem } from \"./mathItem\";\n\nexport const mathText = (\n  ctx: CtxCreateMathMLNode,\n  text: string,\n  color: string | undefined\n): XmlNode => {\n  if (/^\\d+$/.test(text))\n    return {\n      tag: \"mn\",\n      content: text,\n      color,\n    };\n  if (ctx.textMode === \"custom\") return mathItem(text, color);\n  return {\n    tag: \"mtext\",\n    content: text,\n    color,\n  };\n};\n","import { splitColumn } from \"../../buildTextNodes/splitColumn\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { mathColumn } from \"./mathColumn\";\nimport { mathScripted } from \"./mathScripted\";\n\nexport const onNodeItem = (\n  itemNode: TextNode,\n  create: FnNodeToXml\n): XmlNode | undefined => {\n  const { items } = itemNode;\n  if (!items) return undefined;\n  const colDict = splitColumn(items);\n  const { C, B, T } = colDict;\n  if (!C) return undefined;\n  const scripted = mathScripted(C, create);\n  return mathColumn({ C: scripted, B, T }, create);\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { parseColorCss } from \"../../utils/color/parseColorCss\";\nimport { getRgbSamples } from \"../../utils/color/getRgbSamples\";\nimport { CoeffType, TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { ScriptKey, splitScripts } from \"../buildTextNodes/splitScripts\";\nimport { findNearestColor, texColors } from \"./texColors\";\nimport { replaceSpecialTeXSymbols } from \"./replaceSpecialTeXSymbols\";\n\nexport type TeXOptions = {\n  scripts?: \"optimal\" | \"braces\";\n  colors?: \"original\" | \"predefined\" | \"dvips\";\n  noMhchem?: boolean; // dont use mhchem\n  comments?: \"CharChem\" | \"TeX\"; // TeX comments can only be used if all formulas are guaranteed to be output via TeX.\n};\n\ntype CtxTeX = TeXOptions & {\n  extOp: boolean;\n};\n\nexport const buildTeX = (srcNode: TextNode, options?: TeXOptions): string => {\n  const dstNode = cloneTextNode(srcNode);\n  optimizeColors(dstNode, ({ items }) => items);\n  const res = createTexFromNode(dstNode, { ...options, extOp: false });\n  // \\ce{} is mhchem extension\n  // https://mhchem.github.io/MathJax-mhchem/\n  return options?.noMhchem ? `\\\\mathrm{${res}}` : `\\\\ce{${res}}`;\n};\n\nexport const createTexFromNode = (node: TextNode, ctx: CtxTeX): string => {\n  switch (node.type) {\n    case \"atom\":\n      return texColor(node.atom.id, node.color, ctx);\n    case \"bond\":\n      return texColor(node.bond.tx, node.color, ctx);\n    case \"bracket\":\n      return texColor(node.text.replace(/([{}])/g, \"\\\\$1\"), node.color, ctx);\n    case \"brackets\":\n      return texColor(\n        onScripted(splitScripts(node.items ?? []), node.color, ctx),\n        node.color,\n        ctx\n      );\n    case \"charge\":\n      return texColor(node.charge.text, node.color, ctx);\n    case \"column\":\n      if (node.columnType === \"op\") return onComplexOp(node, ctx);\n      return onColumn(node, node.color, ctx);\n    case \"comma\":\n      return \",\";\n    case \"comment\":\n      return applyRichText(node, node.comment.text, ctx);\n    case \"custom\":\n      return applyRichText(node, node.custom.text, ctx);\n    case \"group\":\n      return onGroup(node.items, node.color, ctx);\n    case \"item\":\n      return onItem(node, ctx);\n    case \"k\":\n      return onCoeff(node.k.toString(), node.kType, node.color, ctx);\n    case \"mul\":\n      return ctx.noMhchem ? \" \\\\cdot \" : \"*\";\n    case \"op\":\n      return stdOp(node.op.srcText, node.op.srcText, ctx);\n    case \"radical\":\n      return texColor(escapeTex(node.radical.label), node.color, ctx);\n    case \"richText\":\n      return onRichText(node, ctx);\n    case \"space\":\n      return \" \";\n    case \"text\":\n      return texColor(\n        replaceSpecialTeXSymbols(escapeTex(node.text)),\n        node.color,\n        ctx\n      );\n    default:\n      break;\n  }\n  return \"\";\n};\n\nconst onCoeff = (\n  text: string,\n  type: CoeffType,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  let k = texColor(text, color, ctx);\n  if (ctx.noMhchem && type === \"agent\") {\n    k += \"\\\\,\";\n  }\n  return k;\n};\n\nexport const getTexColor = (color: string | undefined, ctx: CtxTeX): string => {\n  if (!color) return \"\";\n  let dstColor = color;\n  const inPredefined = ctx?.colors === \"predefined\";\n  if (ctx?.colors === \"dvips\" || inPredefined) {\n    const cc = parseColorCss(color);\n    if (cc) {\n      const s = getRgbSamples(cc);\n      if (s) {\n        const i = findNearestColor(s.r, s.g, s.b, inPredefined);\n        // eslint-disable-next-line prefer-destructuring\n        dstColor = texColors[i]![0];\n        if (inPredefined) dstColor = dstColor.toLowerCase();\n      }\n    }\n  }\n  return dstColor;\n};\n\nconst texColor = (text: string, color: string | undefined, ctx: CtxTeX) => {\n  const dstColor = getTexColor(color, ctx);\n  return dstColor ? `{\\\\color{${dstColor}}${text}}` : text;\n};\n\nconst onGroup = (\n  items: TextNode[] | undefined,\n  color: string | undefined,\n  ctx: CtxTeX\n): string =>\n  texColor(\n    items?.map((it) => createTexFromNode(it, ctx)).join(\"\") ?? \"\",\n    color,\n    ctx\n  );\n\ntype CmdCode = \"^\" | \"_\";\n\nconst optimizedCmd = (cmd: CmdCode, param: string, ctx: CtxTeX): string => {\n  if ((!ctx.scripts || ctx.scripts === \"optimal\") && param.length === 1) {\n    return `${cmd}${param}`;\n  }\n  return `${cmd}{${param}}`;\n};\n\nconst onScripted = (\n  s: ReturnType<typeof splitScripts>,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  let res = \"\";\n  const onCmd = (cmd: CmdCode, pos: ScriptKey) => {\n    if (s[pos]) {\n      res += optimizedCmd(cmd, onGroup(s[pos], color, ctx), ctx);\n    }\n  };\n  onCmd(\"^\", \"LT\");\n  onCmd(\"_\", \"LB\");\n  res += onGroup(s.C, color, ctx);\n  onCmd(\"^\", \"RT\");\n  onCmd(\"_\", \"RB\");\n  return res;\n};\n\nconst onColumnExt = (\n  center: TextNode[] | string | undefined,\n  top: TextNode[] | string | undefined,\n  bottom: TextNode[] | string | undefined,\n  color: string | undefined,\n  ctx: CtxTeX\n) => {\n  const cvtParam = (param: TextNode[] | string) =>\n    Array.isArray(param) ? onGroup(param, color, ctx) : param;\n  const op = (\n    cmd: \"overset\" | \"underset\",\n    secondary: TextNode[] | string,\n    primary: TextNode[] | string\n  ) => `\\\\${cmd}{${cvtParam(secondary)}}{${cvtParam(primary)}}`;\n\n  const c = center ?? \"\";\n  if (top && bottom) {\n    return op(\"overset\", top, op(\"underset\", bottom, c));\n  }\n  if (top) {\n    return op(\"overset\", top, c);\n  }\n  if (bottom) {\n    return op(\"underset\", bottom, c);\n  }\n  return cvtParam(c);\n};\n\nconst onColumn = (\n  node: TextNode,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  const col = splitColumn(node.items ?? []);\n  return onColumnExt(col.C, col.T, col.B, color, ctx);\n};\n\nconst onItem = (node: TextNode, ctx: CtxTeX): string => {\n  const col = splitColumn(node.items ?? []);\n  const center = onScripted(splitScripts(col.C ?? []), undefined, ctx);\n  return texColor(\n    onColumnExt(center, col.T, col.B, undefined, ctx),\n    node.color,\n    ctx\n  );\n};\n\nconst onComplexOp = (node: TextNode, ctx0: CtxTeX): string => {\n  const ctx: CtxTeX = { ...ctx0 };\n  const d = splitColumn(node.items ?? []);\n  const complex = isComplexOp(d.C);\n  const mhchem = !ctx0.noMhchem;\n  if (complex && !mhchem) ctx.extOp = true;\n  let above: string | undefined;\n  let below: string | undefined;\n  const opNode = node.items?.find(({ type }) => type === \"op\");\n  if (opNode?.type === \"op\" && ctx0.comments === \"TeX\") {\n    const { op } = opNode;\n    above = op.commentPre?.text;\n    below = op.commentPost?.text;\n  } else {\n    above = onGroup(d.T, node.color, ctx);\n    below = onGroup(d.B, node.color, ctx);\n  }\n  let res = onGroup(d.C, node.color, ctx);\n  if (mhchem) {\n    if (above || below) res += `[${above || \"\"}]`;\n    if (below) res += `[${below}]`;\n  } else if (complex) {\n    // example: \\xrightarrow[under]{over}\n    if (below) res += `[${below}]`;\n    res += `{${above || \"\"}}`;\n  }\n  return res;\n};\n\nconst applyRichText = (node: TextNode, text: string, ctx: CtxTeX): string => {\n  if (ctx.comments === \"TeX\") return replaceSpecialTeXSymbols(text);\n  return onGroup(node.items, node.color, ctx);\n};\n\nconst onRichText = (node: TextNode, ctx: CtxTeX) => {\n  const scripted = splitScripts(node.items ?? []);\n  return onScripted(scripted, node.color, ctx);\n};\n\nconst escapeTex = (text: string): string =>\n  text.replace(/\\\\/g, \"\\\\backslash \").replace(/([{}\\[\\]])/g, \"\\\\$1\");\n\nexport const mhchemOpsDict: Record<string, string> = {\n  \"-->\": \"->\",\n  \"--|>\": \"->\",\n  \"->\": \"->\",\n  \"®\": \"→\",\n  \"<->\": \"<->\",\n  \"<-->\": \"<->\",\n  \"<=>\": \"⇌\",\n  \"<==>\": \"<-->\",\n  \"!=\": \"\\\\ne\",\n  \"<-\": \"<-\",\n  \"<--\": \"<-\",\n  \"<|--\": \"<-\",\n};\n\nexport const stdOp = (\n  srcText: string,\n  dstText: string,\n  ctx: CtxTeX\n): string => {\n  if (!ctx.noMhchem) {\n    return mhchemOpsDict[srcText] ?? dstText;\n  }\n  if (ctx.extOp) {\n    const op = texComplexOps[srcText];\n    if (op) return `\\\\${op}`;\n  }\n  return ifDef(texSimpleOps[srcText], (op) => `\\\\${op}`) ?? dstText;\n};\n\nconst texSimpleOps: Record<string, string> = {\n  \"->\": \"rightarrow\",\n  \"-->\": \"longrightarrow\",\n  \"--|>\": \"longrightarrow\",\n  \"®\": \"rightarrow\",\n  \"<->\": \"leftrightarrow\",\n  \"<-->\": \"longleftrightarrow\",\n  \"<=>\": \"rightleftarrows\",\n  \"<==>\": \"rightleftarrows\",\n  \"!=\": \"ne\",\n  \"<-\": \"leftarrow\",\n  \"<--\": \"longleftarrow\",\n  \"<|--\": \"longleftarrow\",\n};\n\nconst texComplexOps: Record<string, string> = {\n  \"->\": \"xrightarrow\",\n  \"®\": \"xrightarrow\",\n  \"-->\": \"xrightarrow\",\n  \"--|>\": \"xrightarrow\",\n  \"<->\": \"xleftrightarrow\",\n  \"<-->\": \"xleftrightarrow\",\n  \"<=>\": \"xrightleftharpoons\",\n  \"<==>\": \"xrightleftharpoons\", // not supported by MathJax\n  \"<-\": \"xleftarrow\",\n  \"<--\": \"xleftarrow\",\n  \"<|--\": \"xleftarrow\",\n};\n\nconst isComplexOp = (nodes: TextNode[] | undefined): boolean => {\n  if (nodes?.length !== 1 || !nodes[0]) return false;\n  const [node] = nodes;\n  return node.type === \"op\" && !!texComplexOps[node.op.srcText];\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { specCharsB } from \"../../compiler/parse/comment\";\n\n/**\n * Replace unicode-symbols to TeX-commands.\n * Опытным путём выявлено, что так TeX-процессоры лучше обрабатывают код.\n * Вызывать после escapeTex, т.к. после замены появятся TeX-команды.\n * @param src\n * @returns\n */\nexport const replaceSpecialTeXSymbols = (src: string): string => {\n  const { regEx, dict } = getData();\n  return src.replace(regEx, (m) => ifDef(dict[m], (c) => `\\\\${c} `) ?? m);\n};\n\nlet cacheDict: Record<string, string> | undefined;\nlet cacheRegEx = /([↑])/g;\n\nconst getData = (): {\n  dict: Record<string, string>;\n  regEx: RegExp;\n} => {\n  if (!cacheDict) {\n    const d: Record<string, string> = {\n      \"↑\": \"uparrow\",\n      \"↓\": \"downarrow\",\n      // \"°\": \"degree\", - not supported by MathJax\n    };\n    Object.entries(specCharsB).forEach(([cmd, uChar]) => {\n      d[uChar] = cmd;\n    });\n    cacheDict = d;\n    const codes = Object.keys(d).join(\"\");\n    cacheRegEx = new RegExp(`([${codes}])`, \"g\");\n  }\n  return {\n    dict: cacheDict,\n    regEx: cacheRegEx,\n  };\n};\n","// Source: https://en.wikibooks.org/wiki/LaTeX/Colors\n\n// name, red, green, blue, is predefined\ntype TexColorDef = [string, number, number, number, boolean?];\n\nexport const texColors: TexColorDef[] = [\n  [\"Apricot\", 0xfb, 0xb9, 0x82],\n  [\"Aquamarine\", 0, 0xb5, 0xbe],\n  [\"Bittersweet\", 0xc0, 0x4f, 0x17],\n  [\"Black\", 0x22, 0x1e, 0x1f, true],\n  [\"Blue\", 0x2d, 0x2f, 0x92, true],\n  [\"BlueGreen\", 0x00, 0xb3, 0xb8],\n  [\"BlueViolet\", 0x47, 0x39, 0x92],\n  [\"BrickRed\", 0xb6, 0x32, 0x1c],\n  [\"Brown\", 0x79, 0x25, 0x00, true],\n  [\"BurntOrange\", 0xf7, 0x92, 0x1d],\n  [\"CadetBlue\", 0x74, 0x72, 0x9a],\n  [\"CarnationPink\", 0xf2, 0x82, 0xb4],\n  [\"Cerulean\", 0x00, 0xa2, 0xe3],\n  [\"CornflowerBlue\", 0x41, 0xb0, 0xe4],\n  [\"Cyan\", 0x00, 0xae, 0xef, true],\n  [\"Dandelion\", 0xfd, 0xbc, 0x42],\n  [\"DarkOrchid\", 0xa4, 0x53, 0x8a],\n  [\"Emerald\", 0x00, 0xa9, 0x9d],\n  [\"ForestGreen\", 0x00, 0x9b, 0x55],\n  [\"Fuchsia\", 0x8c, 0x36, 0x8c],\n  [\"Goldenrod\", 0xff, 0xdf, 0x42],\n  [\"Gray\", 0x94, 0x96, 0x98, true],\n  [\"Green\", 0x00, 0xa6, 0x4f, true],\n  [\"GreenYellow\", 0xdf, 0xe6, 0x74],\n  [\"JungleGreen\", 0x00, 0xa9, 0x9a],\n  [\"Lavender\", 0xf4, 0x9e, 0xc4],\n  [\"LimeGreen\", 0x8d, 0xc7, 0x3e],\n  [\"Magenta\", 0xec, 0x00, 0x8c, true],\n  [\"Mahogany\", 0xa9, 0x34, 0x1f],\n  [\"Maroon\", 0xaf, 0x32, 0x35],\n  [\"Melon\", 0xf8, 0x9e, 0x7b],\n  [\"MidnightBlue\", 0x00, 0x67, 0x95],\n  [\"Mulberry\", 0xa9, 0x3c, 0x93],\n  [\"NavyBlue\", 0x00, 0x6e, 0xb8],\n  [\"OliveGreen\", 0x3c, 0x80, 0x31],\n  [\"Orange\", 0xf5, 0x81, 0x37, true],\n  [\"OrangeRed\", 0xed, 0x13, 0x5a],\n  [\"Orchid\", 0xaf, 0x72, 0xb0],\n  [\"Peach\", 0xf7, 0x96, 0x5a],\n  [\"Periwinkle\", 0x79, 0x77, 0xb8],\n  [\"PineGreen\", 0x00, 0x8b, 0x72],\n  [\"Plum\", 0x92, 0x26, 0x8f],\n  [\"ProcessBlue\", 0x00, 0xb0, 0xf0],\n  [\"Purple\", 0x99, 0x47, 0x9b, true],\n  [\"RawSienna\", 0x97, 0x40, 0x06],\n  [\"Red\", 0xed, 0x1b, 0x23, true],\n  [\"RedOrange\", 0xf2, 0x60, 0x35],\n  [\"RedViolet\", 0xa1, 0x24, 0x6b],\n  [\"Rhodamine\", 0xef, 0x55, 0x9f],\n  [\"RoyalBlue\", 0x00, 0x71, 0xbc],\n  [\"RoyalPurple\", 0x61, 0x3f, 0x99],\n  [\"RubineRed\", 0xed, 0x01, 0x7d],\n  [\"Salmon\", 0xf6, 0x92, 0x89],\n  [\"SeaGreen\", 0x3f, 0xbc, 0x9d],\n  [\"Sepia\", 0x67, 0x18, 0x00],\n  [\"SkyBlue\", 0x46, 0xc5, 0xdd],\n  [\"SpringGreen\", 0xc6, 0xdc, 0x67],\n  [\"Tan\", 0xda, 0x9d, 0x76],\n  [\"TealBlue\", 0x00, 0xae, 0xb3],\n  [\"Thistle\", 0xd8, 0x83, 0xb7],\n  [\"Turquoise\", 0x00, 0xb4, 0xce],\n  [\"Violet\", 0x58, 0x42, 0x9b, true],\n  [\"VioletRed\", 0xef, 0x58, 0xa0],\n  [\"White\", 0xff, 0xff, 0xff, true],\n  [\"WildStrawberry\", 0xee, 0x29, 0x67],\n  [\"Yellow\", 0xff, 0xf2, 0x00, true],\n  [\"YellowGreen\", 0x98, 0xcc, 0x70],\n  [\"YellowOrange\", 0xfa, 0xa2, 0x1a],\n];\n\n// TODO: здесь не все predefined colors\n\nexport const findNearestColor = (\n  red: number,\n  green: number,\n  blue: number,\n  inPredefined: boolean\n): number => {\n  let minDist = Number.MAX_SAFE_INTEGER;\n  let pos = 0;\n  for (let i = 0; i < texColors.length; i++) {\n    const [, r, g, b, predefined] = texColors[i]!;\n    if (inPredefined && !predefined) continue;\n    const dr = red - r;\n    const dg = green - g;\n    const db = blue - b;\n    const dist = dr * dr + dg * dg + db * db;\n    if (dist < minDist) {\n      pos = i;\n      minDist = dist;\n    }\n  }\n  return pos;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\r\nimport { compile } from \"../compiler/compile\";\r\nimport { ChemObj } from \"../core/ChemObj\";\r\nimport { OptionsHtmlRich } from \"./htmlRich/OptionsHtmlRich\";\r\nimport { buildTextNodes } from \"./buildTextNodes\";\r\nimport { buildHtmlRich } from \"./htmlRich/buildHtmlRich\";\r\nimport { buildTextFormat, OptionsTextFormat } from \"./text/buildTextFormat\";\r\nimport { buildTeX, TeXOptions } from \"./tex/buildTeX\";\r\nimport { MathMLOptions } from \"./mathml/MathMLOptions\";\r\nimport { buildMathML } from \"./mathml/buildMathML\";\r\nimport { renderXmlNode, renderXmlNodes } from \"./xmlNode/renderXmlNode\";\r\nimport { OptionsHtmlPoor } from \"./htmlPoor/OptionsHtmlPoor\";\r\nimport { htmlPoor } from \"./htmlPoor\";\r\nimport { buildCharChemText } from \"./charChem/buildCharChemText\";\r\n\r\ntype OptionsXmlRender = {\r\n  indent?: string;\r\n};\r\n\r\ntype FmtHtmlRich = {\r\n  type: \"html\";\r\n  options?: OptionsHtmlRich & OptionsXmlRender;\r\n};\r\ntype FmtHtmlPoor = {\r\n  type: \"htmlPoor\";\r\n  options?: OptionsHtmlPoor;\r\n};\r\ntype FmtText = {\r\n  type: \"text\";\r\n  options?: OptionsTextFormat;\r\n};\r\ntype FmtTeX = {\r\n  type: \"TeX\";\r\n  options?: TeXOptions;\r\n};\r\ntype FmtMathML = {\r\n  type: \"MathML\";\r\n  options?: MathMLOptions & OptionsXmlRender;\r\n};\r\ntype FmtCharChem = {\r\n  type: \"CharChem\";\r\n};\r\n\r\nexport type FmtDef =\r\n  | FmtHtmlRich\r\n  | FmtHtmlPoor\r\n  | FmtText\r\n  | FmtTeX\r\n  | FmtMathML\r\n  | FmtCharChem;\r\nexport type FmtType = FmtDef[\"type\"];\r\n\r\nexport const textTypes: readonly FmtType[] = [\r\n  \"text\",\r\n  \"htmlPoor\",\r\n  \"TeX\",\r\n  \"CharChem\",\r\n  \"html\",\r\n  \"MathML\",\r\n];\r\n\r\nexport const textFormula = (\r\n  objOrCode: ChemObj | string,\r\n  fmtOrType: FmtDef | FmtType\r\n): string => {\r\n  const chemObj =\r\n    typeof objOrCode === \"string\" ? compile(objOrCode) : objOrCode;\r\n  if (chemObj instanceof ChemExpr && !chemObj.isOk()) {\r\n    return chemObj.getMessage();\r\n  }\r\n  const fmt: FmtDef =\r\n    typeof fmtOrType === \"string\" ? { type: fmtOrType } : fmtOrType;\r\n  const textNode = buildTextNodes(chemObj);\r\n  switch (fmt.type) {\r\n    case \"html\": {\r\n      const { indent, ...htmlOptions } = fmt.options ?? {};\r\n      return renderXmlNodes(buildHtmlRich(textNode, htmlOptions).nodes, {\r\n        indent,\r\n        noSelfClosed: true,\r\n      });\r\n    }\r\n    case \"htmlPoor\":\r\n      return htmlPoor(textNode, fmt.options);\r\n    case \"text\":\r\n      return buildTextFormat(textNode, fmt.options);\r\n    case \"TeX\":\r\n      return buildTeX(textNode, fmt.options);\r\n    case \"CharChem\":\r\n      return buildCharChemText(textNode);\r\n    case \"MathML\": {\r\n      const { indent, ...mmlOptions } = fmt.options ?? {};\r\n      return renderXmlNode(buildMathML(textNode, mmlOptions), { indent });\r\n    }\r\n    default:\r\n      break;\r\n  }\r\n  return \"\";\r\n};\r\n","/**\n * ASCII is used predominantly.\n * But the result is still in UNICODE.\n * Because comments and abstract elements can contain an extended set of characters.\n */\n\nimport { TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { ScriptKey, splitScripts } from \"../buildTextNodes/splitScripts\";\n\ntype OxidationPos =\n  | \"*RT\"\n  | \"RT*\"\n  | \"*RB\"\n  | \"RB*\"\n  | \"*LB\"\n  | \"LB*\"\n  | \"*LT\"\n  | \"LT*\";\ntype FnOxidation = (center: string, oxst: string) => string;\ntype FnScript = (text: string, left?: boolean) => string;\ntype FnOpComment = (text: string, where: \"above\" | \"below\") => string;\n\nexport type OptionsTextFormat = {\n  // default values are first\n  operations?: \"ascii\" | \"dstText\";\n  opComments?: \"text\" | \"ignore\" | \"quoted\" | FnOpComment;\n  sup?: \"withHat\" | \"text\" | FnScript;\n  sub?: \"text\" | \"withUnderscore\" | FnScript;\n  oxidationState?: \"ignore\" | \"sup\" | OxidationPos | FnOxidation;\n  mul?: string; // *\n  scriptDivider?: string; // \"\"\n};\n\nexport const buildTextFormat = (\n  srcNode: TextNode,\n  options?: OptionsTextFormat\n): string => {\n  const dstNode = cloneTextNode(srcNode);\n  optimizeColors(dstNode, ({ items }) => items);\n  return strNode(dstNode, options);\n};\n\nconst strNode = (srcNode: TextNode, options?: OptionsTextFormat): string => {\n  switch (srcNode.type) {\n    case \"atom\":\n      return srcNode.atom.id;\n    case \"bond\":\n      return srcNode.bond.tx;\n    case \"bracket\":\n      return srcNode.text;\n    case \"brackets\":\n      return strScripted(splitScripts(srcNode.items), undefined, options);\n    case \"charge\":\n      return srcNode.charge.text;\n    case \"column\":\n      return strExtOp(srcNode, options);\n    case \"comma\":\n      return \",\";\n    case \"comment\":\n    case \"custom\":\n    case \"group\":\n      return strItems(srcNode.items, options);\n    case \"item\":\n      return strNodeItem(srcNode, options);\n    case \"k\":\n      return srcNode.k.toString();\n    case \"mul\":\n      return options?.mul ?? \"*\";\n    case \"op\":\n      return strOp(srcNode.op.dstText, options);\n    case \"radical\":\n      return srcNode.radical.label;\n    case \"richText\":\n      return strRichText(srcNode.items, options);\n    case \"space\":\n      return \" \";\n    case \"text\":\n      return srcNode.text;\n    default:\n      break;\n  }\n  return \"\";\n};\n\nconst strItems = (\n  items: (TextNode | string)[] | undefined,\n  options?: OptionsTextFormat,\n  divider = \"\"\n): string =>\n  (items ?? [])\n    .map((node) => (typeof node === \"string\" ? node : strNode(node, options)))\n    .join(divider);\n\nconst strOp = (dstText: string, options?: OptionsTextFormat): string => {\n  const mode = options?.operations ?? \"ascii\";\n  let result: string | undefined;\n  if (mode === \"ascii\") {\n    result = opDictAscii[dstText];\n  }\n  return result ?? dstText;\n};\n\nconst opDictAscii: Record<string, string> = {\n  \"→\": \"->\",\n  \"—→\": \"->\",\n  \"↔\": \"<->\",\n  \"←→\": \"<->\",\n  \"\\u21CC\": \"<=>\",\n  \"∙\": \"*\",\n  \"≠\": \"=/=\",\n  \"←—\": \"<-\",\n  \"←\": \"<-\",\n};\n\nconst strExtOp = (\n  node: TextNode,\n  options: OptionsTextFormat | undefined\n): string => {\n  const col = splitColumn(node.items);\n  let items: (TextNode | string)[] = col.C ?? [];\n  const commMode = options?.opComments ?? \"text\";\n  const commCvt = (text: string, where: \"above\" | \"below\") => {\n    if (commMode === \"quoted\") return `\"${text}\"`;\n    if (typeof commMode === \"function\") return commMode(text, where);\n    return text;\n  };\n  if (commMode !== \"ignore\") {\n    if (col.B) {\n      const bottom = strItems(col.B, options);\n      items = [...items, commCvt(bottom, \"below\")];\n    }\n    if (col.T) {\n      const top = strItems(col.T, options);\n      items = [commCvt(top, \"above\"), ...items];\n    }\n  }\n  return strItems(items, options);\n};\n\nconst strRichText = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined\n): string => {\n  const s = splitScripts(items);\n  const c = strItems(s.C, options);\n  return strScripted(s, c, options);\n};\n\nconst strNodeItem = (\n  srcNode: TextNode,\n  options: OptionsTextFormat | undefined\n): string => {\n  const col = splitColumn(srcNode.items ?? []);\n  const scripted = splitScripts(col.C ?? []);\n  const centerItems: (TextNode | string)[] = scripted.C ?? [];\n  const oxMode = options?.oxidationState;\n  let center: string | undefined;\n  if (col.T && oxMode) {\n    if (typeof oxMode === \"function\") {\n      const c = strItems(centerItems, options);\n      const oxst = strItems(col.T, options, options?.scriptDivider);\n      center = oxMode(c, oxst);\n    } else {\n      const oxPos = oxMode === \"sup\" ? \"*RT\" : oxMode;\n      const sPos = oxPosToScript[oxPos as OxidationPos];\n      if (sPos) {\n        const oldScr = scripted[sPos] ?? [];\n        const newScr =\n          oxPos[0] === \"*\" ? [...col.T, ...oldScr] : [...oldScr, ...col.T];\n        scripted[sPos] = newScr;\n      }\n    }\n  }\n  center = center ?? strItems(centerItems, options);\n  return strScripted(scripted, center, options);\n};\nconst oxPosToScript: Record<OxidationPos, ScriptKey> = {\n  \"*RT\": \"RT\",\n  \"RT*\": \"RT\",\n  \"*RB\": \"RB\",\n  \"RB*\": \"RB\",\n  \"*LT\": \"LT\",\n  \"LT*\": \"LT\",\n  \"*LB\": \"LB\",\n  \"LB*\": \"LB\",\n};\n\nconst strScripted = (\n  dict: ReturnType<typeof splitScripts>,\n  center: string | undefined,\n  options: OptionsTextFormat | undefined\n): string =>\n  [\n    strSup(dict.LT, options, true),\n    strSub(dict.LB, options, true),\n    center ?? strItems(dict.C, options),\n    strSub(dict.RB, options),\n    strSup(dict.RT, options),\n  ].join(\"\");\n\nconst strSup = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined,\n  left?: boolean\n): string => {\n  let res = strItems(items, options, options?.scriptDivider);\n  if (res) {\n    const sup = options?.sup ?? \"withHat\";\n    if (sup === \"withHat\") {\n      res = `^${res}`;\n    } else if (typeof sup === \"function\") {\n      res = sup(res, left);\n    }\n  }\n  return res;\n};\n\nconst strSub = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined,\n  left?: boolean\n): string => {\n  let res = strItems(items, options, options?.scriptDivider);\n  if (res) {\n    const sub = options?.sub;\n    if (sub === \"withUnderscore\") {\n      res = `_${res}`;\n    } else if (typeof sub === \"function\") {\n      res = sub(res, left);\n    }\n  }\n  return res;\n};\n","import { XmlNode } from \"./XmlNode\";\n\n/* eslint no-param-reassign: \"off\" */\n\nexport const addClassToXmlNode = (\n  node: XmlNode,\n  className: string | string[]\n) => {\n  const newList = (\n    typeof className === \"string\" ? className : className.join(\" \")\n  )\n    .split(\" \")\n    .filter((s) => s);\n  const oldList = new Set<string>(node.attrs?.class?.split(\" \") ?? []);\n  newList.forEach((name) => oldList.add(name));\n  node.attrs = node.attrs || {};\n  node.attrs!.class = Array.from(oldList).join(\" \");\n};\n","import { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { XmlNode } from \"./XmlNode\";\n\nexport const optimizeXmlColors = (node: XmlNode) =>\n  optimizeColors(node, ({ content }) =>\n    Array.isArray(content) ? content : undefined\n  );\n","import { drawTag } from \"../../utils/xml/drawTag\";\r\nimport { escapeXml } from \"../../utils/xml/escapeXml\";\r\nimport { XmlNode } from \"./XmlNode\";\r\n\r\nexport type OptionsRenderXmlNode = {\r\n  indent?: string;\r\n  noSelfClosed?: boolean;\r\n};\r\n\r\nexport const renderXmlNode = (\r\n  { tag, attrs, color, content }: XmlNode,\r\n  options?: OptionsRenderXmlNode,\r\n  level: number = 0\r\n): string => {\r\n  if (!tag) {\r\n    if (typeof content === \"string\") {\r\n      return escapeXml(content);\r\n    }\r\n    if (Array.isArray(content)) {\r\n      return renderXmlNodes(content, options, level);\r\n    }\r\n  }\r\n\r\n  const indent = options?.indent ?? \"\";\r\n  const canSelfClosed = !options?.noSelfClosed;\r\n  const attrsExt = color\r\n    ? {\r\n        ...attrs,\r\n        style: `color: ${color}`, // Предполагается, что такого атрибута нет в attrs\r\n      }\r\n    : attrs;\r\n  let res = \"\";\r\n  const addStr = (str: string, strLevel: number) => {\r\n    if (indent) res += indent.repeat(strLevel);\r\n    res += str;\r\n    if (indent) res += \"\\n\";\r\n  };\r\n\r\n  if (!content || (Array.isArray(content) && content.length === 0)) {\r\n    if (canSelfClosed) {\r\n      addStr(drawTag(tag, attrsExt, true), level);\r\n    } else {\r\n      addStr(`${drawTag(tag, attrsExt)}</${tag}>`, level);\r\n    }\r\n  } else {\r\n    addStr(drawTag(tag, attrsExt, !content), level);\r\n    if (typeof content === \"string\" && content.trim()) {\r\n      const xc = escapeXml(content);\r\n      if (xc.length > 40) {\r\n        addStr(xc, level + 1);\r\n      } else {\r\n        if (indent) res = res.slice(0, -1);\r\n        res += xc;\r\n        addStr(`</${tag}>`, 0);\r\n        return res;\r\n      }\r\n    } else if (Array.isArray(content)) {\r\n      content.forEach((subNode) => {\r\n        res += renderXmlNode(subNode, options, level + 1);\r\n      });\r\n    }\r\n    if (content) {\r\n      addStr(`</${tag}>`, level);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\nexport const renderXmlNodes = (\r\n  nodes: XmlNode[] | undefined,\r\n  options?: OptionsRenderXmlNode,\r\n  level: number = 0\r\n): string =>\r\n  (nodes ?? []).map((node) => renderXmlNode(node, options, level)).join(\"\");\r\n","/* eslint-disable class-methods-use-this */\nimport { ChemK } from \"../core/ChemK\";\nimport { Double, Int } from \"../types\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { MarkupChunkType, markupFlat, parseMarkup } from \"../utils/markup\";\n\nexport class RulesBase {\n  agentK(k: ChemK): string {\n    return k.toString();\n  }\n\n  atom(id: string): string {\n    return id;\n  }\n\n  comma(): string {\n    return \",\";\n  }\n\n  comment(text: string): string {\n    return this.useMarkup(text);\n  }\n\n  custom(text: string): string {\n    return this.useMarkup(text);\n  }\n\n  itemCount(k: ChemK): string {\n    return k.toString();\n  }\n\n  bracketCount(k: ChemK): string {\n    return this.itemCount(k);\n  }\n\n  itemMass(mass: Double): string {\n    return strMass(mass);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  itemMassAndNum(mass: Double, number: Int | undefined): string {\n    return \"\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  itemCharge(charge: ChemCharge): string {\n    return \"\";\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return charge.text;\n  }\n\n  bracketCharge(charge: ChemCharge): string {\n    return this.nodeCharge(charge);\n  }\n\n  operation(op: ChemOp): string {\n    return `${this.opComment(op.commentPre)}${op.dstText}${this.opComment(\n      op.commentPost\n    )}`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm ? this.useMarkup(comm.text) : \"\";\n  }\n\n  postProcess(text: string): string {\n    return text;\n  }\n\n  radical(label: string): string {\n    return label;\n  }\n\n  mul(): string {\n    return \"∙\";\n  }\n\n  mulK(k: ChemK): string {\n    return String(k);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  colorBegin(color: string): string {\n    return \"\";\n  }\n\n  colorEnd(): string {\n    return \"\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    return \"\";\n  }\n\n  useMarkup(text: string): string {\n    const topChunk = parseMarkup(text);\n    let result = \"\";\n    markupFlat(topChunk, ({ phase, chunk }) => {\n      if (typeof chunk === \"string\") {\n        result += chunk;\n      } else if (phase === \"open\" || phase === \"close\") {\n        const isOpen = phase === \"open\";\n        if (!chunk.type && chunk.color) {\n          result += isOpen ? this.colorBegin(chunk.color) : this.colorEnd();\n        } else {\n          result += this.markupSection(chunk.type, isOpen);\n        }\n      }\n    });\n    return result;\n  }\n}\n","import { RulesBase } from \"./RulesBase\";\nimport { rulesBB } from \"./rulesBB\";\nimport { rulesCharChem } from \"./rulesCharChem\";\nimport { rulesHtml } from \"./rulesHtml\";\nimport { rulesMhchem } from \"./rulesMhchem\";\nimport { rulesRTF } from \"./rulesRTF\";\nimport { rulesText } from \"./rulesText\";\n\nexport const dictTextRules: Record<string, RulesBase> = {\n  bb: rulesBB,\n  charChem: rulesCharChem,\n  html: rulesHtml,\n  mhchem: rulesMhchem,\n  rtf: rulesRTF,\n  text: rulesText,\n};\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { RulesBase } from \"./RulesBase\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\n\n/**\n * Правила для формирования BB-кода представления формулы (для вставки в форумы)\n */\nclass RulesBB extends RulesBase {\n  agentK(k: ChemK): string {\n    return `[b]${k}[/b]`;\n  }\n\n  comment(text: string): string {\n    return `[i]${text}[/i]`;\n  }\n\n  custom(text: string): string {\n    return `[i]${text}[/i]`;\n  }\n\n  itemCount(k: ChemK): string {\n    return `[sub]${k}[/sub]`;\n  }\n\n  itemMass(mass: Double): string {\n    return `[sup]${strMass(mass)}[/sup]`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `[sup]${strMass(mass)}[/sup][sub]${num}[/sub]`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `[sup]${charge.text}[/sup]`;\n  }\n\n  colorBegin(color: string): string {\n    return `[color=${color}]`;\n  }\n\n  colorEnd(): string {\n    return \"[/color]\";\n  }\n}\n\nexport const rulesBB = Object.freeze(new RulesBB());\n","/* eslint-disable class-methods-use-this */\nimport { RulesBase } from \"./RulesBase\";\nimport { Int, Double } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\n\n/*\nСледует учесть, что это не полноценная система обратного преобразования выражения в текст формулы.\nЗдесь действуют те же ограничения, что и для остальных правил: формула должна быть текстовой(линейной)\n */\n\nconst exportCoeff = (k: ChemK) => (k.isNumber() ? String(k) : `'${k}'`);\n\nclass RulesCharChem extends RulesBase {\n  agentK(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  comment(text: string): string {\n    return `\"${text}\"`;\n  }\n\n  custom(text: string): string {\n    return `{${text}}`;\n  }\n\n  itemCount(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  itemMass(mass: Double): string {\n    return `$M(${strMass(mass)})`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `$nM(${strMass(mass)},${num})`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `^${charge.text}`;\n  }\n\n  operation(op: ChemOp): string {\n    return `${this.opComment(op.commentPre)}${op.srcText}${this.opComment(\n      op.commentPost\n    )}`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm ? this.comment(comm.text) : \"\";\n  }\n\n  postProcess(text: string): string {\n    return text.replace(/\\$color\\(\\)\\$color/g, \"$color\");\n  }\n\n  radical(label: string): string {\n    return this.custom(label);\n  }\n\n  mul(): string {\n    return \"*\";\n  }\n\n  mulK(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  colorBegin(color: string): string {\n    return `$color(${color})`;\n  }\n\n  colorEnd(): string {\n    return \"$color()\";\n  }\n}\n\nexport const rulesCharChem = Object.freeze(new RulesCharChem());\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { RulesBase } from \"./RulesBase\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { drawTag } from \"../utils/xml/drawTag\";\nimport { escapeXml } from \"../utils/xml/escapeXml\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { MarkupChunkType } from \"../utils/markup\";\n\n/**\n * Правила для формирования HTML-представления формулы\n * Важно учесть, что полученная разметка предполагает использование определенных правил CSS\n * Их можно скачать тут\n *   http://charchem.org/download/charchem.css\n *\n * Различные части формулы оборачиваются специальными тегами, чтобы их было проще кастомизировать.\n * <b/> - Коэффициент агента\n * <em/> - Текстовый комментарий\n * <i/> - Абстрактные функциональные группы, н.р. {R}OH\n * <sub/> - Подстрочные коэффициенты\n * <span class=\"echem-op\"/> - Операции в химических выражениях\n */\nexport class RulesHtml extends RulesBase {\n  agentK(k: ChemK): string {\n    const attr: string = k.color ? ` style=\"color:${escapeXml(k.color)}\"` : \"\";\n    return `<b${attr}>${k}</b>`;\n  }\n\n  comment(text: string): string {\n    return `<em>${super.comment(text)}</em>`;\n  }\n\n  custom(text: string): string {\n    return `<i>${super.custom(text)}</i>`;\n  }\n\n  itemCount(k: ChemK): string {\n    return `<sub>${k}</sub>`;\n  }\n\n  itemMass(mass: Double): string {\n    return `<sup>${strMass(mass)}</sup>`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `${drawTag(\"span\", { class: \"echem-mass-and-num\" })}${strMass(\n      mass\n    )}<br/>${num}</span>`;\n  }\n\n  itemCharge(charge: ChemCharge): string {\n    return `<sup class=\"echem-item-charge\">${charge.text}</sup>`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `<sup>${charge.text}</sup>`;\n  }\n\n  operation(op: ChemOp): string {\n    let result = drawTag(\"span\", { class: \"echem-op\" });\n    result += this.opComment(op.commentPre);\n    switch (op.srcText) {\n      case \"-->\":\n        result += `<span class=\"chem-long-arrow\">→</span>`;\n        break;\n      case \"<==>\":\n        result += `<span class=\"chem-long-arrow\">\\u21CC</span>`;\n        break;\n      default:\n        result += op.dstText;\n        break;\n    }\n    result += this.opComment(op.commentPost);\n    return `${result}</span>`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm\n      ? `<span class=\"echem-opcomment\">${this.useMarkup(comm.text)}</span>`\n      : \"\";\n  }\n\n  colorBegin(color: string): string {\n    return `<span style=\"color:${escapeXml(color)}\">`;\n  }\n\n  colorEnd(): string {\n    return \"</span>\";\n  }\n\n  override markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    const tag = markupTagDict[type] ?? \"span\";\n    return isOpen ? `<${tag}>` : `</${tag}>`;\n  }\n}\n\nconst markupTagDict: Record<string, string> = {\n  sup: \"sup\",\n  sub: \"sub\",\n};\n\nexport const rulesHtml = Object.freeze(new RulesHtml());\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { RulesBase } from \"./RulesBase\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { MarkupChunkType } from \"../utils/markup\";\n\nconst opDict: Record<string, string> = {\n  \"-->\": \"->\",\n  \"<=>\": \"<-->\",\n  \"<==>\": \"<-->\",\n};\n\n// MathJax/mhchem\n// https://mhchem.github.io/MathJax-mhchem/\n\nclass RulesMhchem extends RulesBase {\n  // Возможно, нужны разные правила для чисел, дробных чисел и абстрактных значений\n  agentK(k: ChemK) {\n    return String(k);\n  }\n\n  itemCount(k: ChemK): string {\n    return `_{${k}}`;\n  }\n\n  itemMass(mass: Double): string {\n    return `^{${strMass(mass)}}`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `^{${strMass(mass)}}_{${num}}`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `^{${charge.text}}`;\n  }\n\n  operation(op: ChemOp): string {\n    let result: string = opDict[op.srcText] ?? op.srcText;\n    const t1 = op.commentPre;\n    const t2 = op.commentPost;\n    if (t1 || t2) {\n      result += `[{${t1?.text ?? \"\"}}]`;\n    }\n    if (t2) {\n      result += `[{${t2.text}}]`;\n    }\n    return result;\n  }\n\n  mul() {\n    return \"*\";\n  }\n\n  colorBegin(color: string): string {\n    return `\\\\color{${color}}{`;\n  }\n\n  colorEnd() {\n    return \"}\";\n  }\n\n  override markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    const cmd = markupDict[type];\n    if (!cmd) return \"\";\n    return isOpen ? `${cmd}{` : \"}\";\n  }\n}\n\nconst markupDict: Record<string, string> = {\n  sup: \"^\",\n  sub: \"_\",\n};\n\nexport const rulesMhchem = Object.freeze(new RulesMhchem());\n","/* eslint-disable class-methods-use-this */\nimport { Char, Double, Int } from \"../types\";\nimport { RulesBase } from \"./RulesBase\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ifDef } from \"../utils/ifDef\";\n\n/*\nЭти правила дают не очень качественный результат.\nПока нет поддержки цветов. И некрасиво выводятся операции с подписями\n */\n\nconst specialCharacters = new Set([\n  \"'\",\n  \"*\",\n  \":\",\n  \"\\\\\",\n  \"_\",\n  \"{\",\n  \"|\",\n  \"}\",\n  \"~\",\n]);\n\nconst rtfChar = (src: Char): string => {\n  if (specialCharacters.has(src)) return `\\\\${src}`;\n  const code = src.charCodeAt(0);\n  if (code > 127) return `{\\\\cf2\\\\rtlch \\\\ltrch\\\\loch \\\\u${code}\\\\'3f}`;\n  return `${src}`;\n};\n\nconst escapeRTF = (text: string): string =>\n  Array.from(text).reduce((src, c) => src + rtfChar(c), \"\");\n\nconst subRTF = (text: string): string => `{\\\\sub ${escapeRTF(text)}}`;\nconst supRTF = (text: string): string => `{\\\\super ${escapeRTF(text)}}`;\n\nclass RulesRTF extends RulesBase {\n  agentK(k: ChemK): string {\n    return escapeRTF(String(k));\n  }\n\n  atom(id: string): string {\n    return id;\n  }\n\n  comment(text: string): string {\n    return escapeRTF(text);\n  }\n\n  custom(text: string): string {\n    return escapeRTF(text);\n  }\n\n  itemCount(k: ChemK): string {\n    return subRTF(String(k));\n  }\n\n  itemMass(mass: Double): string {\n    return supRTF(strMass(mass));\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return supRTF(strMass(mass)) + subRTF(String(num));\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return supRTF(charge.text);\n  }\n\n  operation(op: ChemOp): string {\n    // Пока не удалось найти нормальную реализацию для размещения комментов над и под стрелкой\n    let result = \"\";\n    ifDef(op.commentPre, (it) => {\n      result += supRTF(it.text);\n    });\n    result += escapeRTF(op.dstText);\n    ifDef(op.commentPost, (it) => {\n      result += subRTF(it.text);\n    });\n    return result;\n  }\n\n  radical(label: string): string {\n    return escapeRTF(label);\n  }\n}\n\nexport const rulesRTF = Object.freeze(new RulesRTF());\n\n/*\nДля поддержки цветов нужно вставить таблицу цветов\n{\\colortbl;\\red0\\green0\\blue0;\\red255\\green0\\blue0;}\nН.р, для красного цвета: {\\cf2 this is red text}\n */\n","import { ChemCharge } from \"../core/ChemCharge\";\nimport { RulesBase } from \"./RulesBase\";\n\nexport class RulesText extends RulesBase {\n  // eslint-disable-next-line class-methods-use-this\n  nodeCharge({ isLeft, text }: ChemCharge): string {\n    return isLeft ? `${text}^` : `^${text}`;\n  }\n}\n\n/**\n * Правила для текстового представления формул.\n * Эти правила обеспечивают минимальный набор возможностей для отображения формул.\n * Например, CH3-CH2-OH\n * Для того чтобы получить больше возможностей, рекомендуется использовать другие правила.\n * Например, HTML или MathJax/mhchem.\n */\nexport const rulesText = Object.freeze(new RulesText());\n","//  LT CU RT\n//     ##\n//     ##\n\nimport { normalize360 } from \"../math/angles\";\n\n//  LB    RB\nexport type CoeffPos = \"LT\" | \"RT\" | \"LB\" | \"RB\" | \"CU\" | \"CD\";\n\nexport const rxCoeffPos = /^LT|RT|LB|RB|CU|CD$/;\n\nexport type CoeffPosOrAngle = CoeffPos | number;\n\nexport const isLeftCoeff = (pos?: CoeffPos): boolean => pos?.[0] === \"L\";\n\nexport const isLeftCoeffA = (pos?: CoeffPosOrAngle): boolean => {\n  if (typeof pos === \"number\") {\n    const angle = normalize360(pos);\n    return angle > 90 && angle < 270;\n  }\n  return isLeftCoeff(pos);\n};\n","export const addAll = <T>(container: T[], appends: readonly T[]) =>\n  appends.forEach((it) => container.push(it));\n","export const addAllSet = <T>(container: Set<T>, appends: Set<T>) =>\n  Array.from(appends).forEach((it) => container.add(it));\n","export const cmp = <T>(a: T, b: T): -1 | 0 | 1 => {\n  if (a < b) return -1;\n  if (b < a) return 1;\n  return 0;\n};\n\nexport const cmpLess =\n  <T>(less: (first: T, second: T) => boolean) =>\n  (a: T, b: T): -1 | 0 | 1 => {\n    if (less(a, b)) return -1;\n    if (less(b, a)) return 1;\n    return 0;\n  };\n","import { ColorSamples } from \"./ColorSamples\";\n\nexport const withoutSharp = (value: string): string =>\n  value[0] === \"#\" ? value.slice(1) : value;\n\nexport const isColorHex = (value: string, sharp?: boolean): boolean => {\n  if (sharp === true && value[0] !== \"#\") return false;\n  if (sharp === false && value[0] === \"#\") return false;\n  return /^#?([\\dA-F]{3,4}|[\\dA-F]{6}|[\\dA-F]{8})$/i.test(value);\n};\n\nexport const colorHexIsShort = (value: string): boolean => {\n  const { length } = withoutSharp(value);\n  return length === 3 || length === 4;\n};\n\nexport const colorHexWithAlpha = (value: string): boolean => {\n  const { length } = withoutSharp(value);\n  return length === 4 || length === 8;\n};\n\nexport const colorHexSamples = (\n  value: string | undefined\n): ColorSamples | undefined => {\n  if (!value) return undefined;\n  const pure = withoutSharp(value);\n  let chunks: string[] | undefined;\n  switch (pure.length) {\n    case 3:\n    case 4:\n      chunks = pure.split(\"\").map((c) => c + c);\n      break;\n    case 6:\n      chunks = [0, 2, 4].map((n) => pure.slice(n, n + 2));\n      break;\n    case 8:\n      chunks = [0, 2, 4, 6].map((n) => pure.slice(n, n + 2));\n      break;\n    default:\n      break;\n  }\n  if (!chunks) return undefined;\n  const samples: number[] = chunks.map((s) => parseInt(s, 16));\n  if (samples.findIndex((n) => Number.isNaN(n)) >= 0) return undefined;\n  return {\n    r: samples[0]!,\n    g: samples[1]!,\n    b: samples[2]!,\n    a: samples[3],\n  };\n};\n","/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/named-color\n */\nexport const colorNamesMap: Record<string, string> = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  // transparent\tSee transparent.\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\",\n};\n\nexport const findColorByName = (name: string): string | undefined =>\n  colorNamesMap[name.toLowerCase()];\n","import { ColorRgb } from \"./Color\";\n\nexport const isColorRgb = (value: string): boolean =>\n  /^rgb\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*\\)$/i.test(value);\n\nexport const isColorRgba = (value: string): boolean =>\n  /^rgba\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*(1|0|0?\\.\\d+)\\s*\\)$/i.test(\n    value\n  );\n\nexport const colorRgbParse = (value: string): ColorRgb | undefined => {\n  const chunks = value.split(/[\\(\\),]/);\n  let srcSamples: string[] = [];\n  if (isColorRgb(value)) {\n    srcSamples = chunks.slice(1, 4);\n  } else if (isColorRgba(value)) {\n    srcSamples = chunks.slice(1, 5);\n  } else return undefined;\n  const sampleValues: number[] = srcSamples.map((s) => +s);\n  if (sampleValues.some((n) => Number.isNaN(n))) return undefined;\n  const color: ColorRgb = {\n    type: \"rgb\",\n    r: sampleValues[0]!,\n    g: sampleValues[1]!,\n    b: sampleValues[2]!,\n    a: sampleValues[3],\n  };\n  if (color.a) color.a *= 255;\n  return color;\n};\n","import { Color } from \"./Color\";\nimport { colorHexSamples } from \"./colorHex\";\nimport { findColorByName } from \"./colorNamesMap\";\nimport { ColorSamples } from \"./ColorSamples\";\nimport { traceColor } from \"./traceColor\";\n\nexport const getRgbSamples = (color: Color): ColorSamples | undefined =>\n  traceColor(color, {\n    name: (c) => colorHexSamples(findColorByName(c.name)),\n    hex: (c) => colorHexSamples(c.value),\n    rgb: ({ r, g, b, a }) => ({ r, g, b, a }),\n  });\n","import { Color } from \"./Color\";\nimport { isColorHex } from \"./colorHex\";\nimport { findColorByName } from \"./colorNamesMap\";\nimport { colorRgbParse } from \"./colorRgb\";\n\nexport const parseColorCss = (value: string | undefined): Color | undefined => {\n  if (!value) return undefined;\n  if (findColorByName(value))\n    return {\n      type: \"name\",\n      name: value,\n    };\n  if (isColorHex(value, true))\n    return {\n      type: \"hex\",\n      value,\n    };\n  return colorRgbParse(value);\n};\n","import { Color, ColorHex, ColorName, ColorRgb } from \"./Color\";\n\nexport interface ColorVisitor<Result = void> {\n  name(c: ColorName): Result;\n  hex(c: ColorHex): Result;\n  rgb(c: ColorRgb): Result;\n}\n\nexport const traceColor = <Result = void>(\n  color: Color,\n  visitor: ColorVisitor<Result>\n): Result => {\n  switch (color.type) {\n    case \"name\":\n      return visitor.name(color);\n    case \"hex\":\n      return visitor.hex(color);\n    case \"rgb\":\n      return visitor.rgb(color);\n    default:\n      break;\n  }\n  throw Error(`Invalid color = ${JSON.stringify(color)}`);\n};\n","export const delay = (ms: number): Promise<void> =>\n  new Promise<void>((resolve) => {\n    setTimeout(() => resolve(), ms);\n  });\n","export const getItemForced = <K extends string | number, V>(\n  record: Record<K, V>,\n  key: K,\n  defaultValue: V | (() => V)\n): V => {\n  const existingValue = record[key];\n  if (existingValue !== undefined) return existingValue;\n  const newValue: V =\n    // @ts-ignore\n    typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n  // eslint-disable-next-line no-param-reassign\n  record[key] = newValue;\n  return newValue;\n};\n","export const ifDef = <IN, OUT>(\n  value: IN | undefined,\n  onDef: (v: IN) => OUT\n): OUT | undefined => (value === undefined ? undefined : onDef(value));\n","export const isSubStr = (\n  text: string,\n  pos: number,\n  subStr: string\n): boolean => {\n  for (let i = 0; i < subStr.length; i++) {\n    if (text[pos + i] !== subStr[i]) return false;\n  }\n  return true;\n};\n","export const lastItem = <T>(list?: T[]): T | undefined =>\n  list ? list[list.length - 1] : undefined;\n","export const listToDict = <TValue, TKey extends string | number>(\n  list: TValue[],\n  makeKey: (v: TValue) => TKey\n): Record<TKey, TValue> =>\n  list.reduce(\n    (dict, item) => ({ ...dict, [makeKey(item)]: item }),\n    {} as Record<TKey, TValue>\n  );\n","import { isSubStr } from \"./isSubStr\";\n\n/**\n * Markup commands\n * \\color{...}\n * {\\color{...}...}\n * ^. or ^{...}\n * _. or _{...}\n */\nexport type MarkupChunkType = \"sub\" | \"sup\" | \"\";\n\nexport interface MarkupChunk {\n  type: MarkupChunkType;\n  color?: string;\n  chunks: (MarkupChunk | string)[];\n}\n\nexport const scanMarkupEnd = (\n  text: string,\n  start: number,\n  stopper: string\n): number => {\n  let level = 0;\n  let pos = start;\n  while (pos < text.length) {\n    const ch = text[pos++];\n    if (ch === stopper && level <= 0) break;\n    if (ch === \"{\") level++;\n    else if (ch === \"}\") level--;\n  }\n  return pos;\n};\n\nexport const parseMarkup = (\n  text: string,\n  topType: MarkupChunkType = \"\",\n  topColor: string | undefined = undefined\n): MarkupChunk => {\n  const chunks: (MarkupChunk | string)[] = [];\n  let pos = 0;\n  let prevPos = 0;\n  let color = topColor;\n  const updateLeftText = (lastPos: number) => {\n    if (lastPos > prevPos) {\n      const chunkText = text.slice(prevPos, lastPos);\n      chunks.push(\n        color === topColor\n          ? chunkText\n          : {\n              type: \"\",\n              color,\n              chunks: [chunkText],\n            }\n      );\n    }\n  };\n  const addChunk = (newType: MarkupChunkType) => {\n    if (pos === text.length) return;\n    updateLeftText(pos - 1);\n    const nextCh = text[pos++]!;\n    if (nextCh === \"{\") {\n      prevPos = pos;\n      pos = scanMarkupEnd(text, pos, \"}\");\n      const nested = parseMarkup(text.slice(prevPos, pos - 1), newType);\n      chunks.push(nested);\n    } else {\n      chunks.push({ type: newType, chunks: [nextCh] });\n    }\n    prevPos = pos;\n  };\n  const getColor = (start: number): string | undefined => {\n    const stop = text.indexOf(\"}\", start);\n    let newColor: string | undefined;\n    if (stop < 0) {\n      pos = start;\n      newColor = undefined;\n    } else {\n      newColor = text.slice(start, stop);\n      pos = stop + 1;\n    }\n    prevPos = pos;\n    return newColor;\n  };\n  while (pos < text.length) {\n    const ch = text[pos++];\n    if (ch === \"^\") {\n      addChunk(\"sup\");\n    } else if (ch === \"_\") {\n      addChunk(\"sub\");\n    } else if (ch === \"\\\\\" && isSubStr(text, pos, \"color{\")) {\n      // color for right text\n      updateLeftText(pos - 1);\n      const newColor = getColor(pos + 6);\n      if (newColor) color = newColor;\n    } else if (ch === \"{\" && isSubStr(text, pos, \"\\\\color{\")) {\n      // limited text\n      updateLeftText(pos - 1);\n      const newColor = getColor(pos + 7);\n      pos = scanMarkupEnd(text, pos, \"}\");\n      chunks.push(parseMarkup(text.slice(prevPos, pos - 1), \"\", newColor));\n      prevPos = pos;\n    }\n  }\n  updateLeftText(pos);\n  const res: MarkupChunk = { type: topType, chunks };\n  if (topColor) res.color = topColor;\n  return res;\n};\n\nexport interface ParamsMarkupFlat {\n  phase: \"open\" | \"close\" | \"full\";\n  chunk: MarkupChunk | string;\n  owner: MarkupChunk;\n}\nexport const markupFlat = (\n  m: MarkupChunk,\n  onChunk: (params: ParamsMarkupFlat) => void\n): void => {\n  m.chunks.forEach((chunk) => {\n    if (typeof chunk === \"string\") {\n      onChunk({ phase: \"full\", chunk, owner: m });\n    } else {\n      onChunk({ phase: \"open\", chunk, owner: m });\n      markupFlat(chunk, onChunk);\n      onChunk({ phase: \"close\", chunk, owner: m });\n    }\n  });\n};\n","export const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item);\n  if (pos >= 0) {\n    list.splice(pos, 1);\n  }\n};\n","import { Int } from \"../types\";\n\nexport const romanNum: Record<string, Int> = {\n  i: 1,\n  ii: 2,\n  iii: 3,\n  iv: 4,\n  v: 5,\n  vi: 6,\n  vii: 7,\n  viii: 8,\n};\n","import { XmlAttrs } from \"./xmlTypes\";\nimport { escapeXml } from \"./escapeXml\";\n\nexport const drawTag = (\n  tagName: string,\n  attrs?: XmlAttrs,\n  closed?: boolean,\n  escape?: (value: string) => string\n) => {\n  let result = `<${tagName}`;\n  if (attrs) {\n    const cvt = escape ?? escapeXml;\n    Object.keys(attrs).forEach((attrName) => {\n      result += ` ${attrName}=\"${cvt(attrs[attrName]!)}\"`;\n    });\n  }\n  if (closed) result += \" /\";\n  return `${result}>`;\n};\n","const dict: Record<string, string> = {\n  \"'\": \"apos\",\n  '\"': \"quot\",\n  \"&\": \"amp\",\n  \"<\": \"lt\",\n  \">\": \"gt\",\n  \"\\u00A0\": \"nbsp\",\n};\n\nexport const escapeXml = (\n  value: string,\n  nonAscii?: (code: number) => string\n): string =>\n  Array.from(value)\n    .map((char) => {\n      if (char in dict) {\n        return `&${dict[char]};`;\n      }\n      if (!nonAscii || (char >= \" \" && char <= \"~\")) {\n        return char;\n      }\n      const esc = nonAscii(char.charCodeAt(0));\n      return esc ? `&#${esc};` : char;\n    })\n    .join(\"\");\n\nexport const hexLow = (code: number) => `x${code.toString(16)}`;\n\nexport const dec = (code: number) => String(code);\n","/**\n * If you need to keep spaces at the ends, you need to replace them with special characters.\n * Otherwise, they will be ignored during output.\n *\n * Also, you can't use names like &nbsp; here. Because they will be escaped.\n *\n * @param text\n * @returns\n */\nexport const textInsideTag = (text: string): string =>\n  text.replace(/\\s+/g, \" \").replace(/(^ )|( $)/g, \"\\u00A0\");\n","export default [2, 2, 1];","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { addAutoCompileEvent } from \"./browser/autoCompile\";\nimport { ChemSys } from \"./ChemSys\";\nimport { PeriodicTable } from \"./core/PeriodicTable\";\n\nexport { ChemSys };\n\nif (typeof window !== \"undefined\") {\n  // @ts-ignore\n  window.ChemSys = ChemSys;\n  // deprecated. Used for compatibility with previous versions.\n  // @ts-ignore\n  window.MenTblArray = PeriodicTable.elements;\n  // @ts-ignore\n  window.MenTbl = PeriodicTable.dict;\n  addAutoCompileEvent();\n}\n"],"names":["ChemSys","Object","freeze","addDict","globalDict","Lang","ver","getVersion","verStr","getVersionStr","compile","formula","documentCompile","cfg","draw","owner","exprOrCode","config","renderFormulaCfg","makeSVG","fontPropsCache","expr","makeFormulaSvgText","makeTextFormula","objOrCode","rules","chemObj","dictTextRules","textFormula","fmtOrType","textTypesList","textTypes","makeBruttoKey","src","makeBrutto","lang","key","params","langId","tr","curLang","locale","navLang","Dict","dict","isAbstract","calcMass","applyAgentK","roundMass","mass","calcCharge","findElem","id","findElement","drawTable","drawPeriodicTable","findCategory","table","elemId","TblRules","Std","tableRulesStd","Wide","tableRulesWide","Short","tableRulesShort","EasyChemistry","tableRulesEasyChemistry","TblCategory","block","categoryBlock","blockDLa","categoryBlockDLa","props","categoryProps","drawTag","tag","attrs","content","undefined","escapeXml","String","esc","equalize","equation","eq","ChemEquation","initBySrc","solve","isSolved","getExpr","ChemExpr","createWithError","makeError","DrawSysIds","svg","canvas","addClass","elem","className","classList","add","cls","getAttribute","clsList","split","clsSet","Set","setAttribute","Array","from","join","WebFontCache","autoCompile","document","nodes","querySelectorAll","length","cfgNode","drawSys","drawSysId","toLowerCase","useText","useTextLow","nonText","addAutoCompileEvent","window","addEventListener","Promise","reject","Error","selector","formulaSelector","list","i","elementCompile","delay","e","resolve","code","textContent","innerText","renderFormulaCanvas","innerHTML","createElement","append","surface","HtmlCanvasSurface","createBrowserChemImgProps","renderTopFrame","buildFrame","isOk","getMessage","isTextFormula","renderFormulaSvg","src0","trim","SvgWebSurface","frame","bounds","exportText","width","height","tmp","body","standaloneExportOptions","remove","baseChainId","baseSubChainId","constructor","compiler","chainsDict","subChainsDict","curChainId","curSubChainId","stack","this","getLastBond","lastBond","onBranchBegin","unshift","onBranchEnd","shift","createChain","newChainId","getCurChain","createSubChain","newId","getCurSubChain","addNode","node","chain","push","subChain","setCurNode","addBond","bond","soft","mergeSubChains","dstId","srcId","step","forEach","it","pt","iadd","dstNodes","mergeChains","srcNode","dstNode","srcChainId","dstChainId","curAgent","filter","makeTransitionBond","dir","node1","bondToRef","srcSubChain","dstSubChain","minus","curNode","changeBondToHard","Point","closeChain","closeSubChain","findNode","find","equals","ChemCompiler","srcText","options","text","pos","curState","stateBegin","curPart","elementStartPos","chainSys","ChainSys","references","mulCounter","MulCounter","varsDict","curWidth","nodesBranch","NodesBranch","bracketsCtrl","BracketsCtrl","middlePoints","altFlag","varSlope","varLength","varPadding","centralNode","varDots","varPos","srcMap","item","pop","setAltFlag","getAltFlag","value","eject","v","curChar","nextChar","subStr","startPos","slice","isFinish","isCurPosEq","Math","min","error","msgId","newParams","ChemError","setState","newState","deltaPos","addSrcMapItem","obj","begin","part","end","createTestCompiler","prepareText","closeEntity","funcBackground","args","background","commands","ChemBackground","parseBackgroundArgs","shapeNames","arg","curPos","argt","isAll","divPos","indexOf","has","shape","fill","val","valPos","parseNodes","stroke","strokeWidth","parseNum","padding","parsePadding","borderRadius","nodesList","chunks","map","nodeDef","findNodeEx","funcC","funcColor","varColor","funcItemColor","varItemColor","funcItemColor1","varItemColor1","funcAtomColor","varAtomColor","funcAtomColor1","varAtomColor1","aligns","r","R","l","L","m","M","funcDblAlign","varAlign","rxCompact","splitDotPositions","descr","result","isRev","check2","match","n","checkEx","m1","n1","m2","n2","c","revSet","reduce","acc","delete","parseSingleDotArg","startsWith","cmd","color","margin","test","dirs","num","parseDotsArgs","dots","res","addPos","dotPos","angle","funcDots","funcL","funcM","varMass","funcPadding","funcPos","rxCoeffPos","funcSlope","toIntOrZero","s","parseVerParameter","a","b","verList","ifDef","v1","v2","verList2","funcVer","high","low","currentVersion","cur","need","funcnM","varAtomNumber","cvt","Number","isNaN","funcsDict","atomColor","atomColor1","bg","C","dblAlign","itemColor","itemColor1","nM","slope","queue","clear","onNode","onBracket","bracketCounter","onOpenBracket","mul","onCloseBracket","close","create","newMul","getMulForBracket","getMulForced","nbStack","copy","svNodes","onSubChain","addNodeItem","subObj","closeItem","ChemNodeItem","getItemColor","getAtomColor","atomNum","bCenter","getNodeForced","items","createAgent","preComm","agent","ChemAgent","onCreateEntity","entityBegin","curBond","openNode","closeNode","onCloseAgent","checkMul","checkMiddlePoints","checkBranch","finalUpdateBondsForNodes","finalUpdateAutoNodes","bonds","index","agentMode","star","closeBranch","startMul","scanCoeff","ChemK","stateAgentMid","walk","nodePre","autoMode","updateAutoNode","agentAnalyse","onDefault","pos0","scanSimpleBond","createSimpleBond","stateElement","stateCustom","stateCommentIn","stateAgentSpace","createLabel","stateNodeRef","stateCharge","stateFuncName","openBranch","openParentheses","openSquareBracket","closeBracketShort","comma","stateUniBond","instChemComma","horizAngles","correct","makeBondStep","isNeg","newAngleDeg","isCorr","calcPt","correctPrev","prevBond","fixed","corrNode","oldPos","reverse","autoCorrection","slopeSign","isAuto","is0","y","isHorizontal","createCommonBond","ChemBond","bindNodeToBond","chemBond","node0","auto0","isZero","plus","bindNodeToCurrentBond","findBondBetweenNodes","nodeA","nodeB","getNodeForBondStart","lastCmd","lastItem","bracketEnd","ChemBracketEnd","nodeIn","onOpenBond","oldNode","applyMiddlePoints","align","mergeBonds","oldBond","newBond","newNode","nbn0","nbn1","removeItem","createPolygonalBond","beginPos","mode","multiplicity","sign","strCount","isDigit","count","createPolygonStep","scanBondSuffix","tx","findRingNodes","nodesFull","j","lastIndexOf","findRingNodesEx","createRingBond","ext","isCycle","angleDegree","pointFromDeg","times","BondDef","bondId","calcDir","isText","soft1","soft3","bondDefDict","bondDef","curBondId","curBondDef","nodesInterval","refs","first","last","max","parseNodesListDef","valuePos","srcList","chunk","dstList","createSplineBond","argPos","scanArgs","makeParamsDict","setBondProperties","param","checkCycledList","autoLocateNodes","paramsList","substring","listToDict","calcPolygonDir","prevDir","pointFromRad","polarAngle","PI","defaultLength","parseRefsList","ref","paramPos","points","midPt","sum","vec","parseAxisCoordinate","isX","center","x","calcBondDirection","getLength","fromAngle","p","P","aParam","rad2deg","A","doubleBondSuffizes","parseBondMultiplicity","getMode","setCross","styleSuffixes","parseStyle","style","N","h","connection","T","setHydrogen","arr0","arr1","S","isGlobal","w","d","W","D","second","makePair","w0","w1","setWidth","createUniversalBond","BracketDecl","StackItem","super","msgInvalidClose","openBracket","stateBracketBegin","openBrace","ChemBracketBegin","bracketPairs","getNodeForBracketEnd","ChemMulEnd","closeBracket","decl","needCloseText","must","have","checkMulBeforeBracket","chargeOwner","ch","scanPostItem","BranchDecl","OpDef","dst","div","opCode","opsList","onCloseOp","curOp","createChemOp","def","op","ChemOp","commentPre","scanId","entity","curEntity","entities","elemNode","getLastItem","bondPoints","createMiddlePoint","k","isFirst","ChemMul","stopMul","existsNode","softBond","testDir","ChemNode","createBackground","PeriodicTable","multipleSum","countH","charge","round","H","createComment","scanComment","convertComment","ChemComment","scanTo","replaceLimited","firstLimiter","lastLimiter","transform","endPos","specChars","replace","replaceGreek","findPhrase","specCharsB","alpha","Alpha","beta","Beta","gamma","Gamma","delta","Delta","epsilon","Epsilon","zeta","Zeta","eta","Eta","theta","Theta","iota","Iota","kappa","Kappa","lambda","Lambda","mu","Mu","nu","Nu","xi","Xi","omicron","Omicron","pi","Pi","rho","Rho","sigma","Sigma","tau","Tau","upsilon","Upsilon","phi","Phi","chi","Chi","psi","Psi","omega","Omega","isSpace","numConstDict","$32","sqrt","$3","$3x2","$2","$22","$2x2","parseNumConst","invalidNumber","srcValue","name","useVariable","declareVariable","parseVariable","parseNumExt","values","mainPreProcess","scan","isValid","fin","p0","prev","level","addArg","bondSuffixes","rec","suffix","action","scanCharge","coeffPos","prevCharge","createCharge","getCoeffPos","isIdFirstChar","isIdChar","isId","scanInt","scanOp","nextPos","onCoeff","skipSpaces","globalMacros","PreProcCtx","aSrc","aPos","msg","errPos","errorPar","start","search","cond","stop","searchEx","write","writeFinish","bodyPreprocess","ctx","plain","defMacro","macro","Macros","applyParamValues","names","curIndex","paramValue","ready","exl","f","readRealParams","p1","scanPar","execMacros","ctx0","readFormalPars","ctx1","realParams","dummyBody","lock","isComment","getSrcItemsForObject","needObj","stateAgent","stateAgentBegin","coeff","stateAgentIn","stateCommentPre","opDef","stateOpEnd","isLeft","preCommPos","scanMarkupEnd","ChemRadical","ChemCustom","Elem","statePostItem","func","onReferenceError","bondNodesKey","useRef","curKey","useRefByNumber","atom","isAtomNode","useRefByAtom","useRefById","commentPost","bracketPos","ChemObj","stA","StructAnalyzer","setCoeff","visitor","agentPre","isStop","agentPost","ChemAtom","ChemSubObj","stable","epsilonMass","floor","brk","other","isCross","checkText","abs","linearText","debugText","polarAngleDeg","toFixed","toa","isVisible","isVerticalConnection","isNodeHidden","bracketBegin","getBracketsContent","ChemCharge","isLeftCoeffA","isRound","leftSigned","rightSigned","minuses","pluses","chargeDescr","romanNum","toUpperCase","ChemComma","comment","custom","getErrorMessage","err","oldLang","message","entityPre","entityPost","getAgents","findMapItems","target","srcMapItemText","applyK","html","poor","isLinear","NaN","isSpecified","isNumber","isInt","toString","one","mulEnd","zero","clone","nodePost","getCenterItem","curPriority","maxPriority","foundItem","itemPre","radical","itemPost","walkExt","dstText","operation","radicals","descriptions","label","newDict","left","right","elemList","ElemList","addElemById","isShortRadical","elemRec","chargeText","makeChargeText","findAtom","findById","findCustom","findKey","findRec","addElemRec","foundRec","ElemRecord","addAtom","addElem","addCustom","addList","addRadical","scale","sortByHill","sort","aid","bid","localeCompare","isCustom","k2s","elementsCache","dictCache","isotopesCache","isotopeDictCache","isotopesDict","elements","keys","massMap","finalMap","isotopes","isotopesDef","He","Li","Be","B","O","F","Ne","Na","Mg","Al","Si","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og","getCycleCenter","cy","vectorSign","q","calcBondSign","cycle","bondSideSign","side","nearBonds","isInit","cycles","bondsMap","analyze","NA","nodesMap","order","unwindCycle","usedNodes","nodesSet","curND","nextNode","nextND","cmp","createCycle","cyBonds","nextOrder","getItemForced","findCyclesForBond","c0","sFwd","sBkw","isEmptyNode","isTextBrackets","isTextBracketsCached","absCharge","stdStyle","line","hline","styles","thickWidth","chiralWidth","lineSpace2","lineSpace2x","lineSpace3","subKY","bracketSubKY","supKY","bracketSupKY","hatch","dash","arrowL","arrowD","opSpace","agentKSpace","mulChar","mulRadius","kw","flDblAlign","nodeMargin","bracketWidth","bracketSpace","useTextBrackets","electronDotD","horizLine","lineWidth","init","me","getFontHeight","font","getFontFace","ceil","getTextWidth","getStyle","styleName","getStyleColored","getIndexStyles","context","fontFace","textLine","canvasFont","measureText","drawLine","org","fillStyle","fillText","getCanvas","domElement","getCtx","htmlContext","fontCache","getContext","size","getFont","webProps","getWebProps","hash","HtmlCanvasLocalFont","applyStyle","translate","Matrix2x3","beginPath","strokeStyle","drawPath","segments","save","onM","moveTo","onL","lineTo","onQ","cp","quadraticCurveTo","onC","cp1","cp2","bezierCurveTo","onA","xRot","largeArc","sweep","tracePath","restore","drawEllipse","offset","radius","ellipse","setSize","SvgWebLocalFont","webFontProps","createScaled","newProps","cssHeight","scaleFontFace","makeCanvasFontProp","bold","italic","fontFamily","addFigure","SvgSurface","svgLocFont","cache","createLocalFontHash","makeWebFontProps","fontStyleChunks","family","fontWeight","webFontWeight","weight","vOffset","testHeight","testWidth","baseline","isBold","textBaseline","mZ","mz","trace","letter","toBottom","clearRect","info","getImageData","traceBox","data","xHeight","actualBoundingBoxAscent","capHeight","ascent","descent","actualBoundingBoxDescent","bbox","fontBoundingBoxDescent","fontBoundingBoxAscent","fontStyle","pixels","finish","best","fontWeightValue","rulesList","doc","findComputedStyle","defaultView","getComputedStyle","element","currentStyle","span","createStyle","htmlCode","firstChild","Element","cssStyle","fontProps","fontSize","stretch","fontStretch","appendChild","ChemImgProps","createRulesList","rulesHtml","curStyle","FigBSpline","Figure","segmentLength","bDashed","update","rect","updateRect","Rect","segs","bCycled","sumLen","edgesLen","len","dist","nSegs","curEdge","newEdge","a3","a2","a1","a0","edgeK","isub","t","extendsPoints","srcPoints","bCyclic","preLast","dstPoints","newLast","firstStep","lastStep","FigEllipse","neg","FigFrame","figures","fig","updateFigure","insertFigure","splice","unite","getRelativeBounds","figBounds","FigHashTrapezoid","aWidth","bWidth","dL","dR","calcTrapezoidDir","aL","aR","bL","bR","calcTrapezoidPoints","updatePoint","makeHashTrapezoidPath","dirLen","dir1","transpon","aw2","bw2","srcWidth","dstWidth","minW","dW","hatchLen","desiredStep","stripCount","dStep","t1","w2","p0L","p0R","p1L","p1R","FigPath","rc","grow","createLine","FigRect","drawRect","FigText","ff","baseLine","getBaseline","move","desiredRect","drawTriple","leftTop","leftMid","leftBottom","closeBrace","rightTop","rightMid","rightBottom","top","mid","bot","topConn","botConn","topCa","topCb","midCa","midCb","midCc","botCc","build","setPt","mini","maxi","kx","ky","set","scalePath","drawRubberFigure","rubberFig","imgProps","closeSquareBracket","getRubberBracket","isOpen","sWidth","sHeight","sThickH","sThickV","pathAttrs","cap","repr","defs","path","pathToString","rx","ry","cx","xmlCode","addDef","buildSvgText","xml","version","encoding","standalone","doctype","xmlns","baseProfile","rootAttrs","viewBox","excludeVerInfo","defsList","agentK","itemCount","itemMass","nodeCharge","bracketCharge","bracketCount","used","styleId","seg","dstSeg","rel","addPoint","cpPrev","getPoint","calcCP","onZ","curPoint","onH","onV","dstPoint","dictReady","newSolveItem","dstCol","state","agents","nCols","solves","equationDict","getSolves","initByExpr","isSuitableForEquation","parts","makeElemList","leftPart","rightPart","elemRes","checkElementsMatching","Rational","elemIndex","col","row","getMatrix","getMatrixStr","calcStep","simpleSolve","nRow","findRowForAction","onSimpleSolve","deleteMatrixRow","try2RowsUnit","searchKoeffs","rowIndex","k0Index","k1Index","srcRow","negx","divi","solveItem","srcCol","addi","mulx","findIndex","filledNdx","col0","col1","getUnknownIndices","calcSolves","optimizeKoeffs","checkKoeffs","checkBalance","finalSolve","numCoeffs","newSrc","makeSourceWithNewCoeffs","found","notFound","si","comm","nod","calcAbsMCD","ki","maxX","balance","it0","it1","colNdx","row0","row1","mul0","mul1","sitem","subi","unknownIndices","gen","makeCoeffEnumerator","vars","testKoeffs","unknownIndexes","variants","uIndex","partId","E","coeffEnumerator2d","x0","y0","coeffEnumerator3d","z","z0","coeffEnumeratorNd","dimension","maxLevel","maxMask","mask","subLevelNdx","sn","subVals","dimesion","ru","en","msgAbs","reason","coeffs","oldSrc","prevPos","agentIndex","agentItems","itemsCount","leftPos","calc","listItem","IsAbstractVisitor","isAbstractCoeffs","isAbsK","useItems","locateAtomNumber","ignoreAgentK","l2r","rulesText","ctxOut","space","isLtr","drawCharge","isPrefix","autoNode","rawAtomNum","itemMassAndNum","itemCharge","mulK","nonOptimized","buildTextFromChunks","postProcess","chunkItem","needOpen","needClose","colorBegin","colorEnd","makeTextFormulaSrc","sourceText","curDict","enDict","replaceLangParams","globalDictUpdates","entries","locDict","ruDict","baseDictRu","baseDictEn","navigator","language","browserLanguage","userLanguage","loc","$Native","$English","Group","Period","Row","Lanthanides","Actinides","Metalloids","Halogens","fnParams","getValue","endsWith","divider","createIdentity","createZero","moveX","moveY","scaleX","scaleY","rotate","radians","cosA","cos","sinA","sin","rotateDeg","degrees","deg2rad","apply","deltaX","deltaY","atan2","lengthSqr","distSqr","normal","ccw","staticZero","absLess","absx","norm","addx","subx","muli","divx","bx","by","bottom","isEmpty","moveXY","contains","realDeltaY","clip","x1","y1","x2","y2","makeOutcodes","mkMask","ocu1","ocu2","inside","outside","isSwap","isMask","p2","srcRect","normalize360","degAngle","isClose","strMass","angleInRadians","angleInDegrees","getNodeCenterPos","nodeInfo","nodeFrame","getNodeInfo","nodesInfo","applyPadding","pads","dx","clipLine","ptInside","ptOutside","clipLineByNode","nodeRes","rcNodeCore","isPadding","doubleBond","d1","styleL","styleR","left1","right1","wL","getBondStyleWidth","wR","aSign","getAlignSign","singleLine","drawBezierBond","res0","res1","rect0","rect1","c1","wPoints","vpt","wpt","getBondColor","drawBondArrow","drawBond","drawBondPoly","bondA","bondB","drawBondAB","wedgeBond","stList","tripleBond","cL","calcCenter","bPoints","styleDef","lnStyle","drawWaveLine","drawDashedLine","srcSpace","dstSpace","ampl","arrLen","wp0","wp1","vAmp","segDir","segLen","softBondTemplate","vDir","field","styleLeft","styleCenter","styleRight","wC","left0","right0","canPush","postExec","onPrevious","AgentCmdBrClose","AgentCmd","srcCmd","isCanUnwindNext","unwind","AgentCmdBrOpen","processBrackets","isBridge","checkRtl","rtlNode","rtlNodes","endNode","AgentCmdBridge","dstCmd","beginNode","prevBracket","AgentCmdNode","prevText","nodeBond","createAgentCmdMul","AgentCmdMul","AgentCmdMulBridge","ni","cluster","clusters","findByNode","figK","createCoeff","figure","isPrevBox","isNextBox","bridgeFrame","mFont","mStyle","mFields","figMul","drawMul","srcConn","allBox","yBase","yMiddle","br","n0","ni0","isBothText","isRealText","makeBridge","AgentCmdSoftBond","dstConn","srcNodeInfo","dstNodeInfo","srcBase","srcH","dstH","connPt","insertToCluster","getClusterBoxConnection","getClusterConnection","rcNode","calcOffset","isBothBaseline","calcOffsetAbs","mergeClusters","srcCluster","dstCluster","addAllSet","findByIndex","nodeIndex","clusterIndex","cl","bAbs","dstPos","leftToRight","uniteRest","cmdStack","Clusters","backs","agentFrame","bracketCoeffs","type","drawTextNear","rcCore","drawBracket","bracket","contentRect","figText","getTextInternalRect","textBracket","rubberBracket","isSrcBracket","dy","flAbs","b0","b1","cmdOpen","cmdClose","beginNi","endNi","isText0","contentRect0","rcRel","calcBracketRect","contentRect1","xPad","open","isLeftCoeff","figOpen","figClose","buildAgentPrior","PAgentCtx","prepareNodes","processCommands","drawAllBonds","drawBackground","findAgentCenter","kStyle","irc","createAgentCmd","calcBgRect","makeBackFigure","r0","srcNodes","maxSqr","cc","calcRadius","calcAB","createBgEllipse","createBgRect","calcExplicitCenter","findExplicitlyCentred","monoCycle","findDefaultCenter","allNodesInfo","expNodesInfo","centers","findDefaultY","maxCount","buildNode","previousCmd","canPop","head","buildExpression","einfo","opFrame","buildOp","buildItem","itemFrame","itemFont","onText","txFig","drawText","onMarkup","textWithMarkup","figM","drawTextWithMarkup","drawIndex","atomNumber","pr","drawLewisShell","dotColor","figDot","centerItem","comms","buildOpComment","commWidth","com","drawFn","opDict","opTextFigure","figOp","addOpComment","makeStrokeStyle","mathArrWorldDx","mathRightArrowCommands","mathLeftArrowCommands","mathArrow","drawSegs","minWidth","arrDx","makeMathCoordCvt","drawMathRightSegs","drawMathLeftSegs","drawMathBiSegs","drawMathBothSegs","isFilledArrow","lineLen","figLine","tri","triStyle","figArrow","opRect","isTop","tp","figTxt","drawSpecialCharge","lw","maxY","lw2","figCharge","figR","rcFig","moveNearFigure","calcPos","onDot","rcCur","pExt","fn","getShiftCoeff","makeRectExt","rcCoreExt","sp","figFF","drawMarkup","xSup","xSub","updateX","subChunk","isSup","newFont","rsFig","dY","newStyle","stdH","subH","parseMarkup","class","fieldsDict","number","stdOut","fields","tables","NCol","NRow","category","hardNotes","tblN","drawGroups","fallingNumbers","groupIds","groupCls","tableCls","elementBoxCls","periodCols","groupRows","flLanAct","notes","categoryExt","subGroup","cells","actualTables","tdef","t0","rowspan","colspan","drawPeriods","post","flGroups","flPeriods","pre","ofsX","ofsY","cellFields","cellRender","CellRender","srcItem","h1","grpMaps","curCat","catDict","catName","catValues","isArray","catValue","G","gm","grp","LanActMap","curTable","beginTable","X","GrpCache","Map","revMap","categoryKey","pkList","curCategory","cat","get","s_block","p_block","d_block","f_block","f2_block","subgr_a","subgr_b","addItemProps","addItem","kType","atomMass","buildTextNodes","srcExpr","rootNode","groupType","addItemTo","pushLevel","pushGroupLevel","popLevel","prevEntity","firstItem","addSpace","curEntityType","spaceType","correctBondsDirection","splitRichText","itemNode","createTextOp","cloneTextNode","groupNode","some","opItem","colItem","columnType","dictKeys","optimizeColors","getList","nodeColor","subColors","aColors","splitColumn","textColor","needSrc","onChunk","locColor","groupScripted","ungrouped","grouped","optimized","group","scriptKeys","LT","RT","LB","RB","splitScripts","addFunc","funcs","funcStr","buildCharChemText","buildCharChemTextNodes","flatList","correctItemColor","makeFlat","setFlatColors","setAtomColors","cctn2str","colorType","subNode","atoms","groups","prevGroup","gr","prevColor","onTextNode","addText","fromDict","bondDict","brackets","onGroup","chargePosDict","onItem","kOrder","cmpOrder","chargePos","stdTagsMap","htmlPoor","htmlPoorNodes","hideSpanNodes","renderXmlNodes","noSelfClosed","hideSpans","createHtmlPoorNodes","textTag","makeScripted","makeComplexOp","optGroupTag","specTag","makeItem","operationCode","makeRichText","textInsideTag","flatMap","tags","makeCenter","scr","opComments","onComment","textNodes","scriptTag","addAll","oxidationState","htmlRichCls","clsCode","buildHtmlRich","createHtmlRichNodes","cchOperation","arrow","cchArrowTag","arrows","makeCchTag","longRightArrow","longLeftArrow","bothArrowsLeft","bothArrowsRight","preserveAspectRatio","bondMap","makeCharge","makeGroup","hasOver","optionalGroup","addClassToXmlNode","makeColumn","addScripts","colItems","includes","splitChargeText","opComment","opContainer","setAttr","idGen","txtNode","mathMLRootAttrs","ns","namespace","buildMathML","createMathMLNode","optimizeXmlColors","mathItem","mathText","textMode","mathColumn","customCtx","mathOptRow","customNode","lspace","rspace","mathScripted","onNodeItem","stdOp","mathRichText","stdOpsDict","xC","xB","xT","mathvariant","createCenter","colDict","scripted","buildTeX","createTexFromNode","extOp","noMhchem","texColor","onScripted","onComplexOp","onColumn","applyRichText","escapeTex","onRichText","replaceSpecialTeXSymbols","getTexColor","dstColor","inPredefined","colors","parseColorCss","getRgbSamples","findNearestColor","g","texColors","onCmd","scripts","optimizedCmd","onColumnExt","cvtParam","secondary","primary","complex","isComplexOp","mhchem","above","below","opNode","comments","mhchemOpsDict","texComplexOps","texSimpleOps","cacheDict","regEx","getData","cacheRegEx","uChar","codes","RegExp","red","green","blue","minDist","MAX_SAFE_INTEGER","predefined","dr","dg","db","fmt","textNode","indent","htmlOptions","buildTextFormat","mmlOptions","renderXmlNode","strNode","strScripted","strExtOp","strItems","strNodeItem","strOp","strRichText","operations","opDictAscii","commMode","commCvt","where","centerItems","oxMode","scriptDivider","oxPos","sPos","oxPosToScript","oldScr","newScr","strSup","strSub","sup","sub","newList","oldList","canSelfClosed","attrsExt","addStr","str","strLevel","repeat","xc","useMarkup","markupSection","topChunk","markupFlat","phase","bb","rulesBB","charChem","rulesCharChem","rulesMhchem","rtf","rulesRTF","RulesBB","RulesBase","exportCoeff","RulesCharChem","RulesHtml","markupTagDict","RulesMhchem","t2","markupDict","specialCharacters","escapeRTF","charCodeAt","rtfChar","subRTF","supRTF","RulesRTF","RulesText","container","appends","cmpLess","less","withoutSharp","isColorHex","sharp","colorHexIsShort","colorHexWithAlpha","colorHexSamples","pure","samples","parseInt","colorNamesMap","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","findColorByName","isColorRgb","isColorRgba","colorRgbParse","srcSamples","sampleValues","traceColor","hex","rgb","JSON","stringify","ms","setTimeout","record","defaultValue","existingValue","newValue","onDef","isSubStr","makeKey","stopper","topType","topColor","updateLeftText","lastPos","chunkText","addChunk","newType","nextCh","nested","getColor","newColor","ii","iii","iv","vi","vii","viii","tagName","closed","escape","attrName","nonAscii","char","hexLow","dec","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","MenTblArray","MenTbl"],"sourceRoot":""}